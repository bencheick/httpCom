{"version":3,"file":"compiler.js","sources":["../../../packages/compiler/src/core.js","../../../packages/compiler/src/util.js","../../../packages/compiler/src/version.js","../../../packages/compiler/src/template_parser/template_ast.js","../../../packages/compiler/src/config.js","../../../packages/compiler/src/aot/static_symbol.js","../../../packages/compiler/src/compile_metadata.js","../../../packages/compiler/src/ast_path.js","../../../packages/compiler/src/ml_parser/ast.js","../../../packages/compiler/src/assertions.js","../../../packages/compiler/src/ml_parser/interpolation_config.js","../../../packages/compiler/src/style_url_resolver.js","../../../packages/compiler/src/ml_parser/tags.js","../../../packages/compiler/src/template_parser/template_preparser.js","../../../packages/compiler/src/directive_normalizer.js","../../../packages/compiler/src/directive_resolver.js","../../../packages/compiler/src/chars.js","../../../packages/compiler/src/expression_parser/lexer.js","../../../packages/compiler/src/expression_parser/ast.js","../../../packages/compiler/src/expression_parser/parser.js","../../../packages/compiler/src/parse_util.js","../../../packages/compiler/src/ml_parser/lexer.js","../../../packages/compiler/src/ml_parser/parser.js","../../../packages/compiler/src/i18n/digest.js","../../../packages/compiler/src/i18n/i18n_ast.js","../../../packages/compiler/src/ml_parser/html_tags.js","../../../packages/compiler/src/i18n/serializers/placeholder.js","../../../packages/compiler/src/i18n/i18n_parser.js","../../../packages/compiler/src/i18n/parse_util.js","../../../packages/compiler/src/i18n/extractor_merger.js","../../../packages/compiler/src/ml_parser/xml_tags.js","../../../packages/compiler/src/ml_parser/xml_parser.js","../../../packages/compiler/src/i18n/serializers/serializer.js","../../../packages/compiler/src/i18n/serializers/xml_helper.js","../../../packages/compiler/src/i18n/serializers/xliff.js","../../../packages/compiler/src/i18n/serializers/xliff2.js","../../../packages/compiler/src/i18n/serializers/xmb.js","../../../packages/compiler/src/i18n/serializers/xtb.js","../../../packages/compiler/src/ml_parser/html_parser.js","../../../packages/compiler/src/i18n/translation_bundle.js","../../../packages/compiler/src/i18n/i18n_html_parser.js","../../../packages/compiler/src/aot/util.js","../../../packages/compiler/src/identifiers.js","../../../packages/compiler/src/lifecycle_reflector.js","../../../packages/compiler/src/selector.js","../../../packages/compiler/src/metadata_resolver.js","../../../packages/compiler/src/output/output_ast.js","../../../packages/compiler/src/provider_analyzer.js","../../../packages/compiler/src/output/value_util.js","../../../packages/compiler/src/view_compiler/provider_compiler.js","../../../packages/compiler/src/ng_module_compiler.js","../../../packages/compiler/src/ng_module_resolver.js","../../../packages/compiler/src/output/source_map.js","../../../packages/compiler/src/output/abstract_emitter.js","../../../packages/compiler/src/output/ts_emitter.js","../../../packages/compiler/src/pipe_resolver.js","../../../packages/compiler/src/schema/dom_security_schema.js","../../../packages/compiler/src/schema/element_schema_registry.js","../../../packages/compiler/src/schema/dom_element_schema_registry.js","../../../packages/compiler/src/shadow_css.js","../../../packages/compiler/src/style_compiler.js","../../../packages/compiler/src/ml_parser/html_whitespaces.js","../../../packages/compiler/src/ml_parser/icu_ast_expander.js","../../../packages/compiler/src/template_parser/binding_parser.js","../../../packages/compiler/src/template_parser/template_parser.js","../../../packages/compiler/src/compiler_util/expression_converter.js","../../../packages/compiler/src/view_compiler/type_check_compiler.js","../../../packages/compiler/src/view_compiler/view_compiler.js","../../../packages/compiler/src/i18n/message_bundle.js","../../../packages/compiler/src/aot/generated_file.js","../../../packages/compiler/src/aot/lazy_routes.js","../../../packages/compiler/src/aot/summary_serializer.js","../../../packages/compiler/src/aot/compiler.js","../../../packages/compiler/src/aot/static_reflector.js","../../../packages/compiler/src/aot/static_symbol_resolver.js","../../../packages/compiler/src/aot/summary_resolver.js","../../../packages/compiler/src/aot/compiler_factory.js","../../../packages/compiler/src/summary_resolver.js","../../../packages/compiler/src/output/output_interpreter.js","../../../packages/compiler/src/output/abstract_js_emitter.js","../../../packages/compiler/src/output/output_jit.js","../../../packages/compiler/src/jit/compiler.js","../../../packages/compiler/src/compile_reflector.js","../../../packages/compiler/src/url_resolver.js","../../../packages/compiler/src/resource_loader.js","../../../packages/compiler/src/i18n/extractor.js","../../../packages/compiler/src/i18n/index.js","../../../packages/compiler/src/compiler.js","../../../packages/compiler/public_api.js","../../../packages/compiler/compiler.js"],"sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\nexport function Inject() { }\nfunction Inject_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Inject.prototype.token;\n}\nexport const /** @type {?} */ createInject = makeMetadataFactory('Inject', (token) => ({ token }));\nexport const /** @type {?} */ createInjectionToken = makeMetadataFactory('InjectionToken', (desc) => ({ _desc: desc }));\n/**\n * @record\n */\nexport function Attribute() { }\nfunction Attribute_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Attribute.prototype.attributeName;\n}\nexport const /** @type {?} */ createAttribute = makeMetadataFactory('Attribute', (attributeName) => ({ attributeName }));\n/**\n * @record\n */\nexport function Query() { }\nfunction Query_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Query.prototype.descendants;\n    /** @type {?} */\n    Query.prototype.first;\n    /** @type {?} */\n    Query.prototype.read;\n    /** @type {?} */\n    Query.prototype.isViewQuery;\n    /** @type {?} */\n    Query.prototype.selector;\n}\nexport const /** @type {?} */ createContentChildren = makeMetadataFactory('ContentChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: false, descendants: false }, data)));\nexport const /** @type {?} */ createContentChild = makeMetadataFactory('ContentChild', (selector, data = {}) => (Object.assign({ selector, first: true, isViewQuery: false, descendants: true }, data)));\nexport const /** @type {?} */ createViewChildren = makeMetadataFactory('ViewChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: true, descendants: true }, data)));\nexport const /** @type {?} */ createViewChild = makeMetadataFactory('ViewChild', (selector, data) => (Object.assign({ selector, first: true, isViewQuery: true, descendants: true }, data)));\n/**\n * @record\n */\nexport function Directive() { }\nfunction Directive_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Directive.prototype.selector;\n    /** @type {?|undefined} */\n    Directive.prototype.inputs;\n    /** @type {?|undefined} */\n    Directive.prototype.outputs;\n    /** @type {?|undefined} */\n    Directive.prototype.host;\n    /** @type {?|undefined} */\n    Directive.prototype.providers;\n    /** @type {?|undefined} */\n    Directive.prototype.exportAs;\n    /** @type {?|undefined} */\n    Directive.prototype.queries;\n}\nexport const /** @type {?} */ createDirective = makeMetadataFactory('Directive', (dir = {}) => dir);\n/**\n * @record\n */\nexport function Component() { }\nfunction Component_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Component.prototype.changeDetection;\n    /** @type {?|undefined} */\n    Component.prototype.viewProviders;\n    /** @type {?|undefined} */\n    Component.prototype.moduleId;\n    /** @type {?|undefined} */\n    Component.prototype.templateUrl;\n    /** @type {?|undefined} */\n    Component.prototype.template;\n    /** @type {?|undefined} */\n    Component.prototype.styleUrls;\n    /** @type {?|undefined} */\n    Component.prototype.styles;\n    /** @type {?|undefined} */\n    Component.prototype.animations;\n    /** @type {?|undefined} */\n    Component.prototype.encapsulation;\n    /** @type {?|undefined} */\n    Component.prototype.interpolation;\n    /** @type {?|undefined} */\n    Component.prototype.entryComponents;\n    /** @type {?|undefined} */\n    Component.prototype.preserveWhitespaces;\n}\n/** @enum {number} */\nconst ViewEncapsulation = {\n    Emulated: 0,\n    Native: 1,\n    None: 2,\n};\nexport { ViewEncapsulation };\nViewEncapsulation[ViewEncapsulation.Emulated] = \"Emulated\";\nViewEncapsulation[ViewEncapsulation.Native] = \"Native\";\nViewEncapsulation[ViewEncapsulation.None] = \"None\";\n/** @enum {number} */\nconst ChangeDetectionStrategy = {\n    OnPush: 0,\n    Default: 1,\n};\nexport { ChangeDetectionStrategy };\nChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = \"OnPush\";\nChangeDetectionStrategy[ChangeDetectionStrategy.Default] = \"Default\";\nexport const /** @type {?} */ createComponent = makeMetadataFactory('Component', (c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)));\n/**\n * @record\n */\nexport function Pipe() { }\nfunction Pipe_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Pipe.prototype.name;\n    /** @type {?|undefined} */\n    Pipe.prototype.pure;\n}\nexport const /** @type {?} */ createPipe = makeMetadataFactory('Pipe', (p) => (Object.assign({ pure: true }, p)));\n/**\n * @record\n */\nexport function Input() { }\nfunction Input_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Input.prototype.bindingPropertyName;\n}\nexport const /** @type {?} */ createInput = makeMetadataFactory('Input', (bindingPropertyName) => ({ bindingPropertyName }));\n/**\n * @record\n */\nexport function Output() { }\nfunction Output_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Output.prototype.bindingPropertyName;\n}\nexport const /** @type {?} */ createOutput = makeMetadataFactory('Output', (bindingPropertyName) => ({ bindingPropertyName }));\n/**\n * @record\n */\nexport function HostBinding() { }\nfunction HostBinding_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    HostBinding.prototype.hostPropertyName;\n}\nexport const /** @type {?} */ createHostBinding = makeMetadataFactory('HostBinding', (hostPropertyName) => ({ hostPropertyName }));\n/**\n * @record\n */\nexport function HostListener() { }\nfunction HostListener_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    HostListener.prototype.eventName;\n    /** @type {?|undefined} */\n    HostListener.prototype.args;\n}\nexport const /** @type {?} */ createHostListener = makeMetadataFactory('HostListener', (eventName, args) => ({ eventName, args }));\n/**\n * @record\n */\nexport function NgModule() { }\nfunction NgModule_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    NgModule.prototype.providers;\n    /** @type {?|undefined} */\n    NgModule.prototype.declarations;\n    /** @type {?|undefined} */\n    NgModule.prototype.imports;\n    /** @type {?|undefined} */\n    NgModule.prototype.exports;\n    /** @type {?|undefined} */\n    NgModule.prototype.entryComponents;\n    /** @type {?|undefined} */\n    NgModule.prototype.bootstrap;\n    /** @type {?|undefined} */\n    NgModule.prototype.schemas;\n    /** @type {?|undefined} */\n    NgModule.prototype.id;\n}\nexport const /** @type {?} */ createNgModule = makeMetadataFactory('NgModule', (ngModule) => ngModule);\n/**\n * @record\n */\nexport function ModuleWithProviders() { }\nfunction ModuleWithProviders_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ModuleWithProviders.prototype.ngModule;\n    /** @type {?|undefined} */\n    ModuleWithProviders.prototype.providers;\n}\n/**\n * @record\n */\nexport function SchemaMetadata() { }\nfunction SchemaMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SchemaMetadata.prototype.name;\n}\nexport const /** @type {?} */ CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\nexport const /** @type {?} */ NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\nexport const /** @type {?} */ createOptional = makeMetadataFactory('Optional');\nexport const /** @type {?} */ createInjectable = makeMetadataFactory('Injectable');\nexport const /** @type {?} */ createSelf = makeMetadataFactory('Self');\nexport const /** @type {?} */ createSkipSelf = makeMetadataFactory('SkipSelf');\nexport const /** @type {?} */ createHost = makeMetadataFactory('Host');\nexport const /** @type {?} */ Type = Function;\n/** @enum {number} */\nconst SecurityContext = {\n    NONE: 0,\n    HTML: 1,\n    STYLE: 2,\n    SCRIPT: 3,\n    URL: 4,\n    RESOURCE_URL: 5,\n};\nexport { SecurityContext };\nSecurityContext[SecurityContext.NONE] = \"NONE\";\nSecurityContext[SecurityContext.HTML] = \"HTML\";\nSecurityContext[SecurityContext.STYLE] = \"STYLE\";\nSecurityContext[SecurityContext.SCRIPT] = \"SCRIPT\";\nSecurityContext[SecurityContext.URL] = \"URL\";\nSecurityContext[SecurityContext.RESOURCE_URL] = \"RESOURCE_URL\";\n/** @enum {number} */\nconst NodeFlags = {\n    None: 0,\n    TypeElement: 1,\n    TypeText: 2,\n    ProjectedTemplate: 4,\n    CatRenderNode: 3,\n    TypeNgContent: 8,\n    TypePipe: 16,\n    TypePureArray: 32,\n    TypePureObject: 64,\n    TypePurePipe: 128,\n    CatPureExpression: 224,\n    TypeValueProvider: 256,\n    TypeClassProvider: 512,\n    TypeFactoryProvider: 1024,\n    TypeUseExistingProvider: 2048,\n    LazyProvider: 4096,\n    PrivateProvider: 8192,\n    TypeDirective: 16384,\n    Component: 32768,\n    CatProviderNoDirective: 3840,\n    CatProvider: 20224,\n    OnInit: 65536,\n    OnDestroy: 131072,\n    DoCheck: 262144,\n    OnChanges: 524288,\n    AfterContentInit: 1048576,\n    AfterContentChecked: 2097152,\n    AfterViewInit: 4194304,\n    AfterViewChecked: 8388608,\n    EmbeddedViews: 16777216,\n    ComponentView: 33554432,\n    TypeContentQuery: 67108864,\n    TypeViewQuery: 134217728,\n    StaticQuery: 268435456,\n    DynamicQuery: 536870912,\n    CatQuery: 201326592,\n    // mutually exclusive values...\n    Types: 201347067,\n};\nexport { NodeFlags };\n/** @enum {number} */\nconst DepFlags = {\n    None: 0,\n    SkipSelf: 1,\n    Optional: 2,\n    Value: 8,\n};\nexport { DepFlags };\n/** @enum {number} */\nconst ArgumentType = { Inline: 0, Dynamic: 1, };\nexport { ArgumentType };\n/** @enum {number} */\nconst BindingFlags = {\n    TypeElementAttribute: 1,\n    TypeElementClass: 2,\n    TypeElementStyle: 4,\n    TypeProperty: 8,\n    SyntheticProperty: 16,\n    SyntheticHostProperty: 32,\n    CatSyntheticProperty: 48,\n    // mutually exclusive values...\n    Types: 15,\n};\nexport { BindingFlags };\n/** @enum {number} */\nconst QueryBindingType = { First: 0, All: 1, };\nexport { QueryBindingType };\n/** @enum {number} */\nconst QueryValueType = {\n    ElementRef: 0,\n    RenderElement: 1,\n    TemplateRef: 2,\n    ViewContainerRef: 3,\n    Provider: 4,\n};\nexport { QueryValueType };\n/** @enum {number} */\nconst ViewFlags = {\n    None: 0,\n    OnPush: 2,\n};\nexport { ViewFlags };\n/** @enum {number} */\nconst MissingTranslationStrategy = {\n    Error: 0,\n    Warning: 1,\n    Ignore: 2,\n};\nexport { MissingTranslationStrategy };\nMissingTranslationStrategy[MissingTranslationStrategy.Error] = \"Error\";\nMissingTranslationStrategy[MissingTranslationStrategy.Warning] = \"Warning\";\nMissingTranslationStrategy[MissingTranslationStrategy.Ignore] = \"Ignore\";\n/**\n * @record\n */\nexport function MetadataFactory() { }\nfunction MetadataFactory_tsickle_Closure_declarations() {\n    /* TODO: handle strange member:\n    (...args: any[]): T;\n    */\n    /** @type {?} */\n    MetadataFactory.prototype.isTypeOf;\n    /** @type {?} */\n    MetadataFactory.prototype.ngMetadataName;\n}\n/**\n * @template T\n * @param {?} name\n * @param {?=} props\n * @return {?}\n */\nfunction makeMetadataFactory(name, props) {\n    const /** @type {?} */ factory = (...args) => {\n        const /** @type {?} */ values = props ? props(...args) : {};\n        return Object.assign({ ngMetadataName: name }, values);\n    };\n    factory.isTypeOf = (obj) => obj && obj.ngMetadataName === name;\n    factory.ngMetadataName = name;\n    return factory;\n}\n/**\n * @record\n */\nexport function Route() { }\nfunction Route_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Route.prototype.children;\n    /** @type {?|undefined} */\n    Route.prototype.loadChildren;\n}\n//# sourceMappingURL=core.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nexport function splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nexport function splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input, character, defaultValues) {\n    const /** @type {?} */ characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nexport function visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(/** @type {?} */ (value), context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(/** @type {?} */ (value), context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\n/**\n * @param {?} val\n * @return {?}\n */\nexport function isDefined(val) {\n    return val !== null && val !== undefined;\n}\n/**\n * @template T\n * @param {?} val\n * @return {?}\n */\nexport function noUndefined(val) {\n    return val === undefined ? /** @type {?} */ ((null)) : val;\n}\n/**\n * @record\n */\nexport function ValueVisitor() { }\nfunction ValueVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ValueVisitor.prototype.visitArray;\n    /** @type {?} */\n    ValueVisitor.prototype.visitStringMap;\n    /** @type {?} */\n    ValueVisitor.prototype.visitPrimitive;\n    /** @type {?} */\n    ValueVisitor.prototype.visitOther;\n}\nexport class ValueTransformer {\n    /**\n     * @param {?} arr\n     * @param {?} context\n     * @return {?}\n     */\n    visitArray(arr, context) {\n        return arr.map(value => visitValue(value, this, context));\n    }\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    visitStringMap(map, context) {\n        const /** @type {?} */ result = {};\n        Object.keys(map).forEach(key => { result[key] = visitValue(map[key], this, context); });\n        return result;\n    }\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    visitPrimitive(value, context) { return value; }\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    visitOther(value, context) { return value; }\n}\nexport const /** @type {?} */ SyncAsync = {\n    assertSync: (value) => {\n        if (isPromise(value)) {\n            throw new Error(`Illegal state: value cannot be a promise`);\n        }\n        return value;\n    },\n    then: (value, cb) => { return isPromise(value) ? value.then(cb) : cb(value); },\n    all: (syncAsyncValues) => {\n        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : /** @type {?} */ (syncAsyncValues);\n    }\n};\n/**\n * @param {?} msg\n * @param {?=} parseErrors\n * @return {?}\n */\nexport function syntaxError(msg, parseErrors) {\n    const /** @type {?} */ error = Error(msg);\n    (/** @type {?} */ (error))[ERROR_SYNTAX_ERROR] = true;\n    if (parseErrors)\n        (/** @type {?} */ (error))[ERROR_PARSE_ERRORS] = parseErrors;\n    return error;\n}\nconst /** @type {?} */ ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nconst /** @type {?} */ ERROR_PARSE_ERRORS = 'ngParseErrors';\n/**\n * @param {?} error\n * @return {?}\n */\nexport function isSyntaxError(error) {\n    return (/** @type {?} */ (error))[ERROR_SYNTAX_ERROR];\n}\n/**\n * @param {?} error\n * @return {?}\n */\nexport function getParseErrors(error) {\n    return (/** @type {?} */ (error))[ERROR_PARSE_ERRORS] || [];\n}\n/**\n * @param {?} s\n * @return {?}\n */\nexport function escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nconst /** @type {?} */ STRING_MAP_PROTO = Object.getPrototypeOf({});\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nexport function utf8Encode(str) {\n    let /** @type {?} */ encoded = '';\n    for (let /** @type {?} */ index = 0; index < str.length; index++) {\n        let /** @type {?} */ codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            const /** @type {?} */ low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\n/**\n * @record\n */\nexport function OutputContext() { }\nfunction OutputContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    OutputContext.prototype.genFilePath;\n    /** @type {?} */\n    OutputContext.prototype.statements;\n    /** @type {?} */\n    OutputContext.prototype.importExpr;\n}\n/**\n * @param {?} token\n * @return {?}\n */\nexport function stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (token instanceof Array) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    const /** @type {?} */ res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const /** @type {?} */ newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n * @param {?} type\n * @return {?}\n */\nexport function resolveForwardRef(type) {\n    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n        return type();\n    }\n    else {\n        return type;\n    }\n}\n/**\n * Determine if the argument is shaped like a Promise\n * @param {?} obj\n * @return {?}\n */\nexport function isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\nexport class Version {\n    /**\n     * @param {?} full\n     */\n    constructor(full) {\n        this.full = full;\n        const /** @type {?} */ splits = full.split('.');\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join('.');\n    }\n}\nfunction Version_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Version.prototype.major;\n    /** @type {?} */\n    Version.prototype.minor;\n    /** @type {?} */\n    Version.prototype.patch;\n    /** @type {?} */\n    Version.prototype.full;\n}\n/**\n * @record\n */\nexport function Console() { }\nfunction Console_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Console.prototype.log;\n    /** @type {?} */\n    Console.prototype.warn;\n}\n//# sourceMappingURL=util.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\nimport { Version } from \"./util\";\n/**\n * \\@stable\n */\nexport const /** @type {?} */ VERSION = new Version('5.0.5');\n//# sourceMappingURL=version.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * An Abstract Syntax Tree node representing part of a parsed Angular template.\n * @record\n */\nexport function TemplateAst() { }\nfunction TemplateAst_tsickle_Closure_declarations() {\n    /**\n     * The source span from which this node was parsed.\n     * @type {?}\n     */\n    TemplateAst.prototype.sourceSpan;\n    /**\n     * Visit this node and possibly transform it.\n     * @type {?}\n     */\n    TemplateAst.prototype.visit;\n}\n/**\n * A segment of text within the template.\n */\nexport class TextAst {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    constructor(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitText(this, context); }\n}\nfunction TextAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TextAst.prototype.value;\n    /** @type {?} */\n    TextAst.prototype.ngContentIndex;\n    /** @type {?} */\n    TextAst.prototype.sourceSpan;\n}\n/**\n * A bound expression within the text of a template.\n */\nexport class BoundTextAst {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    constructor(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitBoundText(this, context);\n    }\n}\nfunction BoundTextAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BoundTextAst.prototype.value;\n    /** @type {?} */\n    BoundTextAst.prototype.ngContentIndex;\n    /** @type {?} */\n    BoundTextAst.prototype.sourceSpan;\n}\n/**\n * A plain attribute on an element.\n */\nexport class AttrAst {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitAttr(this, context); }\n}\nfunction AttrAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AttrAst.prototype.name;\n    /** @type {?} */\n    AttrAst.prototype.value;\n    /** @type {?} */\n    AttrAst.prototype.sourceSpan;\n}\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[\\@trigger]=\"stateExp\"`)\n */\nexport class BoundElementPropertyAst {\n    /**\n     * @param {?} name\n     * @param {?} type\n     * @param {?} securityContext\n     * @param {?} value\n     * @param {?} unit\n     * @param {?} sourceSpan\n     */\n    constructor(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.isAnimation = this.type === PropertyBindingType.Animation;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    }\n}\nfunction BoundElementPropertyAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.isAnimation;\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.name;\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.type;\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.securityContext;\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.value;\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.unit;\n    /** @type {?} */\n    BoundElementPropertyAst.prototype.sourceSpan;\n}\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(\\@trigger.phase)=\"callback($event)\"`).\n */\nexport class BoundEventAst {\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @param {?} handler\n     * @param {?} sourceSpan\n     */\n    constructor(name, target, phase, handler, sourceSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n        this.isAnimation = !!this.phase;\n    }\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @return {?}\n     */\n    static calcFullName(name, target, phase) {\n        if (target) {\n            return `${target}:${name}`;\n        }\n        else if (phase) {\n            return `@${name}.${phase}`;\n        }\n        else {\n            return name;\n        }\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitEvent(this, context);\n    }\n}\nfunction BoundEventAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BoundEventAst.prototype.fullName;\n    /** @type {?} */\n    BoundEventAst.prototype.isAnimation;\n    /** @type {?} */\n    BoundEventAst.prototype.name;\n    /** @type {?} */\n    BoundEventAst.prototype.target;\n    /** @type {?} */\n    BoundEventAst.prototype.phase;\n    /** @type {?} */\n    BoundEventAst.prototype.handler;\n    /** @type {?} */\n    BoundEventAst.prototype.sourceSpan;\n}\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nexport class ReferenceAst {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitReference(this, context);\n    }\n}\nfunction ReferenceAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ReferenceAst.prototype.name;\n    /** @type {?} */\n    ReferenceAst.prototype.value;\n    /** @type {?} */\n    ReferenceAst.prototype.sourceSpan;\n}\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nexport class VariableAst {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitVariable(this, context);\n    }\n}\nfunction VariableAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    VariableAst.prototype.name;\n    /** @type {?} */\n    VariableAst.prototype.value;\n    /** @type {?} */\n    VariableAst.prototype.sourceSpan;\n}\n/**\n * An element declaration in a template.\n */\nexport class ElementAst {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     * @param {?} endSourceSpan\n     */\n    constructor(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitElement(this, context);\n    }\n}\nfunction ElementAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ElementAst.prototype.name;\n    /** @type {?} */\n    ElementAst.prototype.attrs;\n    /** @type {?} */\n    ElementAst.prototype.inputs;\n    /** @type {?} */\n    ElementAst.prototype.outputs;\n    /** @type {?} */\n    ElementAst.prototype.references;\n    /** @type {?} */\n    ElementAst.prototype.directives;\n    /** @type {?} */\n    ElementAst.prototype.providers;\n    /** @type {?} */\n    ElementAst.prototype.hasViewContainer;\n    /** @type {?} */\n    ElementAst.prototype.queryMatches;\n    /** @type {?} */\n    ElementAst.prototype.children;\n    /** @type {?} */\n    ElementAst.prototype.ngContentIndex;\n    /** @type {?} */\n    ElementAst.prototype.sourceSpan;\n    /** @type {?} */\n    ElementAst.prototype.endSourceSpan;\n}\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nexport class EmbeddedTemplateAst {\n    /**\n     * @param {?} attrs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} variables\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    constructor(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    }\n}\nfunction EmbeddedTemplateAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.attrs;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.outputs;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.references;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.variables;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.directives;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.providers;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.hasViewContainer;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.queryMatches;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.children;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.ngContentIndex;\n    /** @type {?} */\n    EmbeddedTemplateAst.prototype.sourceSpan;\n}\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nexport class BoundDirectivePropertyAst {\n    /**\n     * @param {?} directiveName\n     * @param {?} templateName\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    }\n}\nfunction BoundDirectivePropertyAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BoundDirectivePropertyAst.prototype.directiveName;\n    /** @type {?} */\n    BoundDirectivePropertyAst.prototype.templateName;\n    /** @type {?} */\n    BoundDirectivePropertyAst.prototype.value;\n    /** @type {?} */\n    BoundDirectivePropertyAst.prototype.sourceSpan;\n}\n/**\n * A directive declared on an element.\n */\nexport class DirectiveAst {\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} hostProperties\n     * @param {?} hostEvents\n     * @param {?} contentQueryStartId\n     * @param {?} sourceSpan\n     */\n    constructor(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitDirective(this, context);\n    }\n}\nfunction DirectiveAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    DirectiveAst.prototype.directive;\n    /** @type {?} */\n    DirectiveAst.prototype.inputs;\n    /** @type {?} */\n    DirectiveAst.prototype.hostProperties;\n    /** @type {?} */\n    DirectiveAst.prototype.hostEvents;\n    /** @type {?} */\n    DirectiveAst.prototype.contentQueryStartId;\n    /** @type {?} */\n    DirectiveAst.prototype.sourceSpan;\n}\n/**\n * A provider declared on an element\n */\nexport class ProviderAst {\n    /**\n     * @param {?} token\n     * @param {?} multiProvider\n     * @param {?} eager\n     * @param {?} providers\n     * @param {?} providerType\n     * @param {?} lifecycleHooks\n     * @param {?} sourceSpan\n     */\n    constructor(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    }\n}\nfunction ProviderAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ProviderAst.prototype.token;\n    /** @type {?} */\n    ProviderAst.prototype.multiProvider;\n    /** @type {?} */\n    ProviderAst.prototype.eager;\n    /** @type {?} */\n    ProviderAst.prototype.providers;\n    /** @type {?} */\n    ProviderAst.prototype.providerType;\n    /** @type {?} */\n    ProviderAst.prototype.lifecycleHooks;\n    /** @type {?} */\n    ProviderAst.prototype.sourceSpan;\n}\n/** @enum {number} */\nconst ProviderAstType = {\n    PublicService: 0,\n    PrivateService: 1,\n    Component: 2,\n    Directive: 3,\n    Builtin: 4,\n};\nexport { ProviderAstType };\nProviderAstType[ProviderAstType.PublicService] = \"PublicService\";\nProviderAstType[ProviderAstType.PrivateService] = \"PrivateService\";\nProviderAstType[ProviderAstType.Component] = \"Component\";\nProviderAstType[ProviderAstType.Directive] = \"Directive\";\nProviderAstType[ProviderAstType.Builtin] = \"Builtin\";\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nexport class NgContentAst {\n    /**\n     * @param {?} index\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    constructor(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) {\n        return visitor.visitNgContent(this, context);\n    }\n}\nfunction NgContentAst_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgContentAst.prototype.index;\n    /** @type {?} */\n    NgContentAst.prototype.ngContentIndex;\n    /** @type {?} */\n    NgContentAst.prototype.sourceSpan;\n}\n/** @enum {number} */\nconst PropertyBindingType = {\n    /**\n       * A normal binding to a property (e.g. `[property]=\"expression\"`).\n       */\n    Property: 0,\n    /**\n       * A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n       */\n    Attribute: 1,\n    /**\n       * A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n       */\n    Class: 2,\n    /**\n       * A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n       */\n    Style: 3,\n    /**\n       * A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n       */\n    Animation: 4,\n};\nexport { PropertyBindingType };\nPropertyBindingType[PropertyBindingType.Property] = \"Property\";\nPropertyBindingType[PropertyBindingType.Attribute] = \"Attribute\";\nPropertyBindingType[PropertyBindingType.Class] = \"Class\";\nPropertyBindingType[PropertyBindingType.Style] = \"Style\";\nPropertyBindingType[PropertyBindingType.Animation] = \"Animation\";\n/**\n * @record\n */\nexport function QueryMatch() { }\nfunction QueryMatch_tsickle_Closure_declarations() {\n    /** @type {?} */\n    QueryMatch.prototype.queryId;\n    /** @type {?} */\n    QueryMatch.prototype.value;\n}\n/**\n * A visitor for {\\@link TemplateAst} trees that will process each node.\n * @record\n */\nexport function TemplateAstVisitor() { }\nfunction TemplateAstVisitor_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    TemplateAstVisitor.prototype.visit;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitNgContent;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitEmbeddedTemplate;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitElement;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitReference;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitVariable;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitEvent;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitElementProperty;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitAttr;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitBoundText;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitText;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitDirective;\n    /** @type {?} */\n    TemplateAstVisitor.prototype.visitDirectiveProperty;\n}\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\nexport class NullTemplateVisitor {\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNgContent(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEmbeddedTemplate(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReference(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitVariable(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEvent(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElementProperty(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttr(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBoundText(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitDirective(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitDirectiveProperty(ast, context) { }\n}\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\nexport class RecursiveTemplateAstVisitor extends NullTemplateVisitor {\n    constructor() { super(); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEmbeddedTemplate(ast, context) {\n        return this.visitChildren(context, visit => {\n            visit(ast.attrs);\n            visit(ast.references);\n            visit(ast.variables);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(ast, context) {\n        return this.visitChildren(context, visit => {\n            visit(ast.attrs);\n            visit(ast.inputs);\n            visit(ast.outputs);\n            visit(ast.references);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitDirective(ast, context) {\n        return this.visitChildren(context, visit => {\n            visit(ast.inputs);\n            visit(ast.hostProperties);\n            visit(ast.hostEvents);\n        });\n    }\n    /**\n     * @template T\n     * @param {?} context\n     * @param {?} cb\n     * @return {?}\n     */\n    visitChildren(context, cb) {\n        let /** @type {?} */ results = [];\n        let /** @type {?} */ t = this;\n        /**\n         * @template T\n         * @param {?} children\n         * @return {?}\n         */\n        function visit(children) {\n            if (children && children.length)\n                results.push(templateVisitAll(t, children, context));\n        }\n        cb(visit);\n        return [].concat.apply([], results);\n    }\n}\n/**\n * Visit every node in a list of {\\@link TemplateAst}s with the given {\\@link TemplateAstVisitor}.\n * @param {?} visitor\n * @param {?} asts\n * @param {?=} context\n * @return {?}\n */\nexport function templateVisitAll(visitor, asts, context = null) {\n    const /** @type {?} */ result = [];\n    const /** @type {?} */ visit = visitor.visit ?\n        (ast) => /** @type {?} */ ((visitor.visit))(ast, context) || ast.visit(visitor, context) :\n        (ast) => ast.visit(visitor, context);\n    asts.forEach(ast => {\n        const /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n//# sourceMappingURL=template_ast.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { ViewEncapsulation } from \"./core\";\nimport { noUndefined } from \"./util\";\nexport class CompilerConfig {\n    /**\n     * @param {?=} __0\n     */\n    constructor({ defaultEncapsulation = ViewEncapsulation.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, enableLegacyTemplate, preserveWhitespaces, strictInjectionParameters } = {}) {\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.jitDevMode = !!jitDevMode;\n        this.missingTranslation = missingTranslation;\n        this.enableLegacyTemplate = enableLegacyTemplate === true;\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n        this.strictInjectionParameters = strictInjectionParameters === true;\n    }\n}\nfunction CompilerConfig_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompilerConfig.prototype.defaultEncapsulation;\n    /** @type {?} */\n    CompilerConfig.prototype.enableLegacyTemplate;\n    /** @type {?} */\n    CompilerConfig.prototype.useJit;\n    /** @type {?} */\n    CompilerConfig.prototype.jitDevMode;\n    /** @type {?} */\n    CompilerConfig.prototype.missingTranslation;\n    /** @type {?} */\n    CompilerConfig.prototype.preserveWhitespaces;\n    /** @type {?} */\n    CompilerConfig.prototype.strictInjectionParameters;\n}\n/**\n * @param {?} preserveWhitespacesOption\n * @param {?=} defaultSetting\n * @return {?}\n */\nexport function preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = true) {\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n//# sourceMappingURL=config.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nexport class StaticSymbol {\n    /**\n     * @param {?} filePath\n     * @param {?} name\n     * @param {?} members\n     */\n    constructor(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    /**\n     * @return {?}\n     */\n    assertNoMembers() {\n        if (this.members.length) {\n            throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\n        }\n    }\n}\nfunction StaticSymbol_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StaticSymbol.prototype.filePath;\n    /** @type {?} */\n    StaticSymbol.prototype.name;\n    /** @type {?} */\n    StaticSymbol.prototype.members;\n}\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nexport class StaticSymbolCache {\n    constructor() {\n        this.cache = new Map();\n    }\n    /**\n     * @param {?} declarationFile\n     * @param {?} name\n     * @param {?=} members\n     * @return {?}\n     */\n    get(declarationFile, name, members) {\n        members = members || [];\n        const /** @type {?} */ memberSuffix = members.length ? `.${members.join('.')}` : '';\n        const /** @type {?} */ key = `\"${declarationFile}\".${name}${memberSuffix}`;\n        let /** @type {?} */ result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    }\n}\nfunction StaticSymbolCache_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StaticSymbolCache.prototype.cache;\n}\n//# sourceMappingURL=static_symbol.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StaticSymbol } from \"./aot/static_symbol\";\nimport { splitAtColon, stringify } from \"./util\";\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nconst /** @type {?} */ HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nlet /** @type {?} */ _anonymousTypeIndex = 0;\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nexport function identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    const /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    let /** @type {?} */ identifier = stringify(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = `anonymous_${_anonymousTypeIndex++}`;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = _sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nexport function identifierModuleUrl(compileIdentifier) {\n    const /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    // Runtime type\n    return `./${stringify(ref)}`;\n}\n/**\n * @param {?} compType\n * @param {?} embeddedTemplateIndex\n * @return {?}\n */\nexport function viewClassName(compType, embeddedTemplateIndex) {\n    return `View_${identifierName({ reference: compType })}_${embeddedTemplateIndex}`;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nexport function rendererTypeName(compType) {\n    return `RenderType_${identifierName({ reference: compType })}`;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nexport function hostViewClassName(compType) {\n    return `HostView_${identifierName({ reference: compType })}`;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nexport function componentFactoryName(compType) {\n    return `${identifierName({ reference: compType })}NgFactory`;\n}\n/**\n * @record\n */\nexport function ProxyClass() { }\nfunction ProxyClass_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ProxyClass.prototype.setDelegate;\n}\n/**\n * @record\n */\nexport function CompileIdentifierMetadata() { }\nfunction CompileIdentifierMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileIdentifierMetadata.prototype.reference;\n}\n/** @enum {number} */\nconst CompileSummaryKind = {\n    Pipe: 0,\n    Directive: 1,\n    NgModule: 2,\n    Injectable: 3,\n};\nexport { CompileSummaryKind };\nCompileSummaryKind[CompileSummaryKind.Pipe] = \"Pipe\";\nCompileSummaryKind[CompileSummaryKind.Directive] = \"Directive\";\nCompileSummaryKind[CompileSummaryKind.NgModule] = \"NgModule\";\nCompileSummaryKind[CompileSummaryKind.Injectable] = \"Injectable\";\n/**\n * A CompileSummary is the data needed to use a directive / pipe / module\n * in other modules / components. However, this data is not enough to compile\n * the directive / module itself.\n * @record\n */\nexport function CompileTypeSummary() { }\nfunction CompileTypeSummary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileTypeSummary.prototype.summaryKind;\n    /** @type {?} */\n    CompileTypeSummary.prototype.type;\n}\n/**\n * @record\n */\nexport function CompileDiDependencyMetadata() { }\nfunction CompileDiDependencyMetadata_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.isAttribute;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.isSelf;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.isHost;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.isSkipSelf;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.isOptional;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.isValue;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.token;\n    /** @type {?|undefined} */\n    CompileDiDependencyMetadata.prototype.value;\n}\n/**\n * @record\n */\nexport function CompileProviderMetadata() { }\nfunction CompileProviderMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileProviderMetadata.prototype.token;\n    /** @type {?|undefined} */\n    CompileProviderMetadata.prototype.useClass;\n    /** @type {?|undefined} */\n    CompileProviderMetadata.prototype.useValue;\n    /** @type {?|undefined} */\n    CompileProviderMetadata.prototype.useExisting;\n    /** @type {?|undefined} */\n    CompileProviderMetadata.prototype.useFactory;\n    /** @type {?|undefined} */\n    CompileProviderMetadata.prototype.deps;\n    /** @type {?|undefined} */\n    CompileProviderMetadata.prototype.multi;\n}\n/**\n * @record\n */\nexport function CompileFactoryMetadata() { }\nfunction CompileFactoryMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileFactoryMetadata.prototype.diDeps;\n    /** @type {?} */\n    CompileFactoryMetadata.prototype.reference;\n}\n/**\n * @param {?} token\n * @return {?}\n */\nexport function tokenName(token) {\n    return token.value != null ? _sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n/**\n * @param {?} token\n * @return {?}\n */\nexport function tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * @record\n */\nexport function CompileTokenMetadata() { }\nfunction CompileTokenMetadata_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    CompileTokenMetadata.prototype.value;\n    /** @type {?|undefined} */\n    CompileTokenMetadata.prototype.identifier;\n}\n/**\n * Metadata regarding compilation of a type.\n * @record\n */\nexport function CompileTypeMetadata() { }\nfunction CompileTypeMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileTypeMetadata.prototype.diDeps;\n    /** @type {?} */\n    CompileTypeMetadata.prototype.lifecycleHooks;\n    /** @type {?} */\n    CompileTypeMetadata.prototype.reference;\n}\n/**\n * @record\n */\nexport function CompileQueryMetadata() { }\nfunction CompileQueryMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileQueryMetadata.prototype.selectors;\n    /** @type {?} */\n    CompileQueryMetadata.prototype.descendants;\n    /** @type {?} */\n    CompileQueryMetadata.prototype.first;\n    /** @type {?} */\n    CompileQueryMetadata.prototype.propertyName;\n    /** @type {?} */\n    CompileQueryMetadata.prototype.read;\n}\n/**\n * Metadata about a stylesheet\n */\nexport class CompileStylesheetMetadata {\n    /**\n     * @param {?=} __0\n     */\n    constructor({ moduleUrl, styles, styleUrls } = {}) {\n        this.moduleUrl = moduleUrl || null;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n}\nfunction CompileStylesheetMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileStylesheetMetadata.prototype.moduleUrl;\n    /** @type {?} */\n    CompileStylesheetMetadata.prototype.styles;\n    /** @type {?} */\n    CompileStylesheetMetadata.prototype.styleUrls;\n}\n/**\n * Summary Metadata regarding compilation of a template.\n * @record\n */\nexport function CompileTemplateSummary() { }\nfunction CompileTemplateSummary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileTemplateSummary.prototype.ngContentSelectors;\n    /** @type {?} */\n    CompileTemplateSummary.prototype.encapsulation;\n}\n/**\n * Metadata regarding compilation of a template.\n */\nexport class CompileTemplateMetadata {\n    /**\n     * @param {?} __0\n     */\n    constructor({ encapsulation, template, templateUrl, htmlAst, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation, isInline, preserveWhitespaces }) {\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.htmlAst = htmlAst;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(`'interpolation' should have a start and an end symbol.`);\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n        this.preserveWhitespaces = preserveWhitespaces;\n    }\n    /**\n     * @return {?}\n     */\n    toSummary() {\n        return {\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n        };\n    }\n}\nfunction CompileTemplateMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.encapsulation;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.template;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.templateUrl;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.htmlAst;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.isInline;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.styles;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.styleUrls;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.externalStylesheets;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.animations;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.ngContentSelectors;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.interpolation;\n    /** @type {?} */\n    CompileTemplateMetadata.prototype.preserveWhitespaces;\n}\n/**\n * @record\n */\nexport function CompileEntryComponentMetadata() { }\nfunction CompileEntryComponentMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileEntryComponentMetadata.prototype.componentType;\n    /** @type {?} */\n    CompileEntryComponentMetadata.prototype.componentFactory;\n}\n/**\n * @record\n */\nexport function CompileDirectiveSummary() { }\nfunction CompileDirectiveSummary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.type;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.isComponent;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.selector;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.exportAs;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.inputs;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.outputs;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.hostListeners;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.hostProperties;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.hostAttributes;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.providers;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.viewProviders;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.queries;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.viewQueries;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.entryComponents;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.changeDetection;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.template;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.componentViewType;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.rendererType;\n    /** @type {?} */\n    CompileDirectiveSummary.prototype.componentFactory;\n}\n/**\n * Metadata regarding compilation of a directive.\n */\nexport class CompileDirectiveMetadata {\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    static create({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {\n        const /** @type {?} */ hostListeners = {};\n        const /** @type {?} */ hostProperties = {};\n        const /** @type {?} */ hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(key => {\n                const /** @type {?} */ value = host[key];\n                const /** @type {?} */ matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        const /** @type {?} */ inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach((bindConfig) => {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                const /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        const /** @type {?} */ outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach((bindConfig) => {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                const /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost,\n            type,\n            isComponent: !!isComponent, selector, exportAs, changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners,\n            hostProperties,\n            hostAttributes,\n            providers,\n            viewProviders,\n            queries,\n            viewQueries,\n            entryComponents,\n            template,\n            componentViewType,\n            rendererType,\n            componentFactory,\n        });\n    }\n    /**\n     * @param {?} __0\n     */\n    constructor({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    /**\n     * @return {?}\n     */\n    toSummary() {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    }\n}\nfunction CompileDirectiveMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.isHost;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.type;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.isComponent;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.selector;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.exportAs;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.changeDetection;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.inputs;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.outputs;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.hostListeners;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.hostProperties;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.hostAttributes;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.providers;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.viewProviders;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.queries;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.viewQueries;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.entryComponents;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.template;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.componentViewType;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.rendererType;\n    /** @type {?} */\n    CompileDirectiveMetadata.prototype.componentFactory;\n}\n/**\n * @record\n */\nexport function CompilePipeSummary() { }\nfunction CompilePipeSummary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompilePipeSummary.prototype.type;\n    /** @type {?} */\n    CompilePipeSummary.prototype.name;\n    /** @type {?} */\n    CompilePipeSummary.prototype.pure;\n}\nexport class CompilePipeMetadata {\n    /**\n     * @param {?} __0\n     */\n    constructor({ type, name, pure }) {\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    /**\n     * @return {?}\n     */\n    toSummary() {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    }\n}\nfunction CompilePipeMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompilePipeMetadata.prototype.type;\n    /** @type {?} */\n    CompilePipeMetadata.prototype.name;\n    /** @type {?} */\n    CompilePipeMetadata.prototype.pure;\n}\n/**\n * @record\n */\nexport function CompileNgModuleSummary() { }\nfunction CompileNgModuleSummary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileNgModuleSummary.prototype.type;\n    /** @type {?} */\n    CompileNgModuleSummary.prototype.exportedDirectives;\n    /** @type {?} */\n    CompileNgModuleSummary.prototype.exportedPipes;\n    /** @type {?} */\n    CompileNgModuleSummary.prototype.entryComponents;\n    /** @type {?} */\n    CompileNgModuleSummary.prototype.providers;\n    /** @type {?} */\n    CompileNgModuleSummary.prototype.modules;\n}\n/**\n * Metadata regarding compilation of a module.\n */\nexport class CompileNgModuleMetadata {\n    /**\n     * @param {?} __0\n     */\n    constructor({ type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id }) {\n        this.type = type || null;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id || null;\n        this.transitiveModule = transitiveModule || null;\n    }\n    /**\n     * @return {?}\n     */\n    toSummary() {\n        const /** @type {?} */ module = /** @type {?} */ ((this.transitiveModule));\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: module.entryComponents,\n            providers: module.providers,\n            modules: module.modules,\n            exportedDirectives: module.exportedDirectives,\n            exportedPipes: module.exportedPipes\n        };\n    }\n}\nfunction CompileNgModuleMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.type;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.declaredDirectives;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.exportedDirectives;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.declaredPipes;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.exportedPipes;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.entryComponents;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.bootstrapComponents;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.providers;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.importedModules;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.exportedModules;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.schemas;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.id;\n    /** @type {?} */\n    CompileNgModuleMetadata.prototype.transitiveModule;\n}\nexport class TransitiveCompileNgModuleMetadata {\n    constructor() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    /**\n     * @param {?} provider\n     * @param {?} module\n     * @return {?}\n     */\n    addProvider(provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    addDirective(id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    addExportedDirective(id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    addPipe(id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    addExportedPipe(id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    addModule(id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    }\n    /**\n     * @param {?} ec\n     * @return {?}\n     */\n    addEntryComponent(ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    }\n}\nfunction TransitiveCompileNgModuleMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.directivesSet;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.directives;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.exportedDirectivesSet;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.exportedDirectives;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.pipesSet;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.pipes;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.exportedPipesSet;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.exportedPipes;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.modulesSet;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.modules;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.entryComponentsSet;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.entryComponents;\n    /** @type {?} */\n    TransitiveCompileNgModuleMetadata.prototype.providers;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nexport class ProviderMeta {\n    /**\n     * @param {?} token\n     * @param {?} __1\n     */\n    constructor(token, { useClass, useValue, useExisting, useFactory, deps, multi }) {\n        this.token = token;\n        this.useClass = useClass || null;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory || null;\n        this.dependencies = deps || null;\n        this.multi = !!multi;\n    }\n}\nfunction ProviderMeta_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ProviderMeta.prototype.token;\n    /** @type {?} */\n    ProviderMeta.prototype.useClass;\n    /** @type {?} */\n    ProviderMeta.prototype.useValue;\n    /** @type {?} */\n    ProviderMeta.prototype.useExisting;\n    /** @type {?} */\n    ProviderMeta.prototype.useFactory;\n    /** @type {?} */\n    ProviderMeta.prototype.dependencies;\n    /** @type {?} */\n    ProviderMeta.prototype.multi;\n}\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nexport function flatten(list) {\n    return list.reduce((flat, item) => {\n        const /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;\n        return (/** @type {?} */ (flat)).concat(flatItem);\n    }, []);\n}\n/**\n * @param {?} url\n * @return {?}\n */\nfunction jitSourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @param {?} templateMeta\n * @return {?}\n */\nexport function templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    let /** @type {?} */ url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;\n        }\n        else {\n            url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;\n        }\n    }\n    else {\n        url = /** @type {?} */ ((templateMeta.templateUrl));\n    }\n    return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n}\n/**\n * @param {?} meta\n * @param {?} id\n * @return {?}\n */\nexport function sharedStylesheetJitUrl(meta, id) {\n    const /** @type {?} */ pathParts = /** @type {?} */ ((meta.moduleUrl)).split(/\\/\\\\/g);\n    const /** @type {?} */ baseName = pathParts[pathParts.length - 1];\n    return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);\n}\n/**\n * @param {?} moduleMeta\n * @return {?}\n */\nexport function ngModuleJitUrl(moduleMeta) {\n    return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @return {?}\n */\nexport function templateJitUrl(ngModuleType, compMeta) {\n    return jitSourceUrl(`${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);\n}\n//# sourceMappingURL=compile_metadata.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expresion `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nexport class AstPath {\n    /**\n     * @param {?} path\n     * @param {?=} position\n     */\n    constructor(path, position = -1) {\n        this.path = path;\n        this.position = position;\n    }\n    /**\n     * @return {?}\n     */\n    get empty() { return !this.path || !this.path.length; }\n    /**\n     * @return {?}\n     */\n    get head() { return this.path[0]; }\n    /**\n     * @return {?}\n     */\n    get tail() { return this.path[this.path.length - 1]; }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    parentOf(node) {\n        return node && this.path[this.path.indexOf(node) - 1];\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    childOf(node) { return this.path[this.path.indexOf(node) + 1]; }\n    /**\n     * @template N\n     * @param {?} ctor\n     * @return {?}\n     */\n    first(ctor) {\n        for (let /** @type {?} */ i = this.path.length - 1; i >= 0; i--) {\n            let /** @type {?} */ item = this.path[i];\n            if (item instanceof ctor)\n                return /** @type {?} */ (item);\n        }\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    push(node) { this.path.push(node); }\n    /**\n     * @return {?}\n     */\n    pop() { return /** @type {?} */ ((this.path.pop())); }\n}\nfunction AstPath_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AstPath.prototype.path;\n    /** @type {?} */\n    AstPath.prototype.position;\n}\n//# sourceMappingURL=ast_path.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { AstPath } from \"../ast_path\";\n/**\n * @record\n */\nexport function Node() { }\nfunction Node_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Node.prototype.sourceSpan;\n    /** @type {?} */\n    Node.prototype.visit;\n}\nexport class Text {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitText(this, context); }\n}\nfunction Text_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Text.prototype.value;\n    /** @type {?} */\n    Text.prototype.sourceSpan;\n}\nexport class Expansion {\n    /**\n     * @param {?} switchValue\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     * @param {?} switchValueSourceSpan\n     */\n    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitExpansion(this, context); }\n}\nfunction Expansion_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Expansion.prototype.switchValue;\n    /** @type {?} */\n    Expansion.prototype.type;\n    /** @type {?} */\n    Expansion.prototype.cases;\n    /** @type {?} */\n    Expansion.prototype.sourceSpan;\n    /** @type {?} */\n    Expansion.prototype.switchValueSourceSpan;\n}\nexport class ExpansionCase {\n    /**\n     * @param {?} value\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} valueSourceSpan\n     * @param {?} expSourceSpan\n     */\n    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitExpansionCase(this, context); }\n}\nfunction ExpansionCase_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExpansionCase.prototype.value;\n    /** @type {?} */\n    ExpansionCase.prototype.expression;\n    /** @type {?} */\n    ExpansionCase.prototype.sourceSpan;\n    /** @type {?} */\n    ExpansionCase.prototype.valueSourceSpan;\n    /** @type {?} */\n    ExpansionCase.prototype.expSourceSpan;\n}\nexport class Attribute {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?=} valueSpan\n     */\n    constructor(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitAttribute(this, context); }\n}\nfunction Attribute_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Attribute.prototype.name;\n    /** @type {?} */\n    Attribute.prototype.value;\n    /** @type {?} */\n    Attribute.prototype.sourceSpan;\n    /** @type {?} */\n    Attribute.prototype.valueSpan;\n}\nexport class Element {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} children\n     * @param {?} sourceSpan\n     * @param {?=} startSourceSpan\n     * @param {?=} endSourceSpan\n     */\n    constructor(name, attrs, children, sourceSpan, startSourceSpan = null, endSourceSpan = null) {\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitElement(this, context); }\n}\nfunction Element_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Element.prototype.name;\n    /** @type {?} */\n    Element.prototype.attrs;\n    /** @type {?} */\n    Element.prototype.children;\n    /** @type {?} */\n    Element.prototype.sourceSpan;\n    /** @type {?} */\n    Element.prototype.startSourceSpan;\n    /** @type {?} */\n    Element.prototype.endSourceSpan;\n}\nexport class Comment {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitComment(this, context); }\n}\nfunction Comment_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Comment.prototype.value;\n    /** @type {?} */\n    Comment.prototype.sourceSpan;\n}\n/**\n * @record\n */\nexport function Visitor() { }\nfunction Visitor_tsickle_Closure_declarations() {\n    /** @type {?|undefined} */\n    Visitor.prototype.visit;\n    /** @type {?} */\n    Visitor.prototype.visitElement;\n    /** @type {?} */\n    Visitor.prototype.visitAttribute;\n    /** @type {?} */\n    Visitor.prototype.visitText;\n    /** @type {?} */\n    Visitor.prototype.visitComment;\n    /** @type {?} */\n    Visitor.prototype.visitExpansion;\n    /** @type {?} */\n    Visitor.prototype.visitExpansionCase;\n}\n/**\n * @param {?} visitor\n * @param {?} nodes\n * @param {?=} context\n * @return {?}\n */\nexport function visitAll(visitor, nodes, context = null) {\n    const /** @type {?} */ result = [];\n    const /** @type {?} */ visit = visitor.visit ?\n        (ast) => /** @type {?} */ ((visitor.visit))(ast, context) || ast.visit(visitor, context) :\n        (ast) => ast.visit(visitor, context);\n    nodes.forEach(ast => {\n        const /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nexport class RecursiveVisitor {\n    constructor() { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(ast, context) {\n        this.visitChildren(context, visit => {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(ast, context) {\n        return this.visitChildren(context, visit => { visit(ast.cases); });\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(ast, context) { }\n    /**\n     * @template T\n     * @param {?} context\n     * @param {?} cb\n     * @return {?}\n     */\n    visitChildren(context, cb) {\n        let /** @type {?} */ results = [];\n        let /** @type {?} */ t = this;\n        /**\n         * @template T\n         * @param {?} children\n         * @return {?}\n         */\n        function visit(children) {\n            if (children)\n                results.push(visitAll(t, children, context));\n        }\n        cb(visit);\n        return [].concat.apply([], results);\n    }\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction spanOf(ast) {\n    const /** @type {?} */ start = ast.sourceSpan.start.offset;\n    let /** @type {?} */ end = ast.sourceSpan.end.offset;\n    if (ast instanceof Element) {\n        if (ast.endSourceSpan) {\n            end = ast.endSourceSpan.end.offset;\n        }\n        else if (ast.children && ast.children.length) {\n            end = spanOf(ast.children[ast.children.length - 1]).end;\n        }\n    }\n    return { start, end };\n}\n/**\n * @param {?} nodes\n * @param {?} position\n * @return {?}\n */\nexport function findNode(nodes, position) {\n    const /** @type {?} */ path = [];\n    const /** @type {?} */ visitor = new class extends RecursiveVisitor {\n        /**\n         * @param {?} ast\n         * @param {?} context\n         * @return {?}\n         */\n        visit(ast, context) {\n            const /** @type {?} */ span = spanOf(ast);\n            if (span.start <= position && position < span.end) {\n                path.push(ast);\n            }\n            else {\n                // Returning a value here will result in the children being skipped.\n                return true;\n            }\n        }\n    };\n    visitAll(visitor, nodes);\n    return new AstPath(path, position);\n}\n//# sourceMappingURL=ast.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nexport function assertArrayOfStrings(identifier, value) {\n    if (value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(`Expected '${identifier}' to be an array of strings.`);\n    }\n    for (let /** @type {?} */ i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(`Expected '${identifier}' to be an array of strings.`);\n        }\n    }\n}\nconst /** @type {?} */ INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nexport function assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    }\n    else if (value != null) {\n        const /** @type {?} */ start = /** @type {?} */ (value[0]);\n        const /** @type {?} */ end = /** @type {?} */ (value[1]);\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}\n//# sourceMappingURL=assertions.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { assertInterpolationSymbols } from \"../assertions\";\nexport class InterpolationConfig {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    /**\n     * @param {?} markers\n     * @return {?}\n     */\n    static fromArray(markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n}\nfunction InterpolationConfig_tsickle_Closure_declarations() {\n    /** @type {?} */\n    InterpolationConfig.prototype.start;\n    /** @type {?} */\n    InterpolationConfig.prototype.end;\n}\nexport const /** @type {?} */ DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n//# sourceMappingURL=interpolation_config.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport class StyleWithImports {\n    /**\n     * @param {?} style\n     * @param {?} styleUrls\n     */\n    constructor(style, styleUrls) {\n        this.style = style;\n        this.styleUrls = styleUrls;\n    }\n}\nfunction StyleWithImports_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StyleWithImports.prototype.style;\n    /** @type {?} */\n    StyleWithImports.prototype.styleUrls;\n}\n/**\n * @param {?} url\n * @return {?}\n */\nexport function isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    const /** @type {?} */ schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the \\@import urls that\n * are either relative or don't have a `package:` scheme\n * @param {?} resolver\n * @param {?} baseUrl\n * @param {?} cssText\n * @return {?}\n */\nexport function extractStyleUrls(resolver, baseUrl, cssText) {\n    const /** @type {?} */ foundUrls = [];\n    const /** @type {?} */ modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')\n        .replace(CSS_IMPORT_REGEXP, (...m) => {\n        const /** @type {?} */ url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI\n            // scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nconst /** @type {?} */ CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nconst /** @type {?} */ CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\nconst /** @type {?} */ URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n//# sourceMappingURL=style_url_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {number} */\nconst TagContentType = {\n    RAW_TEXT: 0,\n    ESCAPABLE_RAW_TEXT: 1,\n    PARSABLE_DATA: 2,\n};\nexport { TagContentType };\nTagContentType[TagContentType.RAW_TEXT] = \"RAW_TEXT\";\nTagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTagContentType[TagContentType.PARSABLE_DATA] = \"PARSABLE_DATA\";\n/**\n * @record\n */\nexport function TagDefinition() { }\nfunction TagDefinition_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TagDefinition.prototype.closedByParent;\n    /** @type {?} */\n    TagDefinition.prototype.requiredParents;\n    /** @type {?} */\n    TagDefinition.prototype.parentToAdd;\n    /** @type {?} */\n    TagDefinition.prototype.implicitNamespacePrefix;\n    /** @type {?} */\n    TagDefinition.prototype.contentType;\n    /** @type {?} */\n    TagDefinition.prototype.isVoid;\n    /** @type {?} */\n    TagDefinition.prototype.ignoreFirstLf;\n    /** @type {?} */\n    TagDefinition.prototype.canSelfClose;\n    /** @type {?} */\n    TagDefinition.prototype.requireExtraParent;\n    /** @type {?} */\n    TagDefinition.prototype.isClosedByChild;\n}\n/**\n * @param {?} elementName\n * @return {?}\n */\nexport function splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    const /** @type {?} */ colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nexport function isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nexport function isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nexport function isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\n/**\n * @param {?} fullName\n * @return {?}\n */\nexport function getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\n/**\n * @param {?} prefix\n * @param {?} localName\n * @return {?}\n */\nexport function mergeNsAndName(prefix, localName) {\n    return prefix ? `:${prefix}:${localName}` : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\nexport const /** @type {?} */ NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nexport const /** @type {?} */ NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n//# sourceMappingURL=tags.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { isNgContent } from \"../ml_parser/tags\";\nconst /** @type {?} */ NG_CONTENT_SELECT_ATTR = 'select';\nconst /** @type {?} */ LINK_ELEMENT = 'link';\nconst /** @type {?} */ LINK_STYLE_REL_ATTR = 'rel';\nconst /** @type {?} */ LINK_STYLE_HREF_ATTR = 'href';\nconst /** @type {?} */ LINK_STYLE_REL_VALUE = 'stylesheet';\nconst /** @type {?} */ STYLE_ELEMENT = 'style';\nconst /** @type {?} */ SCRIPT_ELEMENT = 'script';\nconst /** @type {?} */ NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst /** @type {?} */ NG_PROJECT_AS = 'ngProjectAs';\n/**\n * @param {?} ast\n * @return {?}\n */\nexport function preparseElement(ast) {\n    let /** @type {?} */ selectAttr = /** @type {?} */ ((null));\n    let /** @type {?} */ hrefAttr = /** @type {?} */ ((null));\n    let /** @type {?} */ relAttr = /** @type {?} */ ((null));\n    let /** @type {?} */ nonBindable = false;\n    let /** @type {?} */ projectAs = /** @type {?} */ ((null));\n    ast.attrs.forEach(attr => {\n        const /** @type {?} */ lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    const /** @type {?} */ nodeName = ast.name.toLowerCase();\n    let /** @type {?} */ type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\n/** @enum {number} */\nconst PreparsedElementType = {\n    NG_CONTENT: 0,\n    STYLE: 1,\n    STYLESHEET: 2,\n    SCRIPT: 3,\n    OTHER: 4,\n};\nexport { PreparsedElementType };\nPreparsedElementType[PreparsedElementType.NG_CONTENT] = \"NG_CONTENT\";\nPreparsedElementType[PreparsedElementType.STYLE] = \"STYLE\";\nPreparsedElementType[PreparsedElementType.STYLESHEET] = \"STYLESHEET\";\nPreparsedElementType[PreparsedElementType.SCRIPT] = \"SCRIPT\";\nPreparsedElementType[PreparsedElementType.OTHER] = \"OTHER\";\nexport class PreparsedElement {\n    /**\n     * @param {?} type\n     * @param {?} selectAttr\n     * @param {?} hrefAttr\n     * @param {?} nonBindable\n     * @param {?} projectAs\n     */\n    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n}\nfunction PreparsedElement_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PreparsedElement.prototype.type;\n    /** @type {?} */\n    PreparsedElement.prototype.selectAttr;\n    /** @type {?} */\n    PreparsedElement.prototype.hrefAttr;\n    /** @type {?} */\n    PreparsedElement.prototype.nonBindable;\n    /** @type {?} */\n    PreparsedElement.prototype.projectAs;\n}\n/**\n * @param {?} selectAttr\n * @return {?}\n */\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n//# sourceMappingURL=template_preparser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CompileStylesheetMetadata, CompileTemplateMetadata, templateSourceUrl } from \"./compile_metadata\";\nimport { preserveWhitespacesDefault } from \"./config\";\nimport { ViewEncapsulation } from \"./core\";\nimport * as html from \"./ml_parser/ast\";\nimport { InterpolationConfig } from \"./ml_parser/interpolation_config\";\nimport { extractStyleUrls, isStyleUrlResolvable } from \"./style_url_resolver\";\nimport { PreparsedElementType, preparseElement } from \"./template_parser/template_preparser\";\nimport { SyncAsync, isDefined, stringify, syntaxError } from \"./util\";\n/**\n * @record\n */\nexport function PrenormalizedTemplateMetadata() { }\nfunction PrenormalizedTemplateMetadata_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.ngModuleType;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.componentType;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.moduleUrl;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.template;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.templateUrl;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.styles;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.styleUrls;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.interpolation;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.encapsulation;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.animations;\n    /** @type {?} */\n    PrenormalizedTemplateMetadata.prototype.preserveWhitespaces;\n}\nexport class DirectiveNormalizer {\n    /**\n     * @param {?} _resourceLoader\n     * @param {?} _urlResolver\n     * @param {?} _htmlParser\n     * @param {?} _config\n     */\n    constructor(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    clearCache() { this._resourceLoaderCache.clear(); }\n    /**\n     * @param {?} normalizedDirective\n     * @return {?}\n     */\n    clearCacheFor(normalizedDirective) {\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        const /** @type {?} */ template = /** @type {?} */ ((normalizedDirective.template));\n        this._resourceLoaderCache.delete(/** @type {?} */ ((template.templateUrl)));\n        template.externalStylesheets.forEach((stylesheet) => { this._resourceLoaderCache.delete(/** @type {?} */ ((stylesheet.moduleUrl))); });\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    _fetch(url) {\n        let /** @type {?} */ result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = this._resourceLoader.get(url);\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    }\n    /**\n     * @param {?} prenormData\n     * @return {?}\n     */\n    normalizeTemplate(prenormData) {\n        if (isDefined(prenormData.template)) {\n            if (isDefined(prenormData.templateUrl)) {\n                throw syntaxError(`'${stringify(prenormData.componentType)}' component cannot define both template and templateUrl`);\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(`The template specified for component ${stringify(prenormData.componentType)} is not a string`);\n            }\n        }\n        else if (isDefined(prenormData.templateUrl)) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(`The templateUrl specified for component ${stringify(prenormData.componentType)} is not a string`);\n            }\n        }\n        else {\n            throw syntaxError(`No template specified for component ${stringify(prenormData.componentType)}`);\n        }\n        if (isDefined(prenormData.preserveWhitespaces) &&\n            typeof prenormData.preserveWhitespaces !== 'boolean') {\n            throw syntaxError(`The preserveWhitespaces option for component ${stringify(prenormData.componentType)} must be a boolean`);\n        }\n        return SyncAsync.then(this._preParseTemplate(prenormData), (preparsedTemplate) => this._normalizeTemplateMetadata(prenormData, preparsedTemplate));\n    }\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    _preParseTemplate(prenomData) {\n        let /** @type {?} */ template;\n        let /** @type {?} */ templateUrl;\n        if (prenomData.template != null) {\n            template = prenomData.template;\n            templateUrl = prenomData.moduleUrl;\n        }\n        else {\n            templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, /** @type {?} */ ((prenomData.templateUrl)));\n            template = this._fetch(templateUrl);\n        }\n        return SyncAsync.then(template, (template) => this._preparseLoadedTemplate(prenomData, template, templateUrl));\n    }\n    /**\n     * @param {?} prenormData\n     * @param {?} template\n     * @param {?} templateAbsUrl\n     * @return {?}\n     */\n    _preparseLoadedTemplate(prenormData, template, templateAbsUrl) {\n        const /** @type {?} */ isInline = !!prenormData.template;\n        const /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(/** @type {?} */ ((prenormData.interpolation)));\n        const /** @type {?} */ rootNodesAndErrors = this._htmlParser.parse(template, templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline, templateUrl: templateAbsUrl }), true, interpolationConfig);\n        if (rootNodesAndErrors.errors.length > 0) {\n            const /** @type {?} */ errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(`Template parse errors:\\n${errorString}`);\n        }\n        const /** @type {?} */ templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: prenormData.styles, moduleUrl: prenormData.moduleUrl }));\n        const /** @type {?} */ visitor = new TemplatePreparseVisitor();\n        html.visitAll(visitor, rootNodesAndErrors.rootNodes);\n        const /** @type {?} */ templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        const /** @type {?} */ styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        const /** @type {?} */ inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        const /** @type {?} */ styleUrls = this\n            ._normalizeStylesheet(new CompileStylesheetMetadata({ styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl }))\n            .styleUrls;\n        return {\n            template,\n            templateUrl: templateAbsUrl, isInline,\n            htmlAst: rootNodesAndErrors, styles, inlineStyleUrls, styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n        };\n    }\n    /**\n     * @param {?} prenormData\n     * @param {?} preparsedTemplate\n     * @return {?}\n     */\n    _normalizeTemplateMetadata(prenormData, preparsedTemplate) {\n        return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), (externalStylesheets) => this._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets));\n    }\n    /**\n     * @param {?} prenormData\n     * @param {?} preparsedTemplate\n     * @param {?} stylesheets\n     * @return {?}\n     */\n    _normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, stylesheets) {\n        // Algorithm:\n        // - produce exactly 1 entry per original styleUrl in\n        // CompileTemplateMetadata.externalStylesheets whith all styles inlined\n        // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.\n        // Reason: be able to determine how many stylesheets there are even without loading\n        // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously\n        // (as resouce loading may be async)\n        const /** @type {?} */ styles = [...preparsedTemplate.styles];\n        this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);\n        const /** @type {?} */ styleUrls = preparsedTemplate.styleUrls;\n        const /** @type {?} */ externalStylesheets = styleUrls.map(styleUrl => {\n            const /** @type {?} */ stylesheet = /** @type {?} */ ((stylesheets.get(styleUrl)));\n            const /** @type {?} */ styles = [...stylesheet.styles];\n            this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);\n            return new CompileStylesheetMetadata({ moduleUrl: styleUrl, styles: styles });\n        });\n        let /** @type {?} */ encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = ViewEncapsulation.None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation,\n            template: preparsedTemplate.template,\n            templateUrl: preparsedTemplate.templateUrl,\n            htmlAst: preparsedTemplate.htmlAst, styles, styleUrls,\n            ngContentSelectors: preparsedTemplate.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation,\n            isInline: preparsedTemplate.isInline, externalStylesheets,\n            preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces),\n        });\n    }\n    /**\n     * @param {?} styleUrls\n     * @param {?} stylesheets\n     * @param {?} targetStyles\n     * @return {?}\n     */\n    _inlineStyles(styleUrls, stylesheets, targetStyles) {\n        styleUrls.forEach(styleUrl => {\n            const /** @type {?} */ stylesheet = /** @type {?} */ ((stylesheets.get(styleUrl)));\n            stylesheet.styles.forEach(style => targetStyles.push(style));\n            this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);\n        });\n    }\n    /**\n     * @param {?} styleUrls\n     * @param {?=} loadedStylesheets\n     * @return {?}\n     */\n    _loadMissingExternalStylesheets(styleUrls, loadedStylesheets = new Map()) {\n        return SyncAsync.then(SyncAsync.all(styleUrls.filter((styleUrl) => !loadedStylesheets.has(styleUrl))\n            .map(styleUrl => SyncAsync.then(this._fetch(styleUrl), (loadedStyle) => {\n            const /** @type {?} */ stylesheet = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }))), (_) => loadedStylesheets);\n    }\n    /**\n     * @param {?} stylesheet\n     * @return {?}\n     */\n    _normalizeStylesheet(stylesheet) {\n        const /** @type {?} */ moduleUrl = /** @type {?} */ ((stylesheet.moduleUrl));\n        const /** @type {?} */ allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(url => this._urlResolver.resolve(moduleUrl, url));\n        const /** @type {?} */ allStyles = stylesheet.styles.map(style => {\n            const /** @type {?} */ styleWithImports = extractStyleUrls(this._urlResolver, moduleUrl, style);\n            allStyleUrls.push(...styleWithImports.styleUrls);\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });\n    }\n}\nfunction DirectiveNormalizer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    DirectiveNormalizer.prototype._resourceLoaderCache;\n    /** @type {?} */\n    DirectiveNormalizer.prototype._resourceLoader;\n    /** @type {?} */\n    DirectiveNormalizer.prototype._urlResolver;\n    /** @type {?} */\n    DirectiveNormalizer.prototype._htmlParser;\n    /** @type {?} */\n    DirectiveNormalizer.prototype._config;\n}\n/**\n * @record\n */\nfunction PreparsedTemplate() { }\nfunction PreparsedTemplate_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PreparsedTemplate.prototype.template;\n    /** @type {?} */\n    PreparsedTemplate.prototype.templateUrl;\n    /** @type {?} */\n    PreparsedTemplate.prototype.isInline;\n    /** @type {?} */\n    PreparsedTemplate.prototype.htmlAst;\n    /** @type {?} */\n    PreparsedTemplate.prototype.styles;\n    /** @type {?} */\n    PreparsedTemplate.prototype.inlineStyleUrls;\n    /** @type {?} */\n    PreparsedTemplate.prototype.styleUrls;\n    /** @type {?} */\n    PreparsedTemplate.prototype.ngContentSelectors;\n}\nclass TemplatePreparseVisitor {\n    constructor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(ast, context) {\n        const /** @type {?} */ preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                let /** @type {?} */ textContent = '';\n                ast.children.forEach(child => {\n                    if (child instanceof html.Text) {\n                        textContent += child.value;\n                    }\n                });\n                this.styles.push(textContent);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        html.visitAll(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(ast, context) { html.visitAll(this, ast.cases); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(ast, context) {\n        html.visitAll(this, ast.expression);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(ast, context) { return null; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(ast, context) { return null; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(ast, context) { return null; }\n}\nfunction TemplatePreparseVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TemplatePreparseVisitor.prototype.ngContentSelectors;\n    /** @type {?} */\n    TemplatePreparseVisitor.prototype.styles;\n    /** @type {?} */\n    TemplatePreparseVisitor.prototype.styleUrls;\n    /** @type {?} */\n    TemplatePreparseVisitor.prototype.ngNonBindableStackCount;\n}\n//# sourceMappingURL=directive_normalizer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { createComponent, createContentChild, createContentChildren, createDirective, createHostBinding, createHostListener, createInput, createOutput, createViewChild, createViewChildren } from \"./core\";\nimport { resolveForwardRef, splitAtColon, stringify } from \"./util\";\nconst /** @type {?} */ QUERY_METADATA_IDENTIFIERS = [\n    createViewChild,\n    createViewChildren,\n    createContentChild,\n    createContentChildren,\n];\nexport class DirectiveResolver {\n    /**\n     * @param {?} _reflector\n     */\n    constructor(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isDirective(type) {\n        const /** @type {?} */ typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    }\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    resolve(type, throwIfNotFound = true) {\n        const /** @type {?} */ typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        if (typeMetadata) {\n            const /** @type {?} */ metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                const /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(`No Directive annotation found on ${stringify(type)}`);\n        }\n        return null;\n    }\n    /**\n     * @param {?} dm\n     * @param {?} propertyMetadata\n     * @param {?} directiveType\n     * @return {?}\n     */\n    _mergeWithPropertyMetadata(dm, propertyMetadata, directiveType) {\n        const /** @type {?} */ inputs = [];\n        const /** @type {?} */ outputs = [];\n        const /** @type {?} */ host = {};\n        const /** @type {?} */ queries = {};\n        Object.keys(propertyMetadata).forEach((propName) => {\n            const /** @type {?} */ input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(`${propName}: ${input.bindingPropertyName}`);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            const /** @type {?} */ output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(`${propName}: ${output.bindingPropertyName}`);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            const /** @type {?} */ hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));\n            hostBindings.forEach(hostBinding => {\n                if (hostBinding.hostPropertyName) {\n                    const /** @type {?} */ startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(`@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\n                    }\n                    host[`[${hostBinding.hostPropertyName}]`] = propName;\n                }\n                else {\n                    host[`[${propName}]`] = propName;\n                }\n            });\n            const /** @type {?} */ hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));\n            hostListeners.forEach(hostListener => {\n                const /** @type {?} */ args = hostListener.args || [];\n                host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n            });\n            const /** @type {?} */ query = findLast(propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, directiveType);\n    }\n    /**\n     * @param {?} def\n     * @return {?}\n     */\n    _extractPublicName(def) { return splitAtColon(def, [/** @type {?} */ ((null)), def])[1].trim(); }\n    /**\n     * @param {?} bindings\n     * @return {?}\n     */\n    _dedupeBindings(bindings) {\n        const /** @type {?} */ names = new Set();\n        const /** @type {?} */ reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (let /** @type {?} */ i = bindings.length - 1; i >= 0; i--) {\n            const /** @type {?} */ binding = bindings[i];\n            const /** @type {?} */ name = this._extractPublicName(binding);\n            if (!names.has(name)) {\n                names.add(name);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    }\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} host\n     * @param {?} queries\n     * @param {?} directiveType\n     * @return {?}\n     */\n    _merge(directive, inputs, outputs, host, queries, directiveType) {\n        const /** @type {?} */ mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        const /** @type {?} */ mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        const /** @type {?} */ mergedHost = directive.host ? Object.assign({}, directive.host, host) : host;\n        const /** @type {?} */ mergedQueries = directive.queries ? Object.assign({}, directive.queries, queries) : queries;\n        if (createComponent.isTypeOf(directive)) {\n            const /** @type {?} */ comp = /** @type {?} */ (directive);\n            return createComponent({\n                selector: comp.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: comp.exportAs,\n                moduleId: comp.moduleId,\n                queries: mergedQueries,\n                changeDetection: comp.changeDetection,\n                providers: comp.providers,\n                viewProviders: comp.viewProviders,\n                entryComponents: comp.entryComponents,\n                template: comp.template,\n                templateUrl: comp.templateUrl,\n                styles: comp.styles,\n                styleUrls: comp.styleUrls,\n                encapsulation: comp.encapsulation,\n                animations: comp.animations,\n                interpolation: comp.interpolation,\n                preserveWhitespaces: directive.preserveWhitespaces,\n            });\n        }\n        else {\n            return createDirective({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers\n            });\n        }\n    }\n}\nfunction DirectiveResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    DirectiveResolver.prototype._reflector;\n}\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isDirectiveMetadata(type) {\n    return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nexport function findLast(arr, condition) {\n    for (let /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=directive_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const /** @type {?} */ $EOF = 0;\nexport const /** @type {?} */ $TAB = 9;\nexport const /** @type {?} */ $LF = 10;\nexport const /** @type {?} */ $VTAB = 11;\nexport const /** @type {?} */ $FF = 12;\nexport const /** @type {?} */ $CR = 13;\nexport const /** @type {?} */ $SPACE = 32;\nexport const /** @type {?} */ $BANG = 33;\nexport const /** @type {?} */ $DQ = 34;\nexport const /** @type {?} */ $HASH = 35;\nexport const /** @type {?} */ $$ = 36;\nexport const /** @type {?} */ $PERCENT = 37;\nexport const /** @type {?} */ $AMPERSAND = 38;\nexport const /** @type {?} */ $SQ = 39;\nexport const /** @type {?} */ $LPAREN = 40;\nexport const /** @type {?} */ $RPAREN = 41;\nexport const /** @type {?} */ $STAR = 42;\nexport const /** @type {?} */ $PLUS = 43;\nexport const /** @type {?} */ $COMMA = 44;\nexport const /** @type {?} */ $MINUS = 45;\nexport const /** @type {?} */ $PERIOD = 46;\nexport const /** @type {?} */ $SLASH = 47;\nexport const /** @type {?} */ $COLON = 58;\nexport const /** @type {?} */ $SEMICOLON = 59;\nexport const /** @type {?} */ $LT = 60;\nexport const /** @type {?} */ $EQ = 61;\nexport const /** @type {?} */ $GT = 62;\nexport const /** @type {?} */ $QUESTION = 63;\nexport const /** @type {?} */ $0 = 48;\nexport const /** @type {?} */ $9 = 57;\nexport const /** @type {?} */ $A = 65;\nexport const /** @type {?} */ $E = 69;\nexport const /** @type {?} */ $F = 70;\nexport const /** @type {?} */ $X = 88;\nexport const /** @type {?} */ $Z = 90;\nexport const /** @type {?} */ $LBRACKET = 91;\nexport const /** @type {?} */ $BACKSLASH = 92;\nexport const /** @type {?} */ $RBRACKET = 93;\nexport const /** @type {?} */ $CARET = 94;\nexport const /** @type {?} */ $_ = 95;\nexport const /** @type {?} */ $a = 97;\nexport const /** @type {?} */ $e = 101;\nexport const /** @type {?} */ $f = 102;\nexport const /** @type {?} */ $n = 110;\nexport const /** @type {?} */ $r = 114;\nexport const /** @type {?} */ $t = 116;\nexport const /** @type {?} */ $u = 117;\nexport const /** @type {?} */ $v = 118;\nexport const /** @type {?} */ $x = 120;\nexport const /** @type {?} */ $z = 122;\nexport const /** @type {?} */ $LBRACE = 123;\nexport const /** @type {?} */ $BAR = 124;\nexport const /** @type {?} */ $RBRACE = 125;\nexport const /** @type {?} */ $NBSP = 160;\nexport const /** @type {?} */ $PIPE = 124;\nexport const /** @type {?} */ $TILDA = 126;\nexport const /** @type {?} */ $AT = 64;\nexport const /** @type {?} */ $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isDigit(code) {\n    return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n//# sourceMappingURL=chars.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from \"../chars\";\n/** @enum {number} */\nconst TokenType = {\n    Character: 0,\n    Identifier: 1,\n    Keyword: 2,\n    String: 3,\n    Operator: 4,\n    Number: 5,\n    Error: 6,\n};\nexport { TokenType };\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\nconst /** @type {?} */ KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nexport class Lexer {\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    tokenize(text) {\n        const /** @type {?} */ scanner = new _Scanner(text);\n        const /** @type {?} */ tokens = [];\n        let /** @type {?} */ token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\nexport class Token {\n    /**\n     * @param {?} index\n     * @param {?} type\n     * @param {?} numValue\n     * @param {?} strValue\n     */\n    constructor(index, type, numValue, strValue) {\n        this.index = index;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    isCharacter(code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    }\n    /**\n     * @return {?}\n     */\n    isNumber() { return this.type == TokenType.Number; }\n    /**\n     * @return {?}\n     */\n    isString() { return this.type == TokenType.String; }\n    /**\n     * @param {?} operater\n     * @return {?}\n     */\n    isOperator(operater) {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    }\n    /**\n     * @return {?}\n     */\n    isIdentifier() { return this.type == TokenType.Identifier; }\n    /**\n     * @return {?}\n     */\n    isKeyword() { return this.type == TokenType.Keyword; }\n    /**\n     * @return {?}\n     */\n    isKeywordLet() { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n    /**\n     * @return {?}\n     */\n    isKeywordAs() { return this.type == TokenType.Keyword && this.strValue == 'as'; }\n    /**\n     * @return {?}\n     */\n    isKeywordNull() { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n    /**\n     * @return {?}\n     */\n    isKeywordUndefined() {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    }\n    /**\n     * @return {?}\n     */\n    isKeywordTrue() { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n    /**\n     * @return {?}\n     */\n    isKeywordFalse() { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n    /**\n     * @return {?}\n     */\n    isKeywordThis() { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n    /**\n     * @return {?}\n     */\n    isError() { return this.type == TokenType.Error; }\n    /**\n     * @return {?}\n     */\n    toNumber() { return this.type == TokenType.Number ? this.numValue : -1; }\n    /**\n     * @return {?}\n     */\n    toString() {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\nfunction Token_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Token.prototype.index;\n    /** @type {?} */\n    Token.prototype.type;\n    /** @type {?} */\n    Token.prototype.numValue;\n    /** @type {?} */\n    Token.prototype.strValue;\n}\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index, code) {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index, text) {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index, text) {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index, text) {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index, text) {\n    return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index, n) {\n    return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index, message) {\n    return new Token(index, TokenType.Error, 0, message);\n}\nexport const /** @type {?} */ EOF = new Token(-1, TokenType.Character, 0, '');\nclass _Scanner {\n    /**\n     * @param {?} input\n     */\n    constructor(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    /**\n     * @return {?}\n     */\n    advance() {\n        this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n    }\n    /**\n     * @return {?}\n     */\n    scanToken() {\n        const /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n        let /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n        // Skip whitespace.\n        while (peek <= chars.$SPACE) {\n            if (++index >= length) {\n                peek = chars.$EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (chars.isDigit(peek))\n            return this.scanNumber(index);\n        const /** @type {?} */ start = index;\n        switch (peek) {\n            case chars.$PERIOD:\n                this.advance();\n                return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, chars.$PERIOD);\n            case chars.$LPAREN:\n            case chars.$RPAREN:\n            case chars.$LBRACE:\n            case chars.$RBRACE:\n            case chars.$LBRACKET:\n            case chars.$RBRACKET:\n            case chars.$COMMA:\n            case chars.$COLON:\n            case chars.$SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case chars.$SQ:\n            case chars.$DQ:\n                return this.scanString();\n            case chars.$HASH:\n            case chars.$PLUS:\n            case chars.$MINUS:\n            case chars.$STAR:\n            case chars.$SLASH:\n            case chars.$PERCENT:\n            case chars.$CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case chars.$QUESTION:\n                return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n            case chars.$LT:\n            case chars.$GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n            case chars.$BANG:\n            case chars.$EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n            case chars.$AMPERSAND:\n                return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n            case chars.$BAR:\n                return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n            case chars.$NBSP:\n                while (chars.isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n    /**\n     * @param {?} start\n     * @param {?} code\n     * @return {?}\n     */\n    scanCharacter(start, code) {\n        this.advance();\n        return newCharacterToken(start, code);\n    }\n    /**\n     * @param {?} start\n     * @param {?} str\n     * @return {?}\n     */\n    scanOperator(start, str) {\n        this.advance();\n        return newOperatorToken(start, str);\n    }\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param {?} start start index in the expression\n     * @param {?} one first symbol (always part of the operator)\n     * @param {?} twoCode code point for the second symbol\n     * @param {?} two second symbol (part of the operator when the second code point matches)\n     * @param {?=} threeCode code point for the third symbol\n     * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n     * @return {?}\n     */\n    scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        let /** @type {?} */ str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    }\n    /**\n     * @return {?}\n     */\n    scanIdentifier() {\n        const /** @type {?} */ start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const /** @type {?} */ str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    scanNumber(start) {\n        let /** @type {?} */ simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (chars.isDigit(this.peek)) {\n                // Do nothing.\n            }\n            else if (this.peek == chars.$PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!chars.isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        const /** @type {?} */ str = this.input.substring(start, this.index);\n        const /** @type {?} */ value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    }\n    /**\n     * @return {?}\n     */\n    scanString() {\n        const /** @type {?} */ start = this.index;\n        const /** @type {?} */ quote = this.peek;\n        this.advance(); // Skip initial quote.\n        let /** @type {?} */ buffer = '';\n        let /** @type {?} */ marker = this.index;\n        const /** @type {?} */ input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == chars.$BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                let /** @type {?} */ unescapedCode;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == chars.$u) {\n                    // 4 character hex code for unicode character.\n                    const /** @type {?} */ hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let /** @type {?} */ i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == chars.$EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        const /** @type {?} */ last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, buffer + last);\n    }\n    /**\n     * @param {?} message\n     * @param {?} offset\n     * @return {?}\n     */\n    error(message, offset) {\n        const /** @type {?} */ position = this.index + offset;\n        return newErrorToken(position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\nfunction _Scanner_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _Scanner.prototype.length;\n    /** @type {?} */\n    _Scanner.prototype.peek;\n    /** @type {?} */\n    _Scanner.prototype.index;\n    /** @type {?} */\n    _Scanner.prototype.input;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code) {\n    return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n        (code == chars.$_) || (code == chars.$$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    const /** @type {?} */ scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== chars.$EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code) {\n    return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n        (code == chars.$$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code) {\n    return code == chars.$e || code == chars.$E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code) {\n    return code == chars.$MINUS || code == chars.$PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isQuote(code) {\n    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code) {\n    switch (code) {\n        case chars.$n:\n            return chars.$LF;\n        case chars.$f:\n            return chars.$FF;\n        case chars.$r:\n            return chars.$CR;\n        case chars.$t:\n            return chars.$TAB;\n        case chars.$v:\n            return chars.$VTAB;\n        default:\n            return code;\n    }\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction parseIntAutoRadix(text) {\n    const /** @type {?} */ result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n//# sourceMappingURL=lexer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport class ParserError {\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     */\n    constructor(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\nfunction ParserError_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParserError.prototype.message;\n    /** @type {?} */\n    ParserError.prototype.input;\n    /** @type {?} */\n    ParserError.prototype.errLocation;\n    /** @type {?} */\n    ParserError.prototype.ctxLocation;\n}\nexport class ParseSpan {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nfunction ParseSpan_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParseSpan.prototype.start;\n    /** @type {?} */\n    ParseSpan.prototype.end;\n}\nexport class AST {\n    /**\n     * @param {?} span\n     */\n    constructor(span) {\n        this.span = span;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) { return null; }\n    /**\n     * @return {?}\n     */\n    toString() { return 'AST'; }\n}\nfunction AST_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AST.prototype.span;\n}\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n    /**\n     * @param {?} span\n     * @param {?} prefix\n     * @param {?} uninterpretedExpression\n     * @param {?} location\n     */\n    constructor(span, prefix, uninterpretedExpression, location) {\n        super(span);\n        this.prefix = prefix;\n        this.uninterpretedExpression = uninterpretedExpression;\n        this.location = location;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) { return visitor.visitQuote(this, context); }\n    /**\n     * @return {?}\n     */\n    toString() { return 'Quote'; }\n}\nfunction Quote_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Quote.prototype.prefix;\n    /** @type {?} */\n    Quote.prototype.uninterpretedExpression;\n    /** @type {?} */\n    Quote.prototype.location;\n}\nexport class EmptyExpr extends AST {\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        // do nothing\n    }\n}\nexport class ImplicitReceiver extends AST {\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    constructor(span, expressions) {\n        super(span);\n        this.expressions = expressions;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) { return visitor.visitChain(this, context); }\n}\nfunction Chain_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Chain.prototype.expressions;\n}\nexport class Conditional extends AST {\n    /**\n     * @param {?} span\n     * @param {?} condition\n     * @param {?} trueExp\n     * @param {?} falseExp\n     */\n    constructor(span, condition, trueExp, falseExp) {\n        super(span);\n        this.condition = condition;\n        this.trueExp = trueExp;\n        this.falseExp = falseExp;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitConditional(this, context);\n    }\n}\nfunction Conditional_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Conditional.prototype.condition;\n    /** @type {?} */\n    Conditional.prototype.trueExp;\n    /** @type {?} */\n    Conditional.prototype.falseExp;\n}\nexport class PropertyRead extends AST {\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    constructor(span, receiver, name) {\n        super(span);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\nfunction PropertyRead_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PropertyRead.prototype.receiver;\n    /** @type {?} */\n    PropertyRead.prototype.name;\n}\nexport class PropertyWrite extends AST {\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     */\n    constructor(span, receiver, name, value) {\n        super(span);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\nfunction PropertyWrite_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PropertyWrite.prototype.receiver;\n    /** @type {?} */\n    PropertyWrite.prototype.name;\n    /** @type {?} */\n    PropertyWrite.prototype.value;\n}\nexport class SafePropertyRead extends AST {\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    constructor(span, receiver, name) {\n        super(span);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\nfunction SafePropertyRead_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SafePropertyRead.prototype.receiver;\n    /** @type {?} */\n    SafePropertyRead.prototype.name;\n}\nexport class KeyedRead extends AST {\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     */\n    constructor(span, obj, key) {\n        super(span);\n        this.obj = obj;\n        this.key = key;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\nfunction KeyedRead_tsickle_Closure_declarations() {\n    /** @type {?} */\n    KeyedRead.prototype.obj;\n    /** @type {?} */\n    KeyedRead.prototype.key;\n}\nexport class KeyedWrite extends AST {\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     * @param {?} value\n     */\n    constructor(span, obj, key, value) {\n        super(span);\n        this.obj = obj;\n        this.key = key;\n        this.value = value;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\nfunction KeyedWrite_tsickle_Closure_declarations() {\n    /** @type {?} */\n    KeyedWrite.prototype.obj;\n    /** @type {?} */\n    KeyedWrite.prototype.key;\n    /** @type {?} */\n    KeyedWrite.prototype.value;\n}\nexport class BindingPipe extends AST {\n    /**\n     * @param {?} span\n     * @param {?} exp\n     * @param {?} name\n     * @param {?} args\n     */\n    constructor(span, exp, name, args) {\n        super(span);\n        this.exp = exp;\n        this.name = name;\n        this.args = args;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) { return visitor.visitPipe(this, context); }\n}\nfunction BindingPipe_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BindingPipe.prototype.exp;\n    /** @type {?} */\n    BindingPipe.prototype.name;\n    /** @type {?} */\n    BindingPipe.prototype.args;\n}\nexport class LiteralPrimitive extends AST {\n    /**\n     * @param {?} span\n     * @param {?} value\n     */\n    constructor(span, value) {\n        super(span);\n        this.value = value;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\nfunction LiteralPrimitive_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralPrimitive.prototype.value;\n}\nexport class LiteralArray extends AST {\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    constructor(span, expressions) {\n        super(span);\n        this.expressions = expressions;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\nfunction LiteralArray_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralArray.prototype.expressions;\n}\nexport class LiteralMap extends AST {\n    /**\n     * @param {?} span\n     * @param {?} keys\n     * @param {?} values\n     */\n    constructor(span, keys, values) {\n        super(span);\n        this.keys = keys;\n        this.values = values;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\nfunction LiteralMap_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralMap.prototype.keys;\n    /** @type {?} */\n    LiteralMap.prototype.values;\n}\nexport class Interpolation extends AST {\n    /**\n     * @param {?} span\n     * @param {?} strings\n     * @param {?} expressions\n     */\n    constructor(span, strings, expressions) {\n        super(span);\n        this.strings = strings;\n        this.expressions = expressions;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitInterpolation(this, context);\n    }\n}\nfunction Interpolation_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Interpolation.prototype.strings;\n    /** @type {?} */\n    Interpolation.prototype.expressions;\n}\nexport class Binary extends AST {\n    /**\n     * @param {?} span\n     * @param {?} operation\n     * @param {?} left\n     * @param {?} right\n     */\n    constructor(span, operation, left, right) {\n        super(span);\n        this.operation = operation;\n        this.left = left;\n        this.right = right;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitBinary(this, context);\n    }\n}\nfunction Binary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Binary.prototype.operation;\n    /** @type {?} */\n    Binary.prototype.left;\n    /** @type {?} */\n    Binary.prototype.right;\n}\nexport class PrefixNot extends AST {\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    constructor(span, expression) {\n        super(span);\n        this.expression = expression;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\nfunction PrefixNot_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PrefixNot.prototype.expression;\n}\nexport class NonNullAssert extends AST {\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    constructor(span, expression) {\n        super(span);\n        this.expression = expression;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitNonNullAssert(this, context);\n    }\n}\nfunction NonNullAssert_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NonNullAssert.prototype.expression;\n}\nexport class MethodCall extends AST {\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    constructor(span, receiver, name, args) {\n        super(span);\n        this.receiver = receiver;\n        this.name = name;\n        this.args = args;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitMethodCall(this, context);\n    }\n}\nfunction MethodCall_tsickle_Closure_declarations() {\n    /** @type {?} */\n    MethodCall.prototype.receiver;\n    /** @type {?} */\n    MethodCall.prototype.name;\n    /** @type {?} */\n    MethodCall.prototype.args;\n}\nexport class SafeMethodCall extends AST {\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    constructor(span, receiver, name, args) {\n        super(span);\n        this.receiver = receiver;\n        this.name = name;\n        this.args = args;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitSafeMethodCall(this, context);\n    }\n}\nfunction SafeMethodCall_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SafeMethodCall.prototype.receiver;\n    /** @type {?} */\n    SafeMethodCall.prototype.name;\n    /** @type {?} */\n    SafeMethodCall.prototype.args;\n}\nexport class FunctionCall extends AST {\n    /**\n     * @param {?} span\n     * @param {?} target\n     * @param {?} args\n     */\n    constructor(span, target, args) {\n        super(span);\n        this.target = target;\n        this.args = args;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) {\n        return visitor.visitFunctionCall(this, context);\n    }\n}\nfunction FunctionCall_tsickle_Closure_declarations() {\n    /** @type {?} */\n    FunctionCall.prototype.target;\n    /** @type {?} */\n    FunctionCall.prototype.args;\n}\nexport class ASTWithSource extends AST {\n    /**\n     * @param {?} ast\n     * @param {?} source\n     * @param {?} location\n     * @param {?} errors\n     */\n    constructor(ast, source, location, errors) {\n        super(new ParseSpan(0, source == null ? 0 : source.length));\n        this.ast = ast;\n        this.source = source;\n        this.location = location;\n        this.errors = errors;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context = null) { return this.ast.visit(visitor, context); }\n    /**\n     * @return {?}\n     */\n    toString() { return `${this.source} in ${this.location}`; }\n}\nfunction ASTWithSource_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ASTWithSource.prototype.ast;\n    /** @type {?} */\n    ASTWithSource.prototype.source;\n    /** @type {?} */\n    ASTWithSource.prototype.location;\n    /** @type {?} */\n    ASTWithSource.prototype.errors;\n}\nexport class TemplateBinding {\n    /**\n     * @param {?} span\n     * @param {?} key\n     * @param {?} keyIsVar\n     * @param {?} name\n     * @param {?} expression\n     */\n    constructor(span, key, keyIsVar, name, expression) {\n        this.span = span;\n        this.key = key;\n        this.keyIsVar = keyIsVar;\n        this.name = name;\n        this.expression = expression;\n    }\n}\nfunction TemplateBinding_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TemplateBinding.prototype.span;\n    /** @type {?} */\n    TemplateBinding.prototype.key;\n    /** @type {?} */\n    TemplateBinding.prototype.keyIsVar;\n    /** @type {?} */\n    TemplateBinding.prototype.name;\n    /** @type {?} */\n    TemplateBinding.prototype.expression;\n}\n/**\n * @record\n */\nexport function AstVisitor() { }\nfunction AstVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AstVisitor.prototype.visitBinary;\n    /** @type {?} */\n    AstVisitor.prototype.visitChain;\n    /** @type {?} */\n    AstVisitor.prototype.visitConditional;\n    /** @type {?} */\n    AstVisitor.prototype.visitFunctionCall;\n    /** @type {?} */\n    AstVisitor.prototype.visitImplicitReceiver;\n    /** @type {?} */\n    AstVisitor.prototype.visitInterpolation;\n    /** @type {?} */\n    AstVisitor.prototype.visitKeyedRead;\n    /** @type {?} */\n    AstVisitor.prototype.visitKeyedWrite;\n    /** @type {?} */\n    AstVisitor.prototype.visitLiteralArray;\n    /** @type {?} */\n    AstVisitor.prototype.visitLiteralMap;\n    /** @type {?} */\n    AstVisitor.prototype.visitLiteralPrimitive;\n    /** @type {?} */\n    AstVisitor.prototype.visitMethodCall;\n    /** @type {?} */\n    AstVisitor.prototype.visitPipe;\n    /** @type {?} */\n    AstVisitor.prototype.visitPrefixNot;\n    /** @type {?} */\n    AstVisitor.prototype.visitNonNullAssert;\n    /** @type {?} */\n    AstVisitor.prototype.visitPropertyRead;\n    /** @type {?} */\n    AstVisitor.prototype.visitPropertyWrite;\n    /** @type {?} */\n    AstVisitor.prototype.visitQuote;\n    /** @type {?} */\n    AstVisitor.prototype.visitSafeMethodCall;\n    /** @type {?} */\n    AstVisitor.prototype.visitSafePropertyRead;\n    /** @type {?|undefined} */\n    AstVisitor.prototype.visit;\n}\nexport class NullAstVisitor {\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBinary(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitChain(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitConditional(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitFunctionCall(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitImplicitReceiver(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInterpolation(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedRead(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedWrite(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArray(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMap(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralPrimitive(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitMethodCall(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPipe(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPrefixNot(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNonNullAssert(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyRead(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyWrite(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitQuote(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafeMethodCall(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafePropertyRead(ast, context) { }\n}\nexport class RecursiveAstVisitor {\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBinary(ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitChain(ast, context) { return this.visitAll(ast.expressions, context); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitConditional(ast, context) {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPipe(ast, context) {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitFunctionCall(ast, context) {\n        /** @type {?} */ ((ast.target)).visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitImplicitReceiver(ast, context) { return null; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInterpolation(ast, context) {\n        return this.visitAll(ast.expressions, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedRead(ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedWrite(ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArray(ast, context) {\n        return this.visitAll(ast.expressions, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMap(ast, context) { return this.visitAll(ast.values, context); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralPrimitive(ast, context) { return null; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitMethodCall(ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPrefixNot(ast, context) {\n        ast.expression.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNonNullAssert(ast, context) {\n        ast.expression.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyRead(ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyWrite(ast, context) {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafePropertyRead(ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafeMethodCall(ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    /**\n     * @param {?} asts\n     * @param {?} context\n     * @return {?}\n     */\n    visitAll(asts, context) {\n        asts.forEach(ast => ast.visit(this, context));\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitQuote(ast, context) { return null; }\n}\nexport class AstTransformer {\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitImplicitReceiver(ast, context) { return ast; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInterpolation(ast, context) {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralPrimitive(ast, context) {\n        return new LiteralPrimitive(ast.span, ast.value);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyRead(ast, context) {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyWrite(ast, context) {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafePropertyRead(ast, context) {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitMethodCall(ast, context) {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafeMethodCall(ast, context) {\n        return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitFunctionCall(ast, context) {\n        return new FunctionCall(ast.span, /** @type {?} */ ((ast.target)).visit(this), this.visitAll(ast.args));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArray(ast, context) {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMap(ast, context) {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBinary(ast, context) {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPrefixNot(ast, context) {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNonNullAssert(ast, context) {\n        return new NonNullAssert(ast.span, ast.expression.visit(this));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitConditional(ast, context) {\n        return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPipe(ast, context) {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedRead(ast, context) {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedWrite(ast, context) {\n        return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    visitAll(asts) {\n        const /** @type {?} */ res = new Array(asts.length);\n        for (let /** @type {?} */ i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitChain(ast, context) {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitQuote(ast, context) {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n}\n/**\n * @param {?} ast\n * @param {?} visitor\n * @param {?=} context\n * @return {?}\n */\nexport function visitAstChildren(ast, visitor, context) {\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    function visit(ast) {\n        visitor.visit && visitor.visit(ast, context) || ast.visit(visitor, context);\n    }\n    /**\n     * @template T\n     * @param {?} asts\n     * @return {?}\n     */\n    function visitAll(asts) { asts.forEach(visit); }\n    ast.visit({\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitBinary(ast) {\n            visit(ast.left);\n            visit(ast.right);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitChain(ast) { visitAll(ast.expressions); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitConditional(ast) {\n            visit(ast.condition);\n            visit(ast.trueExp);\n            visit(ast.falseExp);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitFunctionCall(ast) {\n            if (ast.target) {\n                visit(ast.target);\n            }\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitImplicitReceiver(ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitInterpolation(ast) { visitAll(ast.expressions); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitKeyedRead(ast) {\n            visit(ast.obj);\n            visit(ast.key);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitKeyedWrite(ast) {\n            visit(ast.obj);\n            visit(ast.key);\n            visit(ast.obj);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitLiteralArray(ast) { visitAll(ast.expressions); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitLiteralMap(ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitLiteralPrimitive(ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitMethodCall(ast) {\n            visit(ast.receiver);\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPipe(ast) {\n            visit(ast.exp);\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPrefixNot(ast) { visit(ast.expression); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitNonNullAssert(ast) { visit(ast.expression); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPropertyRead(ast) { visit(ast.receiver); },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitPropertyWrite(ast) {\n            visit(ast.receiver);\n            visit(ast.value);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitQuote(ast) { },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitSafeMethodCall(ast) {\n            visit(ast.receiver);\n            visitAll(ast.args);\n        },\n        /**\n         * @param {?} ast\n         * @return {?}\n         */\n        visitSafePropertyRead(ast) { visit(ast.receiver); },\n    });\n}\n//# sourceMappingURL=ast.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from \"../chars\";\nimport { DEFAULT_INTERPOLATION_CONFIG } from \"../ml_parser/interpolation_config\";\nimport { escapeRegExp } from \"../util\";\nimport { ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, NonNullAssert, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding } from \"./ast\";\nimport { EOF, TokenType, isIdentifier, isQuote } from \"./lexer\";\nexport class SplitInterpolation {\n    /**\n     * @param {?} strings\n     * @param {?} expressions\n     * @param {?} offsets\n     */\n    constructor(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n}\nfunction SplitInterpolation_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SplitInterpolation.prototype.strings;\n    /** @type {?} */\n    SplitInterpolation.prototype.expressions;\n    /** @type {?} */\n    SplitInterpolation.prototype.offsets;\n}\nexport class TemplateBindingParseResult {\n    /**\n     * @param {?} templateBindings\n     * @param {?} warnings\n     * @param {?} errors\n     */\n    constructor(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n}\nfunction TemplateBindingParseResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TemplateBindingParseResult.prototype.templateBindings;\n    /** @type {?} */\n    TemplateBindingParseResult.prototype.warnings;\n    /** @type {?} */\n    TemplateBindingParseResult.prototype.errors;\n}\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config) {\n    const /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nexport class Parser {\n    /**\n     * @param {?} _lexer\n     */\n    constructor(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parseAction(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const /** @type {?} */ sourceToLex = this._stripComments(input);\n        const /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n        const /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parseBinding(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parseSimpleBinding(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        const /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     * @return {?}\n     */\n    _reportError(message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _parseBindingAst(input, location, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        const /** @type {?} */ quote = this._parseQuote(input, location);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const /** @type {?} */ sourceToLex = this._stripComments(input);\n        const /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    _parseQuote(input, location) {\n        if (input == null)\n            return null;\n        const /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        const /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        const /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    }\n    /**\n     * @param {?} prefixToken\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    parseTemplateBindings(prefixToken, input, location) {\n        const /** @type {?} */ tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            const /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift(...prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parseInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        const /** @type {?} */ expressions = [];\n        for (let /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n            const /** @type {?} */ expressionText = split.expressions[i];\n            const /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n            const /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n            const /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        const /** @type {?} */ parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        const /** @type {?} */ strings = [];\n        const /** @type {?} */ expressions = [];\n        const /** @type {?} */ offsets = [];\n        let /** @type {?} */ offset = 0;\n        for (let /** @type {?} */ i = 0; i < parts.length; i++) {\n            const /** @type {?} */ part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`, location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    wrapLiteralPrimitive(input, location) {\n        return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    _stripComments(input) {\n        const /** @type {?} */ i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    _commentStart(input) {\n        let /** @type {?} */ outerQuote = null;\n        for (let /** @type {?} */ i = 0; i < input.length - 1; i++) {\n            const /** @type {?} */ char = input.charCodeAt(i);\n            const /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n            if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _checkNoInterpolation(input, location, interpolationConfig) {\n        const /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        const /** @type {?} */ parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(`Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`, input, `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`, location);\n        }\n    }\n    /**\n     * @param {?} parts\n     * @param {?} partInErrIdx\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig) {\n        let /** @type {?} */ errLocation = '';\n        for (let /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n        }\n        return errLocation.length;\n    }\n}\nfunction Parser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Parser.prototype.errors;\n    /** @type {?} */\n    Parser.prototype._lexer;\n}\nexport class _ParseAST {\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} tokens\n     * @param {?} inputLength\n     * @param {?} parseAction\n     * @param {?} errors\n     * @param {?} offset\n     */\n    constructor(input, location, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.index = 0;\n    }\n    /**\n     * @param {?} offset\n     * @return {?}\n     */\n    peek(offset) {\n        const /** @type {?} */ i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n    /**\n     * @return {?}\n     */\n    get next() { return this.peek(0); }\n    /**\n     * @return {?}\n     */\n    get inputIndex() {\n        return (this.index < this.tokens.length) ? this.next.index + this.offset :\n            this.inputLength + this.offset;\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    span(start) { return new ParseSpan(start, this.inputIndex); }\n    /**\n     * @return {?}\n     */\n    advance() { this.index++; }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    optionalCharacter(code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    peekKeywordLet() { return this.next.isKeywordLet(); }\n    /**\n     * @return {?}\n     */\n    peekKeywordAs() { return this.next.isKeywordAs(); }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    expectCharacter(code) {\n        if (this.optionalCharacter(code))\n            return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n    /**\n     * @param {?} op\n     * @return {?}\n     */\n    optionalOperator(op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * @param {?} operator\n     * @return {?}\n     */\n    expectOperator(operator) {\n        if (this.optionalOperator(operator))\n            return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n    /**\n     * @return {?}\n     */\n    expectIdentifierOrKeyword() {\n        const /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(`Unexpected token ${n}, expected identifier or keyword`);\n            return '';\n        }\n        this.advance();\n        return /** @type {?} */ (n.toString());\n    }\n    /**\n     * @return {?}\n     */\n    expectIdentifierOrKeywordOrString() {\n        const /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n            return '';\n        }\n        this.advance();\n        return /** @type {?} */ (n.toString());\n    }\n    /**\n     * @return {?}\n     */\n    parseChain() {\n        const /** @type {?} */ exprs = [];\n        const /** @type {?} */ start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const /** @type {?} */ expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.optionalCharacter(chars.$SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter(chars.$SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(`Unexpected token '${this.next}'`);\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), exprs);\n    }\n    /**\n     * @return {?}\n     */\n    parsePipe() {\n        let /** @type {?} */ result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                const /** @type {?} */ name = this.expectIdentifierOrKeyword();\n                const /** @type {?} */ args = [];\n                while (this.optionalCharacter(chars.$COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseExpression() { return this.parseConditional(); }\n    /**\n     * @return {?}\n     */\n    parseConditional() {\n        const /** @type {?} */ start = this.inputIndex;\n        const /** @type {?} */ result = this.parseLogicalOr();\n        if (this.optionalOperator('?')) {\n            const /** @type {?} */ yes = this.parsePipe();\n            let /** @type {?} */ no;\n            if (!this.optionalCharacter(chars.$COLON)) {\n                const /** @type {?} */ end = this.inputIndex;\n                const /** @type {?} */ expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    parseLogicalOr() {\n        // '||'\n        let /** @type {?} */ result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            const /** @type {?} */ right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseLogicalAnd() {\n        // '&&'\n        let /** @type {?} */ result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            const /** @type {?} */ right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseEquality() {\n        // '==','!=','===','!=='\n        let /** @type {?} */ result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            const /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const /** @type {?} */ right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseRelational() {\n        // '<', '>', '<=', '>='\n        let /** @type {?} */ result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            const /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const /** @type {?} */ right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseAdditive() {\n        // '+', '-'\n        let /** @type {?} */ result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            const /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let /** @type {?} */ right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseMultiplicative() {\n        // '*', '%', '/'\n        let /** @type {?} */ result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            const /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let /** @type {?} */ right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parsePrefix() {\n        if (this.next.type == TokenType.Operator) {\n            const /** @type {?} */ start = this.inputIndex;\n            const /** @type {?} */ operator = this.next.strValue;\n            let /** @type {?} */ result;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n    /**\n     * @return {?}\n     */\n    parseCallChain() {\n        let /** @type {?} */ result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter(chars.$PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.optionalCharacter(chars.$LBRACKET)) {\n                this.rbracketsExpected++;\n                const /** @type {?} */ key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter(chars.$RBRACKET);\n                if (this.optionalOperator('=')) {\n                    const /** @type {?} */ value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n            }\n            else if (this.optionalCharacter(chars.$LPAREN)) {\n                this.rparensExpected++;\n                const /** @type {?} */ args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter(chars.$RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n            }\n            else if (this.optionalOperator('!')) {\n                result = new NonNullAssert(this.span(result.span.start), result);\n            }\n            else {\n                return result;\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    parsePrimary() {\n        const /** @type {?} */ start = this.inputIndex;\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const /** @type {?} */ result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter(chars.$RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n        }\n        else if (this.optionalCharacter(chars.$LBRACKET)) {\n            this.rbracketsExpected++;\n            const /** @type {?} */ elements = this.parseExpressionList(chars.$RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter(chars.$RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n        }\n        else if (this.next.isCharacter(chars.$LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            const /** @type {?} */ value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n        }\n        else if (this.next.isString()) {\n            const /** @type {?} */ literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start));\n        }\n        else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start));\n        }\n    }\n    /**\n     * @param {?} terminator\n     * @return {?}\n     */\n    parseExpressionList(terminator) {\n        const /** @type {?} */ result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n        }\n        return result;\n    }\n    /**\n     * @return {?}\n     */\n    parseLiteralMap() {\n        const /** @type {?} */ keys = [];\n        const /** @type {?} */ values = [];\n        const /** @type {?} */ start = this.inputIndex;\n        this.expectCharacter(chars.$LBRACE);\n        if (!this.optionalCharacter(chars.$RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const /** @type {?} */ quoted = this.next.isString();\n                const /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key, quoted });\n                this.expectCharacter(chars.$COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter(chars.$RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    }\n    /**\n     * @param {?} receiver\n     * @param {?=} isSafe\n     * @return {?}\n     */\n    parseAccessMemberOrMethodCall(receiver, isSafe = false) {\n        const /** @type {?} */ start = receiver.span.start;\n        const /** @type {?} */ id = this.expectIdentifierOrKeyword();\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const /** @type {?} */ args = this.parseCallArguments();\n            this.expectCharacter(chars.$RPAREN);\n            this.rparensExpected--;\n            const /** @type {?} */ span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            }\n            else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n                    const /** @type {?} */ value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    parseCallArguments() {\n        if (this.next.isCharacter(chars.$RPAREN))\n            return [];\n        const /** @type {?} */ positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter(chars.$COMMA));\n        return /** @type {?} */ (positionals);\n    }\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     * @return {?}\n     */\n    expectTemplateBindingKey() {\n        let /** @type {?} */ result = '';\n        let /** @type {?} */ operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return result.toString();\n    }\n    /**\n     * @return {?}\n     */\n    parseTemplateBindings() {\n        const /** @type {?} */ bindings = [];\n        let /** @type {?} */ prefix = /** @type {?} */ ((null));\n        const /** @type {?} */ warnings = [];\n        while (this.index < this.tokens.length) {\n            const /** @type {?} */ start = this.inputIndex;\n            let /** @type {?} */ keyIsVar = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            let /** @type {?} */ rawKey = this.expectTemplateBindingKey();\n            let /** @type {?} */ key = rawKey;\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                }\n                else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter(chars.$COLON);\n            let /** @type {?} */ name = /** @type {?} */ ((null));\n            let /** @type {?} */ expression = /** @type {?} */ ((null));\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                }\n                else {\n                    name = '\\$implicit';\n                }\n            }\n            else if (this.peekKeywordAs()) {\n                const /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                name = rawKey;\n                key = this.expectTemplateBindingKey(); // read local var name\n                keyIsVar = true;\n            }\n            else if (this.next !== EOF && !this.peekKeywordLet()) {\n                const /** @type {?} */ start = this.inputIndex;\n                const /** @type {?} */ ast = this.parsePipe();\n                const /** @type {?} */ source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (this.peekKeywordAs() && !keyIsVar) {\n                const /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                const /** @type {?} */ letName = this.expectTemplateBindingKey(); // read local var name\n                bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, /** @type {?} */ ((null))));\n            }\n            if (!this.optionalCharacter(chars.$SEMICOLON)) {\n                this.optionalCharacter(chars.$COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    }\n    /**\n     * @param {?} message\n     * @param {?=} index\n     * @return {?}\n     */\n    error(message, index = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n    /**\n     * @param {?=} index\n     * @return {?}\n     */\n    locationText(index = null) {\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n    /**\n     * @return {?}\n     */\n    skip() {\n        let /** @type {?} */ n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(/** @type {?} */ ((this.next.toString())), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\nfunction _ParseAST_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _ParseAST.prototype.rparensExpected;\n    /** @type {?} */\n    _ParseAST.prototype.rbracketsExpected;\n    /** @type {?} */\n    _ParseAST.prototype.rbracesExpected;\n    /** @type {?} */\n    _ParseAST.prototype.index;\n    /** @type {?} */\n    _ParseAST.prototype.input;\n    /** @type {?} */\n    _ParseAST.prototype.location;\n    /** @type {?} */\n    _ParseAST.prototype.tokens;\n    /** @type {?} */\n    _ParseAST.prototype.inputLength;\n    /** @type {?} */\n    _ParseAST.prototype.parseAction;\n    /** @type {?} */\n    _ParseAST.prototype.errors;\n    /** @type {?} */\n    _ParseAST.prototype.offset;\n}\nclass SimpleExpressionChecker {\n    constructor() {\n        this.errors = [];\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    static check(ast) {\n        const /** @type {?} */ s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitImplicitReceiver(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInterpolation(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralPrimitive(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyRead(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPropertyWrite(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafePropertyRead(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitMethodCall(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitSafeMethodCall(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitFunctionCall(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArray(ast, context) { this.visitAll(ast.expressions); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMap(ast, context) { this.visitAll(ast.values); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBinary(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPrefixNot(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNonNullAssert(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitConditional(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPipe(ast, context) { this.errors.push('pipes'); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedRead(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitKeyedWrite(ast, context) { }\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    visitAll(asts) { return asts.map(node => node.visit(this)); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitChain(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitQuote(ast, context) { }\n}\nfunction SimpleExpressionChecker_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SimpleExpressionChecker.prototype.errors;\n}\n//# sourceMappingURL=parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from \"./chars\";\nimport { identifierModuleUrl, identifierName } from \"./compile_metadata\";\nexport class ParseLocation {\n    /**\n     * @param {?} file\n     * @param {?} offset\n     * @param {?} line\n     * @param {?} col\n     */\n    constructor(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    /**\n     * @return {?}\n     */\n    toString() {\n        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n    }\n    /**\n     * @param {?} delta\n     * @return {?}\n     */\n    moveBy(delta) {\n        const /** @type {?} */ source = this.file.content;\n        const /** @type {?} */ len = source.length;\n        let /** @type {?} */ offset = this.offset;\n        let /** @type {?} */ line = this.line;\n        let /** @type {?} */ col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            const /** @type {?} */ ch = source.charCodeAt(offset);\n            if (ch == chars.$LF) {\n                line--;\n                const /** @type {?} */ priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            const /** @type {?} */ ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == chars.$LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    }\n    /**\n     * @param {?} maxChars\n     * @param {?} maxLines\n     * @return {?}\n     */\n    getContext(maxChars, maxLines) {\n        const /** @type {?} */ content = this.file.content;\n        let /** @type {?} */ startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            let /** @type {?} */ endOffset = startOffset;\n            let /** @type {?} */ ctxChars = 0;\n            let /** @type {?} */ ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    }\n}\nfunction ParseLocation_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParseLocation.prototype.file;\n    /** @type {?} */\n    ParseLocation.prototype.offset;\n    /** @type {?} */\n    ParseLocation.prototype.line;\n    /** @type {?} */\n    ParseLocation.prototype.col;\n}\nexport class ParseSourceFile {\n    /**\n     * @param {?} content\n     * @param {?} url\n     */\n    constructor(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n}\nfunction ParseSourceFile_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParseSourceFile.prototype.content;\n    /** @type {?} */\n    ParseSourceFile.prototype.url;\n}\nexport class ParseSourceSpan {\n    /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?=} details\n     */\n    constructor(start, end, details = null) {\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    /**\n     * @return {?}\n     */\n    toString() {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    }\n}\nfunction ParseSourceSpan_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParseSourceSpan.prototype.start;\n    /** @type {?} */\n    ParseSourceSpan.prototype.end;\n    /** @type {?} */\n    ParseSourceSpan.prototype.details;\n}\n/** @enum {number} */\nconst ParseErrorLevel = {\n    WARNING: 0,\n    ERROR: 1,\n};\nexport { ParseErrorLevel };\nParseErrorLevel[ParseErrorLevel.WARNING] = \"WARNING\";\nParseErrorLevel[ParseErrorLevel.ERROR] = \"ERROR\";\nexport class ParseError {\n    /**\n     * @param {?} span\n     * @param {?} msg\n     * @param {?=} level\n     */\n    constructor(span, msg, level = ParseErrorLevel.ERROR) {\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    /**\n     * @return {?}\n     */\n    contextualMessage() {\n        const /** @type {?} */ ctx = this.span.start.getContext(100, 3);\n        return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n            this.msg;\n    }\n    /**\n     * @return {?}\n     */\n    toString() {\n        const /** @type {?} */ details = this.span.details ? `, ${this.span.details}` : '';\n        return `${this.contextualMessage()}: ${this.span.start}${details}`;\n    }\n}\nfunction ParseError_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParseError.prototype.span;\n    /** @type {?} */\n    ParseError.prototype.msg;\n    /** @type {?} */\n    ParseError.prototype.level;\n}\n/**\n * @param {?} kind\n * @param {?} type\n * @return {?}\n */\nexport function typeSourceSpan(kind, type) {\n    const /** @type {?} */ moduleUrl = identifierModuleUrl(type);\n    const /** @type {?} */ sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :\n        `in ${kind} ${identifierName(type)}`;\n    const /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n//# sourceMappingURL=parse_util.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from \"../chars\";\nimport { ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan } from \"../parse_util\";\nimport { DEFAULT_INTERPOLATION_CONFIG } from \"./interpolation_config\";\nimport { NAMED_ENTITIES, TagContentType } from \"./tags\";\n/** @enum {number} */\nconst TokenType = {\n    TAG_OPEN_START: 0,\n    TAG_OPEN_END: 1,\n    TAG_OPEN_END_VOID: 2,\n    TAG_CLOSE: 3,\n    TEXT: 4,\n    ESCAPABLE_RAW_TEXT: 5,\n    RAW_TEXT: 6,\n    COMMENT_START: 7,\n    COMMENT_END: 8,\n    CDATA_START: 9,\n    CDATA_END: 10,\n    ATTR_NAME: 11,\n    ATTR_VALUE: 12,\n    DOC_TYPE: 13,\n    EXPANSION_FORM_START: 14,\n    EXPANSION_CASE_VALUE: 15,\n    EXPANSION_CASE_EXP_START: 16,\n    EXPANSION_CASE_EXP_END: 17,\n    EXPANSION_FORM_END: 18,\n    EOF: 19,\n};\nexport { TokenType };\nTokenType[TokenType.TAG_OPEN_START] = \"TAG_OPEN_START\";\nTokenType[TokenType.TAG_OPEN_END] = \"TAG_OPEN_END\";\nTokenType[TokenType.TAG_OPEN_END_VOID] = \"TAG_OPEN_END_VOID\";\nTokenType[TokenType.TAG_CLOSE] = \"TAG_CLOSE\";\nTokenType[TokenType.TEXT] = \"TEXT\";\nTokenType[TokenType.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTokenType[TokenType.RAW_TEXT] = \"RAW_TEXT\";\nTokenType[TokenType.COMMENT_START] = \"COMMENT_START\";\nTokenType[TokenType.COMMENT_END] = \"COMMENT_END\";\nTokenType[TokenType.CDATA_START] = \"CDATA_START\";\nTokenType[TokenType.CDATA_END] = \"CDATA_END\";\nTokenType[TokenType.ATTR_NAME] = \"ATTR_NAME\";\nTokenType[TokenType.ATTR_VALUE] = \"ATTR_VALUE\";\nTokenType[TokenType.DOC_TYPE] = \"DOC_TYPE\";\nTokenType[TokenType.EXPANSION_FORM_START] = \"EXPANSION_FORM_START\";\nTokenType[TokenType.EXPANSION_CASE_VALUE] = \"EXPANSION_CASE_VALUE\";\nTokenType[TokenType.EXPANSION_CASE_EXP_START] = \"EXPANSION_CASE_EXP_START\";\nTokenType[TokenType.EXPANSION_CASE_EXP_END] = \"EXPANSION_CASE_EXP_END\";\nTokenType[TokenType.EXPANSION_FORM_END] = \"EXPANSION_FORM_END\";\nTokenType[TokenType.EOF] = \"EOF\";\nexport class Token {\n    /**\n     * @param {?} type\n     * @param {?} parts\n     * @param {?} sourceSpan\n     */\n    constructor(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n}\nfunction Token_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Token.prototype.type;\n    /** @type {?} */\n    Token.prototype.parts;\n    /** @type {?} */\n    Token.prototype.sourceSpan;\n}\nexport class TokenError extends ParseError {\n    /**\n     * @param {?} errorMsg\n     * @param {?} tokenType\n     * @param {?} span\n     */\n    constructor(errorMsg, tokenType, span) {\n        super(span, errorMsg);\n        this.tokenType = tokenType;\n    }\n}\nfunction TokenError_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TokenError.prototype.tokenType;\n}\nexport class TokenizeResult {\n    /**\n     * @param {?} tokens\n     * @param {?} errors\n     */\n    constructor(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n}\nfunction TokenizeResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TokenizeResult.prototype.tokens;\n    /** @type {?} */\n    TokenizeResult.prototype.errors;\n}\n/**\n * @param {?} source\n * @param {?} url\n * @param {?} getTagDefinition\n * @param {?=} tokenizeExpansionForms\n * @param {?=} interpolationConfig\n * @return {?}\n */\nexport function tokenize(source, url, getTagDefinition, tokenizeExpansionForms = false, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)\n        .tokenize();\n}\nconst /** @type {?} */ _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n/**\n * @param {?} charCode\n * @return {?}\n */\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    const /** @type {?} */ char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n    return `Unexpected character \"${char}\"`;\n}\n/**\n * @param {?} entitySrc\n * @return {?}\n */\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nclass _ControlFlowError {\n    /**\n     * @param {?} error\n     */\n    constructor(error) {\n        this.error = error;\n    }\n}\nfunction _ControlFlowError_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _ControlFlowError.prototype.error;\n}\nclass _Tokenizer {\n    /**\n     * @param {?} _file The html source\n     * @param {?} _getTagDefinition\n     * @param {?} _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n     * @param {?=} _interpolationConfig\n     */\n    constructor(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        this._file = _file;\n        this._getTagDefinition = _getTagDefinition;\n        this._tokenizeIcu = _tokenizeIcu;\n        this._interpolationConfig = _interpolationConfig;\n        this._peek = -1;\n        this._nextPeek = -1;\n        this._index = -1;\n        this._line = 0;\n        this._column = -1;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._input = _file.content;\n        this._length = _file.content.length;\n        this._advance();\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    _processCarriageReturns(content) {\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    }\n    /**\n     * @return {?}\n     */\n    tokenize() {\n        while (this._peek !== chars.$EOF) {\n            const /** @type {?} */ start = this._getLocation();\n            try {\n                if (this._attemptCharCode(chars.$LT)) {\n                    if (this._attemptCharCode(chars.$BANG)) {\n                        if (this._attemptCharCode(chars.$LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode(chars.$MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode(chars.$SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (/** @type {?} */ e) {\n                if (e instanceof _ControlFlowError) {\n                    this.errors.push(e.error);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        this._beginToken(TokenType.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    }\n    /**\n     * \\@internal\n     * @return {?} whether an ICU token has been created\n     */\n    _tokenizeExpansionForm() {\n        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._peek === chars.$RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @return {?}\n     */\n    _getLocation() {\n        return new ParseLocation(this._file, this._index, this._line, this._column);\n    }\n    /**\n     * @param {?=} start\n     * @param {?=} end\n     * @return {?}\n     */\n    _getSpan(start = this._getLocation(), end = this._getLocation()) {\n        return new ParseSourceSpan(start, end);\n    }\n    /**\n     * @param {?} type\n     * @param {?=} start\n     * @return {?}\n     */\n    _beginToken(type, start = this._getLocation()) {\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    }\n    /**\n     * @param {?} parts\n     * @param {?=} end\n     * @return {?}\n     */\n    _endToken(parts, end = this._getLocation()) {\n        const /** @type {?} */ token = new Token(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n        this.tokens.push(token);\n        this._currentTokenStart = /** @type {?} */ ((null));\n        this._currentTokenType = /** @type {?} */ ((null));\n        return token;\n    }\n    /**\n     * @param {?} msg\n     * @param {?} span\n     * @return {?}\n     */\n    _createError(msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n        }\n        const /** @type {?} */ error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = /** @type {?} */ ((null));\n        this._currentTokenType = /** @type {?} */ ((null));\n        return new _ControlFlowError(error);\n    }\n    /**\n     * @return {?}\n     */\n    _advance() {\n        if (this._index >= this._length) {\n            throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());\n        }\n        if (this._peek === chars.$LF) {\n            this._line++;\n            this._column = 0;\n        }\n        else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {\n            this._column++;\n        }\n        this._index++;\n        this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);\n        this._nextPeek =\n            this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);\n    }\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _attemptCharCode(charCode) {\n        if (this._peek === charCode) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _attemptCharCodeCaseInsensitive(charCode) {\n        if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _requireCharCode(charCode) {\n        const /** @type {?} */ location = this._getLocation();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n        }\n    }\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _attemptStr(chars) {\n        const /** @type {?} */ len = chars.length;\n        if (this._index + len > this._length) {\n            return false;\n        }\n        const /** @type {?} */ initialPosition = this._savePosition();\n        for (let /** @type {?} */ i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._restorePosition(initialPosition);\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _attemptStrCaseInsensitive(chars) {\n        for (let /** @type {?} */ i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _requireStr(chars) {\n        const /** @type {?} */ location = this._getLocation();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n        }\n    }\n    /**\n     * @param {?} predicate\n     * @return {?}\n     */\n    _attemptCharCodeUntilFn(predicate) {\n        while (!predicate(this._peek)) {\n            this._advance();\n        }\n    }\n    /**\n     * @param {?} predicate\n     * @param {?} len\n     * @return {?}\n     */\n    _requireCharCodeUntilFn(predicate, len) {\n        const /** @type {?} */ start = this._getLocation();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._index - start.offset < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n        }\n    }\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _attemptUntilChar(char) {\n        while (this._peek !== char) {\n            this._advance();\n        }\n    }\n    /**\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _readChar(decodeEntities) {\n        if (decodeEntities && this._peek === chars.$AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            const /** @type {?} */ index = this._index;\n            this._advance();\n            return this._input[index];\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _decodeEntity() {\n        const /** @type {?} */ start = this._getLocation();\n        this._advance();\n        if (this._attemptCharCode(chars.$HASH)) {\n            const /** @type {?} */ isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n            const /** @type {?} */ numberStart = this._getLocation().offset;\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._peek != chars.$SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            this._advance();\n            const /** @type {?} */ strNum = this._input.substring(numberStart, this._index - 1);\n            try {\n                const /** @type {?} */ charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (/** @type {?} */ e) {\n                const /** @type {?} */ entity = this._input.substring(start.offset + 1, this._index - 1);\n                throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n            }\n        }\n        else {\n            const /** @type {?} */ startPosition = this._savePosition();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._peek != chars.$SEMICOLON) {\n                this._restorePosition(startPosition);\n                return '&';\n            }\n            this._advance();\n            const /** @type {?} */ name = this._input.substring(start.offset + 1, this._index - 1);\n            const /** @type {?} */ char = NAMED_ENTITIES[name];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n            }\n            return char;\n        }\n    }\n    /**\n     * @param {?} decodeEntities\n     * @param {?} firstCharOfEnd\n     * @param {?} attemptEndRest\n     * @return {?}\n     */\n    _consumeRawText(decodeEntities, firstCharOfEnd, attemptEndRest) {\n        let /** @type {?} */ tagCloseStart;\n        const /** @type {?} */ textStart = this._getLocation();\n        this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);\n        const /** @type {?} */ parts = [];\n        while (true) {\n            tagCloseStart = this._getLocation();\n            if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n                break;\n            }\n            if (this._index > tagCloseStart.offset) {\n                // add the characters consumed by the previous if statement to the output\n                parts.push(this._input.substring(tagCloseStart.offset, this._index));\n            }\n            while (this._peek !== firstCharOfEnd) {\n                parts.push(this._readChar(decodeEntities));\n            }\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _consumeComment(start) {\n        this._beginToken(TokenType.COMMENT_START, start);\n        this._requireCharCode(chars.$MINUS);\n        this._endToken([]);\n        const /** @type {?} */ textToken = this._consumeRawText(false, chars.$MINUS, () => this._attemptStr('->'));\n        this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _consumeCdata(start) {\n        this._beginToken(TokenType.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        const /** @type {?} */ textToken = this._consumeRawText(false, chars.$RBRACKET, () => this._attemptStr(']>'));\n        this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _consumeDocType(start) {\n        this._beginToken(TokenType.DOC_TYPE, start);\n        this._attemptUntilChar(chars.$GT);\n        this._advance();\n        this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n    }\n    /**\n     * @return {?}\n     */\n    _consumePrefixAndName() {\n        const /** @type {?} */ nameOrPrefixStart = this._index;\n        let /** @type {?} */ prefix = /** @type {?} */ ((null));\n        while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {\n            this._advance();\n        }\n        let /** @type {?} */ nameStart;\n        if (this._peek === chars.$COLON) {\n            this._advance();\n            prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n            nameStart = this._index;\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n        const /** @type {?} */ name = this._input.substring(nameStart, this._index);\n        return [prefix, name];\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _consumeTagOpen(start) {\n        const /** @type {?} */ savedPos = this._savePosition();\n        let /** @type {?} */ tagName;\n        let /** @type {?} */ lowercaseTagName;\n        try {\n            if (!chars.isAsciiLetter(this._peek)) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            const /** @type {?} */ nameStart = this._index;\n            this._consumeTagOpenStart(start);\n            tagName = this._input.substring(nameStart, this._index);\n            lowercaseTagName = tagName.toLowerCase();\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode(chars.$EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (/** @type {?} */ e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid, assume we want a \"<\"\n                this._restorePosition(savedPos);\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        const /** @type {?} */ contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, true);\n        }\n    }\n    /**\n     * @param {?} lowercaseTagName\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _consumeRawTextWithTagClose(lowercaseTagName, decodeEntities) {\n        const /** @type {?} */ textToken = this._consumeRawText(decodeEntities, chars.$LT, () => {\n            if (!this._attemptCharCode(chars.$SLASH))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!this._attemptStrCaseInsensitive(lowercaseTagName))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            return this._attemptCharCode(chars.$GT);\n        });\n        this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);\n        this._endToken([/** @type {?} */ ((null)), lowercaseTagName]);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _consumeTagOpenStart(start) {\n        this._beginToken(TokenType.TAG_OPEN_START, start);\n        const /** @type {?} */ parts = this._consumePrefixAndName();\n        this._endToken(parts);\n    }\n    /**\n     * @return {?}\n     */\n    _consumeAttributeName() {\n        this._beginToken(TokenType.ATTR_NAME);\n        const /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    }\n    /**\n     * @return {?}\n     */\n    _consumeAttributeValue() {\n        this._beginToken(TokenType.ATTR_VALUE);\n        let /** @type {?} */ value;\n        if (this._peek === chars.$SQ || this._peek === chars.$DQ) {\n            const /** @type {?} */ quoteChar = this._peek;\n            this._advance();\n            const /** @type {?} */ parts = [];\n            while (this._peek !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._advance();\n        }\n        else {\n            const /** @type {?} */ valueStart = this._index;\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._input.substring(valueStart, this._index);\n        }\n        this._endToken([this._processCarriageReturns(value)]);\n    }\n    /**\n     * @return {?}\n     */\n    _consumeTagOpenEnd() {\n        const /** @type {?} */ tokenType = this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode(chars.$GT);\n        this._endToken([]);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _consumeTagClose(start) {\n        this._beginToken(TokenType.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        const /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode(chars.$GT);\n        this._endToken(prefixAndName);\n    }\n    /**\n     * @return {?}\n     */\n    _consumeExpansionFormStart() {\n        this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());\n        this._requireCharCode(chars.$LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n        this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n        const /** @type {?} */ condition = this._readUntil(chars.$COMMA);\n        this._endToken([condition], this._getLocation());\n        this._requireCharCode(chars.$COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n        const /** @type {?} */ type = this._readUntil(chars.$COMMA);\n        this._endToken([type], this._getLocation());\n        this._requireCharCode(chars.$COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    }\n    /**\n     * @return {?}\n     */\n    _consumeExpansionCaseStart() {\n        this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());\n        const /** @type {?} */ value = this._readUntil(chars.$LBRACE).trim();\n        this._endToken([value], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());\n        this._requireCharCode(chars.$LBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n    }\n    /**\n     * @return {?}\n     */\n    _consumeExpansionCaseEnd() {\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());\n        this._requireCharCode(chars.$RBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    }\n    /**\n     * @return {?}\n     */\n    _consumeExpansionFormEnd() {\n        this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());\n        this._requireCharCode(chars.$RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    }\n    /**\n     * @return {?}\n     */\n    _consumeText() {\n        const /** @type {?} */ start = this._getLocation();\n        this._beginToken(TokenType.TEXT, start);\n        const /** @type {?} */ parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    /**\n     * @return {?}\n     */\n    _isTextEnd() {\n        if (this._peek === chars.$LT || this._peek === chars.$EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @return {?}\n     */\n    _savePosition() {\n        return [this._peek, this._index, this._column, this._line, this.tokens.length];\n    }\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _readUntil(char) {\n        const /** @type {?} */ start = this._index;\n        this._attemptUntilChar(char);\n        return this._input.substring(start, this._index);\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    _restorePosition(position) {\n        this._peek = position[0];\n        this._index = position[1];\n        this._column = position[2];\n        this._line = position[3];\n        const /** @type {?} */ nbTokens = position[4];\n        if (nbTokens < this.tokens.length) {\n            // remove any extra tokens\n            this.tokens = this.tokens.slice(0, nbTokens);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _isInExpansionCase() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType.EXPANSION_CASE_EXP_START;\n    }\n    /**\n     * @return {?}\n     */\n    _isInExpansionForm() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType.EXPANSION_FORM_START;\n    }\n}\nfunction _Tokenizer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _Tokenizer.prototype._input;\n    /** @type {?} */\n    _Tokenizer.prototype._length;\n    /** @type {?} */\n    _Tokenizer.prototype._peek;\n    /** @type {?} */\n    _Tokenizer.prototype._nextPeek;\n    /** @type {?} */\n    _Tokenizer.prototype._index;\n    /** @type {?} */\n    _Tokenizer.prototype._line;\n    /** @type {?} */\n    _Tokenizer.prototype._column;\n    /** @type {?} */\n    _Tokenizer.prototype._currentTokenStart;\n    /** @type {?} */\n    _Tokenizer.prototype._currentTokenType;\n    /** @type {?} */\n    _Tokenizer.prototype._expansionCaseStack;\n    /** @type {?} */\n    _Tokenizer.prototype._inInterpolation;\n    /** @type {?} */\n    _Tokenizer.prototype.tokens;\n    /** @type {?} */\n    _Tokenizer.prototype.errors;\n    /** @type {?} */\n    _Tokenizer.prototype._file;\n    /** @type {?} */\n    _Tokenizer.prototype._getTagDefinition;\n    /** @type {?} */\n    _Tokenizer.prototype._tokenizeIcu;\n    /** @type {?} */\n    _Tokenizer.prototype._interpolationConfig;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNotWhitespace(code) {\n    return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNameEnd(code) {\n    return chars.isWhitespace(code) || code === chars.$GT || code === chars.$SLASH ||\n        code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isPrefixEnd(code) {\n    return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n        (code < chars.$0 || code > chars.$9);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigitEntityEnd(code) {\n    return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNamedEntityEnd(code) {\n    return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);\n}\n/**\n * @param {?} input\n * @param {?} offset\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction isExpansionFormStart(input, offset, interpolationConfig) {\n    const /** @type {?} */ isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n    return input.charCodeAt(offset) == chars.$LBRACE && !isInterpolationStart;\n}\n/**\n * @param {?} peek\n * @return {?}\n */\nfunction isExpansionCaseStart(peek) {\n    return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n/**\n * @param {?} code1\n * @param {?} code2\n * @return {?}\n */\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction toUpperCaseCharCode(code) {\n    return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n/**\n * @param {?} srcTokens\n * @return {?}\n */\nfunction mergeTextTokens(srcTokens) {\n    const /** @type {?} */ dstTokens = [];\n    let /** @type {?} */ lastDstToken = undefined;\n    for (let /** @type {?} */ i = 0; i < srcTokens.length; i++) {\n        const /** @type {?} */ token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\n//# sourceMappingURL=lexer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ParseError, ParseSourceSpan } from \"../parse_util\";\nimport * as html from \"./ast\";\nimport { DEFAULT_INTERPOLATION_CONFIG } from \"./interpolation_config\";\nimport * as lex from \"./lexer\";\nimport { getNsPrefix, isNgContainer, mergeNsAndName } from \"./tags\";\nexport class TreeError extends ParseError {\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     */\n    constructor(elementName, span, msg) {\n        super(span, msg);\n        this.elementName = elementName;\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     * @return {?}\n     */\n    static create(elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    }\n}\nfunction TreeError_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TreeError.prototype.elementName;\n}\nexport class ParseTreeResult {\n    /**\n     * @param {?} rootNodes\n     * @param {?} errors\n     */\n    constructor(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n}\nfunction ParseTreeResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ParseTreeResult.prototype.rootNodes;\n    /** @type {?} */\n    ParseTreeResult.prototype.errors;\n}\nexport class Parser {\n    /**\n     * @param {?} getTagDefinition\n     */\n    constructor(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parse(source, url, parseExpansionForms = false, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const /** @type {?} */ tokensAndErrors = lex.tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n        const /** @type {?} */ treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, (/** @type {?} */ (tokensAndErrors.errors)).concat(treeAndErrors.errors));\n    }\n}\nfunction Parser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Parser.prototype.getTagDefinition;\n}\nclass _TreeBuilder {\n    /**\n     * @param {?} tokens\n     * @param {?} getTagDefinition\n     */\n    constructor(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    /**\n     * @return {?}\n     */\n    build() {\n        while (this._peek.type !== lex.TokenType.EOF) {\n            if (this._peek.type === lex.TokenType.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === lex.TokenType.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === lex.TokenType.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === lex.TokenType.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === lex.TokenType.TEXT || this._peek.type === lex.TokenType.RAW_TEXT ||\n                this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    }\n    /**\n     * @return {?}\n     */\n    _advance() {\n        const /** @type {?} */ prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _advanceIf(type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    }\n    /**\n     * @param {?} startToken\n     * @return {?}\n     */\n    _consumeCdata(startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(lex.TokenType.CDATA_END);\n    }\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _consumeComment(token) {\n        const /** @type {?} */ text = this._advanceIf(lex.TokenType.RAW_TEXT);\n        this._advanceIf(lex.TokenType.COMMENT_END);\n        const /** @type {?} */ value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new html.Comment(value, token.sourceSpan));\n    }\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _consumeExpansion(token) {\n        const /** @type {?} */ switchValue = this._advance();\n        const /** @type {?} */ type = this._advance();\n        const /** @type {?} */ cases = [];\n        // read =\n        while (this._peek.type === lex.TokenType.EXPANSION_CASE_VALUE) {\n            const /** @type {?} */ expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== lex.TokenType.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n            return;\n        }\n        const /** @type {?} */ sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new html.Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    }\n    /**\n     * @return {?}\n     */\n    _parseExpansionCase() {\n        const /** @type {?} */ value = this._advance();\n        // read {\n        if (this._peek.type !== lex.TokenType.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n            return null;\n        }\n        // read until }\n        const /** @type {?} */ start = this._advance();\n        const /** @type {?} */ exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        const /** @type {?} */ end = this._advance();\n        exp.push(new lex.Token(lex.TokenType.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        const /** @type {?} */ parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(/** @type {?} */ (parsedExp.errors));\n            return null;\n        }\n        const /** @type {?} */ sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        const /** @type {?} */ expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new html.ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    }\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _collectExpansionExpTokens(start) {\n        const /** @type {?} */ exp = [];\n        const /** @type {?} */ expansionFormStack = [lex.TokenType.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === lex.TokenType.EXPANSION_FORM_START ||\n                this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === lex.TokenType.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === lex.TokenType.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    }\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _consumeText(token) {\n        let /** @type {?} */ text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            const /** @type {?} */ parent = this._getParentElement();\n            if (parent != null && parent.children.length == 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new html.Text(text, token.sourceSpan));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _closeVoidElement() {\n        const /** @type {?} */ el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    }\n    /**\n     * @param {?} startTagToken\n     * @return {?}\n     */\n    _consumeStartTag(startTagToken) {\n        const /** @type {?} */ prefix = startTagToken.parts[0];\n        const /** @type {?} */ name = startTagToken.parts[1];\n        const /** @type {?} */ attrs = [];\n        while (this._peek.type === lex.TokenType.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        const /** @type {?} */ fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        let /** @type {?} */ selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === lex.TokenType.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            const /** @type {?} */ tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n            }\n        }\n        else if (this._peek.type === lex.TokenType.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        const /** @type {?} */ end = this._peek.sourceSpan.start;\n        const /** @type {?} */ span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        const /** @type {?} */ el = new html.Element(fullName, attrs, [], span, span, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _pushElement(el) {\n        const /** @type {?} */ parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        const /** @type {?} */ tagDef = this.getTagDefinition(el.name);\n        const { parent, container } = this._getParentElementSkippingContainers();\n        if (parent && tagDef.requireExtraParent(parent.name)) {\n            const /** @type {?} */ newParent = new html.Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n            this._insertBeforeContainer(parent, container, newParent);\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    }\n    /**\n     * @param {?} endTagToken\n     * @return {?}\n     */\n    _consumeEndTag(endTagToken) {\n        const /** @type {?} */ fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            /** @type {?} */ ((this._getParentElement())).endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n        }\n        else if (!this._popElement(fullName)) {\n            const /** @type {?} */ errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    }\n    /**\n     * @param {?} fullName\n     * @return {?}\n     */\n    _popElement(fullName) {\n        for (let /** @type {?} */ stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            const /** @type {?} */ el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    _consumeAttr(attrName) {\n        const /** @type {?} */ fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        let /** @type {?} */ end = attrName.sourceSpan.end;\n        let /** @type {?} */ value = '';\n        let /** @type {?} */ valueSpan = /** @type {?} */ ((undefined));\n        if (this._peek.type === lex.TokenType.ATTR_VALUE) {\n            const /** @type {?} */ valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        return new html.Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    }\n    /**\n     * @return {?}\n     */\n    _getParentElement() {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    }\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     * @return {?}\n     */\n    _getParentElementSkippingContainers() {\n        let /** @type {?} */ container = null;\n        for (let /** @type {?} */ i = this._elementStack.length - 1; i >= 0; i--) {\n            if (!isNgContainer(this._elementStack[i].name)) {\n                return { parent: this._elementStack[i], container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: null, container };\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    _addToParent(node) {\n        const /** @type {?} */ parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    }\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * \\@internal\n     * @param {?} parent\n     * @param {?} container\n     * @param {?} node\n     * @return {?}\n     */\n    _insertBeforeContainer(parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                const /** @type {?} */ index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    }\n    /**\n     * @param {?} prefix\n     * @param {?} localName\n     * @param {?} parentElement\n     * @return {?}\n     */\n    _getElementFullName(prefix, localName, parentElement) {\n        if (prefix == null) {\n            prefix = /** @type {?} */ ((this.getTagDefinition(localName).implicitNamespacePrefix));\n            if (prefix == null && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    }\n}\nfunction _TreeBuilder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _TreeBuilder.prototype._index;\n    /** @type {?} */\n    _TreeBuilder.prototype._peek;\n    /** @type {?} */\n    _TreeBuilder.prototype._rootNodes;\n    /** @type {?} */\n    _TreeBuilder.prototype._errors;\n    /** @type {?} */\n    _TreeBuilder.prototype._elementStack;\n    /** @type {?} */\n    _TreeBuilder.prototype.tokens;\n    /** @type {?} */\n    _TreeBuilder.prototype.getTagDefinition;\n}\n/**\n * @param {?} stack\n * @param {?} element\n * @return {?}\n */\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n//# sourceMappingURL=parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { utf8Encode } from \"../util\";\n/**\n * @param {?} message\n * @return {?}\n */\nexport function digest(message) {\n    return message.id || sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n/**\n * @param {?} message\n * @return {?}\n */\nexport function decimalDigest(message) {\n    if (message.id) {\n        return message.id;\n    }\n    const /** @type {?} */ visitor = new _SerializerIgnoreIcuExpVisitor();\n    const /** @type {?} */ parts = message.nodes.map(a => a.visit(visitor, null));\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * \\@internal\n */\nclass _SerializerVisitor {\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { return text.value; }\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        const /** @type {?} */ strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n    }\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        return ph.isVoid ?\n            `<ph tag name=\"${ph.startName}\"/>` :\n            `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n    }\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) {\n        return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n    }\n}\nconst /** @type {?} */ serializerVisitor = new _SerializerVisitor();\n/**\n * @param {?} nodes\n * @return {?}\n */\nexport function serializeNodes(nodes) {\n    return nodes.map(a => a.visit(serializerVisitor, null));\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * \\@internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        let /** @type {?} */ strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        // Do not take the expression into account\n        return `{${icu.type}, ${strCases.join(', ')}}`;\n    }\n}\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n * @param {?} str\n * @return {?}\n */\nexport function sha1(str) {\n    const /** @type {?} */ utf8 = utf8Encode(str);\n    const /** @type {?} */ words32 = stringToWords32(utf8, Endian.Big);\n    const /** @type {?} */ len = utf8.length * 8;\n    const /** @type {?} */ w = new Array(80);\n    let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (let /** @type {?} */ i = 0; i < words32.length; i += 16) {\n        const [h0, h1, h2, h3, h4] = [a, b, c, d, e];\n        for (let /** @type {?} */ j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            const [f, k] = fk(j, b, c, d);\n            const /** @type {?} */ temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];\n        }\n        [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\n/**\n * @param {?} index\n * @param {?} b\n * @param {?} c\n * @param {?} d\n * @return {?}\n */\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n * @param {?} str\n * @return {?}\n */\nexport function fingerprint(str) {\n    const /** @type {?} */ utf8 = utf8Encode(str);\n    let [hi, lo] = [hash32(utf8, 0), hash32(utf8, 102072)];\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\n/**\n * @param {?} msg\n * @param {?} meaning\n * @return {?}\n */\nexport function computeMsgId(msg, meaning) {\n    let [hi, lo] = fingerprint(msg);\n    if (meaning) {\n        const [him, lom] = fingerprint(meaning);\n        [hi, lo] = add64(rol64([hi, lo], 1), [him, lom]);\n    }\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\n/**\n * @param {?} str\n * @param {?} c\n * @return {?}\n */\nfunction hash32(str, c) {\n    let [a, b] = [0x9e3779b9, 0x9e3779b9];\n    let /** @type {?} */ i;\n    const /** @type {?} */ len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        [a, b, c] = mix([a, b, c]);\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix([a, b, c])[2];\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction mix([a, b, c]) {\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\n/** @enum {number} */\nconst Endian = {\n    Little: 0,\n    Big: 1,\n};\nEndian[Endian.Little] = \"Little\";\nEndian[Endian.Big] = \"Big\";\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32to64(a, b) {\n    const /** @type {?} */ low = (a & 0xffff) + (b & 0xffff);\n    const /** @type {?} */ high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n/**\n * @param {?} __0\n * @param {?} __1\n * @return {?}\n */\nfunction add64([ah, al], [bh, bl]) {\n    const [carry, l] = add32to64(al, bl);\n    const /** @type {?} */ h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sub32(a, b) {\n    const /** @type {?} */ low = (a & 0xffff) - (b & 0xffff);\n    const /** @type {?} */ high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n/**\n * @param {?} a\n * @param {?} count\n * @return {?}\n */\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n/**\n * @param {?} __0\n * @param {?} count\n * @return {?}\n */\nfunction rol64([hi, lo], count) {\n    const /** @type {?} */ h = (hi << count) | (lo >>> (32 - count));\n    const /** @type {?} */ l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\n/**\n * @param {?} str\n * @param {?} endian\n * @return {?}\n */\nfunction stringToWords32(str, endian) {\n    const /** @type {?} */ words32 = Array((str.length + 3) >>> 2);\n    for (let /** @type {?} */ i = 0; i < words32.length; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @return {?}\n */\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @param {?} endian\n * @return {?}\n */\nfunction wordAt(str, index, endian) {\n    let /** @type {?} */ word = 0;\n    if (endian === Endian.Big) {\n        for (let /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (let /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\n/**\n * @param {?} words32\n * @return {?}\n */\nfunction words32ToByteString(words32) {\n    return words32.reduce((str, word) => str + word32ToByteString(word), '');\n}\n/**\n * @param {?} word\n * @return {?}\n */\nfunction word32ToByteString(word) {\n    let /** @type {?} */ str = '';\n    for (let /** @type {?} */ i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToHexString(str) {\n    let /** @type {?} */ hex = '';\n    for (let /** @type {?} */ i = 0; i < str.length; i++) {\n        const /** @type {?} */ b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToDecString(str) {\n    let /** @type {?} */ decimal = '';\n    let /** @type {?} */ toThePower = '1';\n    for (let /** @type {?} */ i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n/**\n * @param {?} x\n * @param {?} y\n * @return {?}\n */\nfunction addBigInt(x, y) {\n    let /** @type {?} */ sum = '';\n    const /** @type {?} */ len = Math.max(x.length, y.length);\n    for (let /** @type {?} */ i = 0, /** @type {?} */ carry = 0; i < len || carry; i++) {\n        const /** @type {?} */ tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\n/**\n * @param {?} num\n * @param {?} b\n * @return {?}\n */\nfunction numberTimesBigInt(num, b) {\n    let /** @type {?} */ product = '';\n    let /** @type {?} */ bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n//# sourceMappingURL=digest.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport class Message {\n    /**\n     * @param {?} nodes message AST\n     * @param {?} placeholders maps placeholder names to static content\n     * @param {?} placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     */\n    constructor(nodes, placeholders, placeholderToMessage, meaning, description, id) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.id = id;\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n}\nfunction Message_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Message.prototype.sources;\n    /** @type {?} */\n    Message.prototype.nodes;\n    /** @type {?} */\n    Message.prototype.placeholders;\n    /** @type {?} */\n    Message.prototype.placeholderToMessage;\n    /** @type {?} */\n    Message.prototype.meaning;\n    /** @type {?} */\n    Message.prototype.description;\n    /** @type {?} */\n    Message.prototype.id;\n}\n/**\n * @record\n */\nexport function MessageSpan() { }\nfunction MessageSpan_tsickle_Closure_declarations() {\n    /** @type {?} */\n    MessageSpan.prototype.filePath;\n    /** @type {?} */\n    MessageSpan.prototype.startLine;\n    /** @type {?} */\n    MessageSpan.prototype.startCol;\n    /** @type {?} */\n    MessageSpan.prototype.endLine;\n    /** @type {?} */\n    MessageSpan.prototype.endCol;\n}\n/**\n * @record\n */\nexport function Node() { }\nfunction Node_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Node.prototype.sourceSpan;\n    /** @type {?} */\n    Node.prototype.visit;\n}\nexport class Text {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitText(this, context); }\n}\nfunction Text_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Text.prototype.value;\n    /** @type {?} */\n    Text.prototype.sourceSpan;\n}\nexport class Container {\n    /**\n     * @param {?} children\n     * @param {?} sourceSpan\n     */\n    constructor(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitContainer(this, context); }\n}\nfunction Container_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Container.prototype.children;\n    /** @type {?} */\n    Container.prototype.sourceSpan;\n}\nexport class Icu {\n    /**\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     */\n    constructor(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitIcu(this, context); }\n}\nfunction Icu_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Icu.prototype.expressionPlaceholder;\n    /** @type {?} */\n    Icu.prototype.expression;\n    /** @type {?} */\n    Icu.prototype.type;\n    /** @type {?} */\n    Icu.prototype.cases;\n    /** @type {?} */\n    Icu.prototype.sourceSpan;\n}\nexport class TagPlaceholder {\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} startName\n     * @param {?} closeName\n     * @param {?} children\n     * @param {?} isVoid\n     * @param {?} sourceSpan\n     */\n    constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitTagPlaceholder(this, context); }\n}\nfunction TagPlaceholder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TagPlaceholder.prototype.tag;\n    /** @type {?} */\n    TagPlaceholder.prototype.attrs;\n    /** @type {?} */\n    TagPlaceholder.prototype.startName;\n    /** @type {?} */\n    TagPlaceholder.prototype.closeName;\n    /** @type {?} */\n    TagPlaceholder.prototype.children;\n    /** @type {?} */\n    TagPlaceholder.prototype.isVoid;\n    /** @type {?} */\n    TagPlaceholder.prototype.sourceSpan;\n}\nexport class Placeholder {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitPlaceholder(this, context); }\n}\nfunction Placeholder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Placeholder.prototype.value;\n    /** @type {?} */\n    Placeholder.prototype.name;\n    /** @type {?} */\n    Placeholder.prototype.sourceSpan;\n}\nexport class IcuPlaceholder {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    visit(visitor, context) { return visitor.visitIcuPlaceholder(this, context); }\n}\nfunction IcuPlaceholder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    IcuPlaceholder.prototype.value;\n    /** @type {?} */\n    IcuPlaceholder.prototype.name;\n    /** @type {?} */\n    IcuPlaceholder.prototype.sourceSpan;\n}\n/**\n * @record\n */\nexport function Visitor() { }\nfunction Visitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Visitor.prototype.visitText;\n    /** @type {?} */\n    Visitor.prototype.visitContainer;\n    /** @type {?} */\n    Visitor.prototype.visitIcu;\n    /** @type {?} */\n    Visitor.prototype.visitTagPlaceholder;\n    /** @type {?} */\n    Visitor.prototype.visitPlaceholder;\n    /** @type {?} */\n    Visitor.prototype.visitIcuPlaceholder;\n}\nexport class CloneVisitor {\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { return new Text(text.value, text.sourceSpan); }\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        const /** @type {?} */ children = container.children.map(n => n.visit(this, context));\n        return new Container(children, container.sourceSpan);\n    }\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        const /** @type {?} */ cases = {};\n        Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n        const /** @type {?} */ msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        const /** @type {?} */ children = ph.children.map(n => n.visit(this, context));\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    }\n}\nexport class RecurseVisitor {\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { }\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        container.children.forEach(child => child.visit(this));\n    }\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        Object.keys(icu.cases).forEach(k => { icu.cases[k].visit(this); });\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        ph.children.forEach(child => child.visit(this));\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) { }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) { }\n}\n//# sourceMappingURL=i18n_ast.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { TagContentType } from \"./tags\";\nexport class HtmlTagDefinition {\n    /**\n     * @param {?=} __0\n     */\n    constructor({ closedByChildren, requiredParents, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false } = {}) {\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        if (requiredParents && requiredParents.length > 0) {\n            this.requiredParents = {};\n            // The first parent is the list is automatically when none of the listed parents are present\n            this.parentToAdd = requiredParents[0];\n            requiredParents.forEach(tagName => this.requiredParents[tagName] = true);\n        }\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    requireExtraParent(currentParent) {\n        if (!this.requiredParents) {\n            return false;\n        }\n        if (!currentParent) {\n            return true;\n        }\n        const /** @type {?} */ lcParent = currentParent.toLowerCase();\n        const /** @type {?} */ isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n        return !isParentTemplate && this.requiredParents[lcParent] != true;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    isClosedByChild(name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    }\n}\nfunction HtmlTagDefinition_tsickle_Closure_declarations() {\n    /** @type {?} */\n    HtmlTagDefinition.prototype.closedByChildren;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.closedByParent;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.requiredParents;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.parentToAdd;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.implicitNamespacePrefix;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.contentType;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.isVoid;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.ignoreFirstLf;\n    /** @type {?} */\n    HtmlTagDefinition.prototype.canSelfClose;\n}\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nconst /** @type {?} */ TAG_DEFINITIONS = {\n    'base': new HtmlTagDefinition({ isVoid: true }),\n    'meta': new HtmlTagDefinition({ isVoid: true }),\n    'area': new HtmlTagDefinition({ isVoid: true }),\n    'embed': new HtmlTagDefinition({ isVoid: true }),\n    'link': new HtmlTagDefinition({ isVoid: true }),\n    'img': new HtmlTagDefinition({ isVoid: true }),\n    'input': new HtmlTagDefinition({ isVoid: true }),\n    'param': new HtmlTagDefinition({ isVoid: true }),\n    'hr': new HtmlTagDefinition({ isVoid: true }),\n    'br': new HtmlTagDefinition({ isVoid: true }),\n    'source': new HtmlTagDefinition({ isVoid: true }),\n    'track': new HtmlTagDefinition({ isVoid: true }),\n    'wbr': new HtmlTagDefinition({ isVoid: true }),\n    'p': new HtmlTagDefinition({\n        closedByChildren: [\n            'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',\n            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',\n            'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'\n        ],\n        closedByParent: true\n    }),\n    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n    'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        requiredParents: ['tbody', 'tfoot', 'thead'],\n        closedByParent: true\n    }),\n    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\n    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n    'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n};\nconst /** @type {?} */ _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nexport function getHtmlTagDefinition(tagName) {\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n//# sourceMappingURL=html_tags.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst /** @type {?} */ TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * \\@internal\n */\nexport class PlaceholderRegistry {\n    constructor() {\n        this._placeHolderNameCounts = {};\n        this._signatureToName = {};\n    }\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    getStartTagPlaceholderName(tag, attrs, isVoid) {\n        const /** @type {?} */ signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const /** @type {?} */ upperTag = tag.toUpperCase();\n        const /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const /** @type {?} */ name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    getCloseTagPlaceholderName(tag) {\n        const /** @type {?} */ signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const /** @type {?} */ upperTag = tag.toUpperCase();\n        const /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const /** @type {?} */ name = this._generateUniqueName(`CLOSE_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    /**\n     * @param {?} name\n     * @param {?} content\n     * @return {?}\n     */\n    getPlaceholderName(name, content) {\n        const /** @type {?} */ upperName = name.toUpperCase();\n        const /** @type {?} */ signature = `PH: ${upperName}=${content}`;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const /** @type {?} */ uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getUniquePlaceholder(name) {\n        return this._generateUniqueName(name.toUpperCase());\n    }\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    _hashTag(tag, attrs, isVoid) {\n        const /** @type {?} */ start = `<${tag}`;\n        const /** @type {?} */ strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n        const /** @type {?} */ end = isVoid ? '/>' : `></${tag}>`;\n        return start + strAttrs + end;\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    _hashClosingTag(tag) { return this._hashTag(`/${tag}`, {}, false); }\n    /**\n     * @param {?} base\n     * @return {?}\n     */\n    _generateUniqueName(base) {\n        const /** @type {?} */ seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        const /** @type {?} */ id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return `${base}_${id}`;\n    }\n}\nfunction PlaceholderRegistry_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PlaceholderRegistry.prototype._placeHolderNameCounts;\n    /** @type {?} */\n    PlaceholderRegistry.prototype._signatureToName;\n}\n//# sourceMappingURL=placeholder.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Lexer as ExpressionLexer } from \"../expression_parser/lexer\";\nimport { Parser as ExpressionParser } from \"../expression_parser/parser\";\nimport * as html from \"../ml_parser/ast\";\nimport { getHtmlTagDefinition } from \"../ml_parser/html_tags\";\nimport * as i18n from \"./i18n_ast\";\nimport { PlaceholderRegistry } from \"./serializers/placeholder\";\nconst /** @type {?} */ _expParser = new ExpressionParser(new ExpressionLexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n * @param {?} interpolationConfig\n * @return {?}\n */\nexport function createI18nMessageFactory(interpolationConfig) {\n    const /** @type {?} */ visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return (nodes, meaning, description, id) => visitor.toI18nMessage(nodes, meaning, description, id);\n}\nclass _I18nVisitor {\n    /**\n     * @param {?} _expressionParser\n     * @param {?} _interpolationConfig\n     */\n    constructor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     * @return {?}\n     */\n    toI18nMessage(nodes, meaning, description, id) {\n        this._isIcu = nodes.length == 1 && nodes[0] instanceof html.Expansion;\n        this._icuDepth = 0;\n        this._placeholderRegistry = new PlaceholderRegistry();\n        this._placeholderToContent = {};\n        this._placeholderToMessage = {};\n        const /** @type {?} */ i18nodes = html.visitAll(this, nodes, {});\n        return new i18n.Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n    }\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(el, context) {\n        const /** @type {?} */ children = html.visitAll(this, el.children);\n        const /** @type {?} */ attrs = {};\n        el.attrs.forEach(attr => {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        const /** @type {?} */ isVoid = getHtmlTagDefinition(el.name).isVoid;\n        const /** @type {?} */ startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        this._placeholderToContent[startPhName] = /** @type {?} */ ((el.sourceSpan)).toString();\n        let /** @type {?} */ closePhName = '';\n        if (!isVoid) {\n            closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            this._placeholderToContent[closePhName] = `</${el.name}>`;\n        }\n        return new i18n.TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, /** @type {?} */ ((el.sourceSpan)));\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) {\n        return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) {\n        return this._visitTextWithInterpolation(text.value, /** @type {?} */ ((text.sourceSpan)));\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { return null; }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(icu, context) {\n        this._icuDepth++;\n        const /** @type {?} */ i18nIcuCases = {};\n        const /** @type {?} */ i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach((caze) => {\n            i18nIcuCases[caze.value] = new i18n.Container(caze.expression.map((node) => node.visit(this, {})), caze.expSourceSpan);\n        });\n        this._icuDepth--;\n        if (this._isIcu || this._icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            const /** @type {?} */ expPh = this._placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n            i18nIcu.expressionPlaceholder = expPh;\n            this._placeholderToContent[expPh] = icu.switchValue;\n            return i18nIcu;\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations. We need to create a new visitor (they are not re-entrant) to compute the\n        // message id.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        const /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        const /** @type {?} */ visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n        this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n        return new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    }\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(icuCase, context) {\n        throw new Error('Unreachable code');\n    }\n    /**\n     * @param {?} text\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _visitTextWithInterpolation(text, sourceSpan) {\n        const /** @type {?} */ splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new i18n.Text(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        const /** @type {?} */ nodes = [];\n        const /** @type {?} */ container = new i18n.Container(nodes, sourceSpan);\n        const { start: sDelimiter, end: eDelimiter } = this._interpolationConfig;\n        for (let /** @type {?} */ i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            const /** @type {?} */ expression = splitInterpolation.expressions[i];\n            const /** @type {?} */ baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            const /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new i18n.Text(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new i18n.Placeholder(expression, phName, sourceSpan));\n            this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        const /** @type {?} */ lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    }\n}\nfunction _I18nVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _I18nVisitor.prototype._isIcu;\n    /** @type {?} */\n    _I18nVisitor.prototype._icuDepth;\n    /** @type {?} */\n    _I18nVisitor.prototype._placeholderRegistry;\n    /** @type {?} */\n    _I18nVisitor.prototype._placeholderToContent;\n    /** @type {?} */\n    _I18nVisitor.prototype._placeholderToMessage;\n    /** @type {?} */\n    _I18nVisitor.prototype._expressionParser;\n    /** @type {?} */\n    _I18nVisitor.prototype._interpolationConfig;\n}\nconst /** @type {?} */ _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n//# sourceMappingURL=i18n_parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ParseError } from \"../parse_util\";\n/**\n * An i18n error.\n */\nexport class I18nError extends ParseError {\n    /**\n     * @param {?} span\n     * @param {?} msg\n     */\n    constructor(span, msg) { super(span, msg); }\n}\n//# sourceMappingURL=parse_util.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as html from \"../ml_parser/ast\";\nimport { ParseTreeResult } from \"../ml_parser/parser\";\nimport * as i18n from \"./i18n_ast\";\nimport { createI18nMessageFactory } from \"./i18n_parser\";\nimport { I18nError } from \"./parse_util\";\nconst /** @type {?} */ _I18N_ATTR = 'i18n';\nconst /** @type {?} */ _I18N_ATTR_PREFIX = 'i18n-';\nconst /** @type {?} */ _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst /** @type {?} */ MEANING_SEPARATOR = '|';\nconst /** @type {?} */ ID_SEPARATOR = '@@';\nlet /** @type {?} */ i18nCommentsWarned = false;\n/**\n * Extract translatable messages from an html AST\n * @param {?} nodes\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nexport function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    const /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\n/**\n * @param {?} nodes\n * @param {?} translations\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nexport function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    const /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nexport class ExtractionResult {\n    /**\n     * @param {?} messages\n     * @param {?} errors\n     */\n    constructor(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n}\nfunction ExtractionResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExtractionResult.prototype.messages;\n    /** @type {?} */\n    ExtractionResult.prototype.errors;\n}\n/** @enum {number} */\nconst _VisitorMode = {\n    Extract: 0,\n    Merge: 1,\n};\n_VisitorMode[_VisitorMode.Extract] = \"Extract\";\n_VisitorMode[_VisitorMode.Merge] = \"Merge\";\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * \\@internal\n */\nclass _Visitor {\n    /**\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     */\n    constructor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     * @param {?} nodes\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    extract(nodes, interpolationConfig) {\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(node => node.visit(this, null));\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    }\n    /**\n     * Returns a tree where all translatable nodes are translated\n     * @param {?} nodes\n     * @param {?} translations\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    merge(nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        const /** @type {?} */ wrapper = new html.Element('wrapper', [], nodes, /** @type {?} */ ((undefined)), undefined, undefined);\n        const /** @type {?} */ translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    }\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(icuCase, context) {\n        // Parse cases for translatable html attributes\n        const /** @type {?} */ expression = html.visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new html.ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        const /** @type {?} */ wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        const /** @type {?} */ cases = html.visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new html.Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) {\n        const /** @type {?} */ isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        const /** @type {?} */ isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n                    if (!i18nCommentsWarned && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {\n                        i18nCommentsWarned = true;\n                        const /** @type {?} */ details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n                        // TODO(ocombe): use a log service once there is a public one available\n                        console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n                    }\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc = /** @type {?} */ ((comment.value)).replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        const /** @type {?} */ message = /** @type {?} */ ((this._addMessage(this._blockChildren, this._blockMeaningAndDesc)));\n                        // merge attributes in sections\n                        const /** @type {?} */ nodes = this._translateMessage(comment, message);\n                        return html.visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    }\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(el, context) {\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        const /** @type {?} */ wasInI18nNode = this._inI18nNode;\n        const /** @type {?} */ wasInImplicitNode = this._inImplicitNode;\n        let /** @type {?} */ childNodes = [];\n        let /** @type {?} */ translatedChildNodes = /** @type {?} */ ((undefined));\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        const /** @type {?} */ i18nAttr = _getI18nAttr(el);\n        const /** @type {?} */ i18nMeta = i18nAttr ? i18nAttr.value : '';\n        const /** @type {?} */ isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        const /** @type {?} */ isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                const /** @type {?} */ message = /** @type {?} */ ((this._addMessage(el.children, i18nMeta)));\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                const /** @type {?} */ isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                html.visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                html.visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            const /** @type {?} */ visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(child => {\n                const /** @type {?} */ visited = child.visit(this, context);\n                if (visited && !this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            const /** @type {?} */ translatedAttrs = this._translateAttributes(el);\n            return new html.Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) {\n        throw new Error('unreachable code');\n    }\n    /**\n     * @param {?} mode\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _init(mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _visitAttributesOf(el) {\n        const /** @type {?} */ explicitAttrNameToValue = {};\n        const /** @type {?} */ implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n            .forEach(attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value);\n        el.attrs.forEach(attr => {\n            if (attr.name in explicitAttrNameToValue) {\n                this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(name => attr.name === name)) {\n                this._addMessage([attr]);\n            }\n        });\n    }\n    /**\n     * @param {?} ast\n     * @param {?=} msgMeta\n     * @return {?}\n     */\n    _addMessage(ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof html.Attribute && !(/** @type {?} */ (ast[0])).value) {\n            // Do not create empty messages\n            return null;\n        }\n        const { meaning, description, id } = _parseMessageMeta(msgMeta);\n        const /** @type {?} */ message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    }\n    /**\n     * @param {?} el\n     * @param {?} message\n     * @return {?}\n     */\n    _translateMessage(el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            const /** @type {?} */ nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n        }\n        return [];\n    }\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _translateAttributes(el) {\n        const /** @type {?} */ attributes = el.attrs;\n        const /** @type {?} */ i18nParsedMessageMeta = {};\n        attributes.forEach(attr => {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        const /** @type {?} */ translatedAttributes = [];\n        attributes.forEach((attr) => {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                const { meaning, description, id } = i18nParsedMessageMeta[attr.name];\n                const /** @type {?} */ message = this._createI18nMessage([attr], meaning, description, id);\n                const /** @type {?} */ nodes = this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new html.Attribute(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof html.Text) {\n                        const /** @type {?} */ value = (/** @type {?} */ (nodes[0])).value;\n                        translatedAttributes.push(new html.Attribute(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        this._reportError(el, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                    }\n                }\n                else {\n                    this._reportError(el, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    }\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     * @param {?} node\n     * @return {?}\n     */\n    _mayBeAddBlockChildren(node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    }\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     * @param {?} node\n     * @return {?}\n     */\n    _openTranslatableSection(node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    }\n    /**\n     * A translatable section could be:\n     * - the content of translatable element,\n     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n     * @return {?}\n     */\n    get _isInTranslatableSection() {\n        return this._msgCountAtSectionStart !== void 0;\n    }\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     * @param {?} node\n     * @param {?} directChildren\n     * @return {?}\n     */\n    _closeTranslatableSection(node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        const /** @type {?} */ startIndex = this._msgCountAtSectionStart;\n        const /** @type {?} */ significantChildren = directChildren.reduce((count, node) => count + (node instanceof html.Comment ? 0 : 1), 0);\n        if (significantChildren == 1) {\n            for (let /** @type {?} */ i = this._messages.length - 1; i >= /** @type {?} */ ((startIndex)); i--) {\n                const /** @type {?} */ ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    }\n    /**\n     * @param {?} node\n     * @param {?} msg\n     * @return {?}\n     */\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), msg));\n    }\n}\nfunction _Visitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _Visitor.prototype._depth;\n    /** @type {?} */\n    _Visitor.prototype._inI18nNode;\n    /** @type {?} */\n    _Visitor.prototype._inImplicitNode;\n    /** @type {?} */\n    _Visitor.prototype._inI18nBlock;\n    /** @type {?} */\n    _Visitor.prototype._blockMeaningAndDesc;\n    /** @type {?} */\n    _Visitor.prototype._blockChildren;\n    /** @type {?} */\n    _Visitor.prototype._blockStartDepth;\n    /** @type {?} */\n    _Visitor.prototype._inIcu;\n    /** @type {?} */\n    _Visitor.prototype._msgCountAtSectionStart;\n    /** @type {?} */\n    _Visitor.prototype._errors;\n    /** @type {?} */\n    _Visitor.prototype._mode;\n    /** @type {?} */\n    _Visitor.prototype._messages;\n    /** @type {?} */\n    _Visitor.prototype._translations;\n    /** @type {?} */\n    _Visitor.prototype._createI18nMessage;\n    /** @type {?} */\n    _Visitor.prototype._implicitTags;\n    /** @type {?} */\n    _Visitor.prototype._implicitAttrs;\n}\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isOpeningComment(n) {\n    return !!(n instanceof html.Comment && n.value && n.value.startsWith('i18n'));\n}\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isClosingComment(n) {\n    return !!(n instanceof html.Comment && n.value && n.value === '/i18n');\n}\n/**\n * @param {?} p\n * @return {?}\n */\nfunction _getI18nAttr(p) {\n    return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n/**\n * @param {?=} i18n\n * @return {?}\n */\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    const /** @type {?} */ idIndex = i18n.indexOf(ID_SEPARATOR);\n    const /** @type {?} */ descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    const [meaningAndDesc, id] = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n    const [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n    return { meaning, description, id };\n}\n//# sourceMappingURL=extractor_merger.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { TagContentType } from \"./tags\";\nexport class XmlTagDefinition {\n    constructor() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    requireExtraParent(currentParent) { return false; }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    isClosedByChild(name) { return false; }\n}\nfunction XmlTagDefinition_tsickle_Closure_declarations() {\n    /** @type {?} */\n    XmlTagDefinition.prototype.closedByParent;\n    /** @type {?} */\n    XmlTagDefinition.prototype.requiredParents;\n    /** @type {?} */\n    XmlTagDefinition.prototype.parentToAdd;\n    /** @type {?} */\n    XmlTagDefinition.prototype.implicitNamespacePrefix;\n    /** @type {?} */\n    XmlTagDefinition.prototype.contentType;\n    /** @type {?} */\n    XmlTagDefinition.prototype.isVoid;\n    /** @type {?} */\n    XmlTagDefinition.prototype.ignoreFirstLf;\n    /** @type {?} */\n    XmlTagDefinition.prototype.canSelfClose;\n}\nconst /** @type {?} */ _TAG_DEFINITION = new XmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nexport function getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n//# sourceMappingURL=xml_tags.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Parser } from \"./parser\";\nimport { getXmlTagDefinition } from \"./xml_tags\";\nexport { ParseTreeResult, TreeError } from \"./parser\";\nexport class XmlParser extends Parser {\n    constructor() { super(getXmlTagDefinition); }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @return {?}\n     */\n    parse(source, url, parseExpansionForms = false) {\n        return super.parse(source, url, parseExpansionForms);\n    }\n}\n//# sourceMappingURL=xml_parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from \"../i18n_ast\";\n/**\n * @abstract\n */\nexport class Serializer {\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    createNameMapper(message) { return null; }\n}\nfunction Serializer_tsickle_Closure_declarations() {\n    /**\n     * @abstract\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Serializer.prototype.write = function (messages, locale) { };\n    /**\n     * @abstract\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Serializer.prototype.load = function (content, url) { };\n    /**\n     * @abstract\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.digest = function (message) { };\n}\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n * @record\n */\nexport function PlaceholderMapper() { }\nfunction PlaceholderMapper_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PlaceholderMapper.prototype.toPublicName;\n    /** @type {?} */\n    PlaceholderMapper.prototype.toInternalName;\n}\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor {\n    /**\n     * @param {?} message\n     * @param {?} mapName\n     */\n    constructor(message, mapName) {\n        super();\n        this.mapName = mapName;\n        this.internalToPublic = {};\n        this.publicToNextId = {};\n        this.publicToInternal = {};\n        message.nodes.forEach(node => node.visit(this));\n    }\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    toPublicName(internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    }\n    /**\n     * @param {?} publicName\n     * @return {?}\n     */\n    toInternalName(publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { return null; }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        super.visitTagPlaceholder(ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) { this.visitPlaceholderName(ph.name); }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    visitPlaceholderName(internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        let /** @type {?} */ publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            const /** @type {?} */ nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = `${publicName}_${nextId}`;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    }\n}\nfunction SimplePlaceholderMapper_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SimplePlaceholderMapper.prototype.internalToPublic;\n    /** @type {?} */\n    SimplePlaceholderMapper.prototype.publicToNextId;\n    /** @type {?} */\n    SimplePlaceholderMapper.prototype.publicToInternal;\n    /** @type {?} */\n    SimplePlaceholderMapper.prototype.mapName;\n}\n//# sourceMappingURL=serializer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\nexport function IVisitor() { }\nfunction IVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    IVisitor.prototype.visitTag;\n    /** @type {?} */\n    IVisitor.prototype.visitText;\n    /** @type {?} */\n    IVisitor.prototype.visitDeclaration;\n    /** @type {?} */\n    IVisitor.prototype.visitDoctype;\n}\nclass _Visitor {\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    visitTag(tag) {\n        const /** @type {?} */ strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return `<${tag.name}${strAttrs}/>`;\n        }\n        const /** @type {?} */ strChildren = tag.children.map(node => node.visit(this));\n        return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n    }\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    visitText(text) { return text.value; }\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    visitDeclaration(decl) {\n        return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n    }\n    /**\n     * @param {?} attrs\n     * @return {?}\n     */\n    _serializeAttributes(attrs) {\n        const /** @type {?} */ strAttrs = Object.keys(attrs).map((name) => `${name}=\"${attrs[name]}\"`).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    }\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    visitDoctype(doctype) {\n        return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n    }\n}\nconst /** @type {?} */ _visitor = new _Visitor();\n/**\n * @param {?} nodes\n * @return {?}\n */\nexport function serialize(nodes) {\n    return nodes.map((node) => node.visit(_visitor)).join('');\n}\n/**\n * @record\n */\nexport function Node() { }\nfunction Node_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Node.prototype.visit;\n}\nexport class Declaration {\n    /**\n     * @param {?} unescapedAttrs\n     */\n    constructor(unescapedAttrs) {\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    visit(visitor) { return visitor.visitDeclaration(this); }\n}\nfunction Declaration_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Declaration.prototype.attrs;\n}\nexport class Doctype {\n    /**\n     * @param {?} rootTag\n     * @param {?} dtd\n     */\n    constructor(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    visit(visitor) { return visitor.visitDoctype(this); }\n}\nfunction Doctype_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Doctype.prototype.rootTag;\n    /** @type {?} */\n    Doctype.prototype.dtd;\n}\nexport class Tag {\n    /**\n     * @param {?} name\n     * @param {?=} unescapedAttrs\n     * @param {?=} children\n     */\n    constructor(name, unescapedAttrs = {}, children = []) {\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    visit(visitor) { return visitor.visitTag(this); }\n}\nfunction Tag_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Tag.prototype.attrs;\n    /** @type {?} */\n    Tag.prototype.name;\n    /** @type {?} */\n    Tag.prototype.children;\n}\nexport class Text {\n    /**\n     * @param {?} unescapedValue\n     */\n    constructor(unescapedValue) { this.value = _escapeXml(unescapedValue); }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    visit(visitor) { return visitor.visitText(this); }\n}\nfunction Text_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Text.prototype.value;\n}\nexport class CR extends Text {\n    /**\n     * @param {?=} ws\n     */\n    constructor(ws = 0) { super(`\\n${new Array(ws + 1).join(' ')}`); }\n}\nconst /** @type {?} */ _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n/**\n * @param {?} text\n * @return {?}\n */\nfunction _escapeXml(text) {\n    return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\n//# sourceMappingURL=xml_helper.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ml from \"../../ml_parser/ast\";\nimport { XmlParser } from \"../../ml_parser/xml_parser\";\nimport { digest } from \"../digest\";\nimport * as i18n from \"../i18n_ast\";\nimport { I18nError } from \"../parse_util\";\nimport { Serializer } from \"./serializer\";\nimport * as xml from \"./xml_helper\";\nconst /** @type {?} */ _VERSION = '1.2';\nconst /** @type {?} */ _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst /** @type {?} */ _DEFAULT_SOURCE_LANG = 'en';\nconst /** @type {?} */ _PLACEHOLDER_TAG = 'x';\nconst /** @type {?} */ _FILE_TAG = 'file';\nconst /** @type {?} */ _SOURCE_TAG = 'source';\nconst /** @type {?} */ _TARGET_TAG = 'target';\nconst /** @type {?} */ _UNIT_TAG = 'trans-unit';\nconst /** @type {?} */ _CONTEXT_GROUP_TAG = 'context-group';\nconst /** @type {?} */ _CONTEXT_TAG = 'context';\nexport class Xliff extends Serializer {\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    write(messages, locale) {\n        const /** @type {?} */ visitor = new _WriteVisitor();\n        const /** @type {?} */ transUnits = [];\n        messages.forEach(message => {\n            let /** @type {?} */ contextTags = [];\n            message.sources.forEach((source) => {\n                let /** @type {?} */ contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new xml.CR(10), new xml.Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new xml.Text(source.filePath)]), new xml.CR(10), new xml.Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new xml.Text(`${source.startLine}`)]), new xml.CR(8));\n                contextTags.push(new xml.CR(8), contextGroupTag);\n            });\n            const /** @type {?} */ transUnit = new xml.Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            transUnit.children.push(new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), ...contextTags);\n            if (message.description) {\n                transUnit.children.push(new xml.CR(8), new xml.Tag('note', { priority: '1', from: 'description' }, [new xml.Text(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new xml.CR(8), new xml.Tag('note', { priority: '1', from: 'meaning' }, [new xml.Text(message.meaning)]));\n            }\n            transUnit.children.push(new xml.CR(6));\n            transUnits.push(new xml.CR(6), transUnit);\n        });\n        const /** @type {?} */ body = new xml.Tag('body', {}, [...transUnits, new xml.CR(4)]);\n        const /** @type {?} */ file = new xml.Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new xml.CR(4), body, new xml.CR(2)]);\n        const /** @type {?} */ xliff = new xml.Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new xml.CR(2), file, new xml.CR()]);\n        return xml.serialize([\n            new xml.Declaration({ version: '1.0', encoding: 'UTF-8' }), new xml.CR(), xliff, new xml.CR()\n        ]);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    load(content, url) {\n        // xliff to xml nodes\n        const /** @type {?} */ xliffParser = new XliffParser();\n        const { locale, msgIdToHtml, errors } = xliffParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const /** @type {?} */ i18nNodesByMsgId = {};\n        const /** @type {?} */ converter = new XmlToI18n();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId };\n    }\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    digest(message) { return digest(message); }\n}\nclass _WriteVisitor {\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { return [new xml.Text(text.value)]; }\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        const /** @type {?} */ nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        const /** @type {?} */ nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n        });\n        nodes.push(new xml.Text(`}`));\n        return nodes;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        const /** @type {?} */ ctype = getCtypeForTag(ph.tag);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [new xml.Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>` })];\n        }\n        const /** @type {?} */ startTagPh = new xml.Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>` });\n        const /** @type {?} */ closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>` });\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) {\n        return [new xml.Tag(_PLACEHOLDER_TAG, { id: ph.name, 'equiv-text': `{{${ph.value}}}` })];\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        const /** @type {?} */ equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`;\n        return [new xml.Tag(_PLACEHOLDER_TAG, { id: ph.name, 'equiv-text': equivText })];\n    }\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\nclass XliffParser {\n    constructor() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        ml.visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = /** @type {?} */ ((null));\n                const /** @type {?} */ idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        ml.visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                const /** @type {?} */ innerTextStart = /** @type {?} */ ((element.startSourceSpan)).end.offset;\n                const /** @type {?} */ innerTextEnd = /** @type {?} */ ((element.endSourceSpan)).start.offset;\n                const /** @type {?} */ content = /** @type {?} */ ((element.startSourceSpan)).start.file.content;\n                const /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                const /** @type {?} */ localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                ml.visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                ml.visitAll(this, element.children, null);\n        }\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(expansion, context) { }\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(expansionCase, context) { }\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    _addError(node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    }\n}\nfunction XliffParser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    XliffParser.prototype._unitMlString;\n    /** @type {?} */\n    XliffParser.prototype._errors;\n    /** @type {?} */\n    XliffParser.prototype._msgIdToHtml;\n    /** @type {?} */\n    XliffParser.prototype._locale;\n}\nclass XmlToI18n {\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    convert(message, url) {\n        const /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        const /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            ml.visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { return new i18n.Text(text.value, /** @type {?} */ ((text.sourceSpan))); }\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            const /** @type {?} */ nameAttr = el.attrs.find((attr) => attr.name === 'id');\n            if (nameAttr) {\n                return new i18n.Placeholder('', nameAttr.value, /** @type {?} */ ((el.sourceSpan)));\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n        }\n        else {\n            this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(icu, context) {\n        const /** @type {?} */ caseMap = {};\n        ml.visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n        });\n        return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: ml.visitAll(this, icuCase.expression),\n        };\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { }\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    _addError(node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    }\n}\nfunction XmlToI18n_tsickle_Closure_declarations() {\n    /** @type {?} */\n    XmlToI18n.prototype._errors;\n}\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return `x-${tag}`;\n    }\n}\n//# sourceMappingURL=xliff.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ml from \"../../ml_parser/ast\";\nimport { XmlParser } from \"../../ml_parser/xml_parser\";\nimport { decimalDigest } from \"../digest\";\nimport * as i18n from \"../i18n_ast\";\nimport { I18nError } from \"../parse_util\";\nimport { Serializer } from \"./serializer\";\nimport * as xml from \"./xml_helper\";\nconst /** @type {?} */ _VERSION = '2.0';\nconst /** @type {?} */ _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst /** @type {?} */ _DEFAULT_SOURCE_LANG = 'en';\nconst /** @type {?} */ _PLACEHOLDER_TAG = 'ph';\nconst /** @type {?} */ _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst /** @type {?} */ _XLIFF_TAG = 'xliff';\nconst /** @type {?} */ _SOURCE_TAG = 'source';\nconst /** @type {?} */ _TARGET_TAG = 'target';\nconst /** @type {?} */ _UNIT_TAG = 'unit';\nexport class Xliff2 extends Serializer {\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    write(messages, locale) {\n        const /** @type {?} */ visitor = new _WriteVisitor();\n        const /** @type {?} */ units = [];\n        messages.forEach(message => {\n            const /** @type {?} */ unit = new xml.Tag(_UNIT_TAG, { id: message.id });\n            const /** @type {?} */ notes = new xml.Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new xml.CR(8), new xml.Tag('note', { category: 'description' }, [new xml.Text(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new xml.CR(8), new xml.Tag('note', { category: 'meaning' }, [new xml.Text(message.meaning)]));\n                }\n            }\n            message.sources.forEach((source) => {\n                notes.children.push(new xml.CR(8), new xml.Tag('note', { category: 'location' }, [\n                    new xml.Text(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n                ]));\n            });\n            notes.children.push(new xml.CR(6));\n            unit.children.push(new xml.CR(6), notes);\n            const /** @type {?} */ segment = new xml.Tag('segment');\n            segment.children.push(new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new xml.CR(6));\n            unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n            units.push(new xml.CR(4), unit);\n        });\n        const /** @type {?} */ file = new xml.Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, [...units, new xml.CR(2)]);\n        const /** @type {?} */ xliff = new xml.Tag(_XLIFF_TAG, { version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG }, [new xml.CR(2), file, new xml.CR()]);\n        return xml.serialize([\n            new xml.Declaration({ version: '1.0', encoding: 'UTF-8' }), new xml.CR(), xliff, new xml.CR()\n        ]);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    load(content, url) {\n        // xliff to xml nodes\n        const /** @type {?} */ xliff2Parser = new Xliff2Parser();\n        const { locale, msgIdToHtml, errors } = xliff2Parser.parse(content, url);\n        // xml nodes to i18n nodes\n        const /** @type {?} */ i18nNodesByMsgId = {};\n        const /** @type {?} */ converter = new XmlToI18n();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId };\n    }\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    digest(message) { return decimalDigest(message); }\n}\nclass _WriteVisitor {\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { return [new xml.Text(text.value)]; }\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        const /** @type {?} */ nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        const /** @type {?} */ nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n        });\n        nodes.push(new xml.Text(`}`));\n        return nodes;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        const /** @type {?} */ type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            const /** @type {?} */ tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: `<${ph.tag}/>`,\n            });\n            return [tagPh];\n        }\n        const /** @type {?} */ tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: `<${ph.tag}>`,\n            dispEnd: `</${ph.tag}>`,\n        });\n        const /** @type {?} */ nodes = [].concat(...ph.children.map(node => node.visit(this)));\n        if (nodes.length) {\n            nodes.forEach((node) => tagPc.children.push(node));\n        }\n        else {\n            tagPc.children.push(new xml.Text(''));\n        }\n        return [tagPc];\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) {\n        const /** @type {?} */ idStr = (this._nextPlaceholderId++).toString();\n        return [new xml.Tag(_PLACEHOLDER_TAG, {\n                id: idStr,\n                equiv: ph.name,\n                disp: `{{${ph.value}}}`,\n            })];\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        const /** @type {?} */ cases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const /** @type {?} */ idStr = (this._nextPlaceholderId++).toString();\n        return [new xml.Tag(_PLACEHOLDER_TAG, { id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}` })];\n    }\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    serialize(nodes) {\n        this._nextPlaceholderId = 0;\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\nfunction _WriteVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _WriteVisitor.prototype._nextPlaceholderId;\n}\nclass Xliff2Parser {\n    constructor() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        ml.visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = null;\n                const /** @type {?} */ idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        ml.visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                const /** @type {?} */ innerTextStart = /** @type {?} */ ((element.startSourceSpan)).end.offset;\n                const /** @type {?} */ innerTextEnd = /** @type {?} */ ((element.endSourceSpan)).start.offset;\n                const /** @type {?} */ content = /** @type {?} */ ((element.startSourceSpan)).start.file.content;\n                const /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                const /** @type {?} */ localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                const /** @type {?} */ versionAttr = element.attrs.find((attr) => attr.name === 'version');\n                if (versionAttr) {\n                    const /** @type {?} */ version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n                    }\n                    else {\n                        ml.visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                ml.visitAll(this, element.children, null);\n        }\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(expansion, context) { }\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(expansionCase, context) { }\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction Xliff2Parser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Xliff2Parser.prototype._unitMlString;\n    /** @type {?} */\n    Xliff2Parser.prototype._errors;\n    /** @type {?} */\n    Xliff2Parser.prototype._msgIdToHtml;\n    /** @type {?} */\n    Xliff2Parser.prototype._locale;\n}\nclass XmlToI18n {\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    convert(message, url) {\n        const /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        const /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { return new i18n.Text(text.value, text.sourceSpan); }\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(el, context) {\n        switch (el.name) {\n            case _PLACEHOLDER_TAG:\n                const /** @type {?} */ nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n                if (nameAttr) {\n                    return [new i18n.Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                const /** @type {?} */ startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n                const /** @type {?} */ endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n                if (!startAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n                }\n                else if (!endAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n                }\n                else {\n                    const /** @type {?} */ startId = startAttr.value;\n                    const /** @type {?} */ endId = endAttr.value;\n                    const /** @type {?} */ nodes = [];\n                    return nodes.concat(new i18n.Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new i18n.Placeholder('', endId, el.sourceSpan));\n                }\n                break;\n            default:\n                this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(icu, context) {\n        const /** @type {?} */ caseMap = {};\n        ml.visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n        });\n        return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat(...ml.visitAll(this, icuCase.expression)),\n        };\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { }\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction XmlToI18n_tsickle_Closure_declarations() {\n    /** @type {?} */\n    XmlToI18n.prototype._errors;\n}\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n//# sourceMappingURL=xliff2.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { decimalDigest } from \"../digest\";\nimport { Serializer, SimplePlaceholderMapper } from \"./serializer\";\nimport * as xml from \"./xml_helper\";\nconst /** @type {?} */ _MESSAGES_TAG = 'messagebundle';\nconst /** @type {?} */ _MESSAGE_TAG = 'msg';\nconst /** @type {?} */ _PLACEHOLDER_TAG = 'ph';\nconst /** @type {?} */ _EXEMPLE_TAG = 'ex';\nconst /** @type {?} */ _SOURCE_TAG = 'source';\nconst /** @type {?} */ _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nexport class Xmb extends Serializer {\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    write(messages, locale) {\n        const /** @type {?} */ exampleVisitor = new ExampleVisitor();\n        const /** @type {?} */ visitor = new _Visitor();\n        let /** @type {?} */ rootNode = new xml.Tag(_MESSAGES_TAG);\n        messages.forEach(message => {\n            const /** @type {?} */ attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            let /** @type {?} */ sourceTags = [];\n            message.sources.forEach((source) => {\n                sourceTags.push(new xml.Tag(_SOURCE_TAG, {}, [\n                    new xml.Text(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n                ]));\n            });\n            rootNode.children.push(new xml.CR(2), new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n        });\n        rootNode.children.push(new xml.CR());\n        return xml.serialize([\n            new xml.Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new xml.CR(),\n            new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new xml.CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new xml.CR(),\n        ]);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    load(content, url) {\n        throw new Error('Unsupported');\n    }\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    digest(message) { return digest(message); }\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nclass _Visitor {\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { return [new xml.Text(text.value)]; }\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        const /** @type {?} */ nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        const /** @type {?} */ nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n        });\n        nodes.push(new xml.Text(`}`));\n        return nodes;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        const /** @type {?} */ startEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`<${ph.tag}>`)]);\n        const /** @type {?} */ startTagPh = new xml.Tag(_PLACEHOLDER_TAG, { name: ph.startName }, [startEx]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        const /** @type {?} */ closeEx = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`</${ph.tag}>`)]);\n        const /** @type {?} */ closeTagPh = new xml.Tag(_PLACEHOLDER_TAG, { name: ph.closeName }, [closeEx]);\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) {\n        const /** @type {?} */ exTag = new xml.Tag(_EXEMPLE_TAG, {}, [new xml.Text(`{{${ph.value}}}`)]);\n        return [new xml.Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag])];\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        const /** @type {?} */ exTag = new xml.Tag(_EXEMPLE_TAG, {}, [\n            new xml.Text(`{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`)\n        ]);\n        return [new xml.Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag])];\n    }\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n/**\n * @param {?} message\n * @return {?}\n */\nexport function digest(message) {\n    return decimalDigest(message);\n}\nclass ExampleVisitor {\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    addDefaultExamples(node) {\n        node.visit(this);\n        return node;\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    visitTag(tag) {\n        if (tag.name === _PLACEHOLDER_TAG) {\n            if (!tag.children || tag.children.length == 0) {\n                const /** @type {?} */ exText = new xml.Text(tag.attrs['name'] || '...');\n                tag.children = [new xml.Tag(_EXEMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(node => node.visit(this));\n        }\n    }\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    visitText(text) { }\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    visitDeclaration(decl) { }\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    visitDoctype(doctype) { }\n}\n/**\n * @param {?} internalName\n * @return {?}\n */\nexport function toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n//# sourceMappingURL=xmb.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ml from \"../../ml_parser/ast\";\nimport { XmlParser } from \"../../ml_parser/xml_parser\";\nimport * as i18n from \"../i18n_ast\";\nimport { I18nError } from \"../parse_util\";\nimport { Serializer, SimplePlaceholderMapper } from \"./serializer\";\nimport { digest, toPublicName } from \"./xmb\";\nconst /** @type {?} */ _TRANSLATIONS_TAG = 'translationbundle';\nconst /** @type {?} */ _TRANSLATION_TAG = 'translation';\nconst /** @type {?} */ _PLACEHOLDER_TAG = 'ph';\nexport class Xtb extends Serializer {\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    write(messages, locale) { throw new Error('Unsupported'); }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    load(content, url) {\n        // xtb to xml nodes\n        const /** @type {?} */ xtbParser = new XtbParser();\n        const { locale, msgIdToHtml, errors } = xtbParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const /** @type {?} */ i18nNodesByMsgId = {};\n        const /** @type {?} */ converter = new XmlToI18n();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const /** @type {?} */ valueFn = function () {\n                const { i18nNodes, errors } = converter.convert(msgIdToHtml[msgId], url);\n                if (errors.length) {\n                    throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId };\n    }\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    digest(message) { return digest(message); }\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\n/**\n * @param {?} messages\n * @param {?} id\n * @param {?} valueFn\n * @return {?}\n */\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            const /** @type {?} */ value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value });\n            return value;\n        },\n        set: _ => { throw new Error('Could not overwrite an XTB translation'); },\n    });\n}\nclass XtbParser {\n    constructor() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xtb\n     * @param {?} url\n     * @return {?}\n     */\n    parse(xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        const /** @type {?} */ xml = new XmlParser().parse(xtb, url, false);\n        this._errors = xml.errors;\n        ml.visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n                }\n                const /** @type {?} */ langAttr = element.attrs.find((attr) => attr.name === 'lang');\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                ml.visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                const /** @type {?} */ idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        const /** @type {?} */ innerTextStart = /** @type {?} */ ((element.startSourceSpan)).end.offset;\n                        const /** @type {?} */ innerTextEnd = /** @type {?} */ ((element.endSourceSpan)).start.offset;\n                        const /** @type {?} */ content = /** @type {?} */ ((element.startSourceSpan)).start.file.content;\n                        const /** @type {?} */ innerText = content.slice(/** @type {?} */ ((innerTextStart)), /** @type {?} */ ((innerTextEnd)));\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(expansion, context) { }\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(expansionCase, context) { }\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    _addError(node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    }\n}\nfunction XtbParser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    XtbParser.prototype._bundleDepth;\n    /** @type {?} */\n    XtbParser.prototype._errors;\n    /** @type {?} */\n    XtbParser.prototype._msgIdToHtml;\n    /** @type {?} */\n    XtbParser.prototype._locale;\n}\nclass XmlToI18n {\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    convert(message, url) {\n        const /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        const /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            ml.visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { return new i18n.Text(text.value, /** @type {?} */ ((text.sourceSpan))); }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(icu, context) {\n        const /** @type {?} */ caseMap = {};\n        ml.visitAll(this, icu.cases).forEach(c => {\n            caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n        });\n        return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: ml.visitAll(this, icuCase.expression),\n        };\n    }\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            const /** @type {?} */ nameAttr = el.attrs.find((attr) => attr.name === 'name');\n            if (nameAttr) {\n                return new i18n.Placeholder('', nameAttr.value, /** @type {?} */ ((el.sourceSpan)));\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n        }\n        else {\n            this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { }\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    _addError(node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    }\n}\nfunction XmlToI18n_tsickle_Closure_declarations() {\n    /** @type {?} */\n    XmlToI18n.prototype._errors;\n}\n//# sourceMappingURL=xtb.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { getHtmlTagDefinition } from \"./html_tags\";\nimport { DEFAULT_INTERPOLATION_CONFIG } from \"./interpolation_config\";\nimport { Parser } from \"./parser\";\nexport { ParseTreeResult, TreeError } from \"./parser\";\nexport class HtmlParser extends Parser {\n    constructor() { super(getHtmlTagDefinition); }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parse(source, url, parseExpansionForms = false, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        return super.parse(source, url, parseExpansionForms, interpolationConfig);\n    }\n}\n//# sourceMappingURL=html_parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { MissingTranslationStrategy } from \"../core\";\nimport { HtmlParser } from \"../ml_parser/html_parser\";\nimport { I18nError } from \"./parse_util\";\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} locale\n     * @param {?=} digest\n     * @param {?=} mapperFactory\n     * @param {?=} missingTranslationStrategy\n     * @param {?=} console\n     */\n    constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, /** @type {?} */ ((mapperFactory)), missingTranslationStrategy, console);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @param {?} serializer\n     * @param {?} missingTranslationStrategy\n     * @param {?=} console\n     * @return {?}\n     */\n    static load(content, url, serializer, missingTranslationStrategy, console) {\n        const { locale, i18nNodesByMsgId } = serializer.load(content, url);\n        const /** @type {?} */ digestFn = (m) => serializer.digest(m);\n        const /** @type {?} */ mapperFactory = (m) => /** @type {?} */ ((serializer.createNameMapper(m)));\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    get(srcMsg) {\n        const /** @type {?} */ html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    has(srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; }\n}\nfunction TranslationBundle_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TranslationBundle.prototype._i18nToHtml;\n    /** @type {?} */\n    TranslationBundle.prototype._i18nNodesByMsgId;\n    /** @type {?} */\n    TranslationBundle.prototype.digest;\n    /** @type {?} */\n    TranslationBundle.prototype.mapperFactory;\n}\nclass I18nToHtmlVisitor {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} _locale\n     * @param {?=} _digest\n     * @param {?=} _mapperFactory\n     * @param {?=} _missingTranslationStrategy\n     * @param {?=} _console\n     */\n    constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    convert(srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        const /** @type {?} */ text = this._convertToText(srcMsg);\n        // text to html\n        const /** @type {?} */ url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        const /** @type {?} */ html = new HtmlParser().parse(text, url, true);\n        return {\n            nodes: html.rootNodes,\n            errors: [...this._errors, ...html.errors],\n        };\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    visitText(text, context) { return text.value; }\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    visitContainer(container, context) {\n        return container.children.map(n => n.visit(this)).join('');\n    }\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcu(icu, context) {\n        const /** @type {?} */ cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        const /** @type {?} */ exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitPlaceholder(ph, context) {\n        const /** @type {?} */ phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n        return '';\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, context) {\n        const /** @type {?} */ tag = `${ph.tag}`;\n        const /** @type {?} */ attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n        if (ph.isVoid) {\n            return `<${tag} ${attrs}/>`;\n        }\n        const /** @type {?} */ children = ph.children.map((c) => c.visit(this)).join('');\n        return `<${tag} ${attrs}>${children}</${tag}>`;\n    }\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    }\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    _convertToText(srcMsg) {\n        const /** @type {?} */ id = this._digest(srcMsg);\n        const /** @type {?} */ mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        let /** @type {?} */ nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = (name) => mapper ? /** @type {?} */ ((mapper.toInternalName(name))) : name;\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n                const /** @type {?} */ ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n                const /** @type {?} */ ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = (name) => name;\n        }\n        const /** @type {?} */ text = nodes.map(node => node.visit(this)).join('');\n        const /** @type {?} */ context = /** @type {?} */ ((this._contextStack.pop()));\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    }\n    /**\n     * @param {?} el\n     * @param {?} msg\n     * @return {?}\n     */\n    _addError(el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    }\n}\nfunction I18nToHtmlVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._srcMsg;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._contextStack;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._errors;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._mapper;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._i18nNodesByMsgId;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._locale;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._digest;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._mapperFactory;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._missingTranslationStrategy;\n    /** @type {?} */\n    I18nToHtmlVisitor.prototype._console;\n}\n//# sourceMappingURL=translation_bundle.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { MissingTranslationStrategy } from \"../core\";\nimport { DEFAULT_INTERPOLATION_CONFIG } from \"../ml_parser/interpolation_config\";\nimport { ParseTreeResult } from \"../ml_parser/parser\";\nimport { digest } from \"./digest\";\nimport { mergeTranslations } from \"./extractor_merger\";\nimport { Xliff } from \"./serializers/xliff\";\nimport { Xliff2 } from \"./serializers/xliff2\";\nimport { Xmb } from \"./serializers/xmb\";\nimport { Xtb } from \"./serializers/xtb\";\nimport { TranslationBundle } from \"./translation_bundle\";\nexport class I18NHtmlParser {\n    /**\n     * @param {?} _htmlParser\n     * @param {?=} translations\n     * @param {?=} translationsFormat\n     * @param {?=} missingTranslation\n     * @param {?=} console\n     */\n    constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            const /** @type {?} */ serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest, undefined, missingTranslation, console);\n        }\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    parse(source, url, parseExpansionForms = false, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const /** @type {?} */ parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    }\n}\nfunction I18NHtmlParser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    I18NHtmlParser.prototype.getTagDefinition;\n    /** @type {?} */\n    I18NHtmlParser.prototype._translationBundle;\n    /** @type {?} */\n    I18NHtmlParser.prototype._htmlParser;\n}\n/**\n * @param {?=} format\n * @return {?}\n */\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n//# sourceMappingURL=i18n_html_parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst /** @type {?} */ STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nconst /** @type {?} */ GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\nconst /** @type {?} */ JIT_SUMMARY_FILE = /\\.ngsummary\\./;\nconst /** @type {?} */ JIT_SUMMARY_NAME = /NgSummary$/;\n/**\n * @param {?} filePath\n * @param {?=} forceSourceFile\n * @return {?}\n */\nexport function ngfactoryFilePath(filePath, forceSourceFile = false) {\n    const /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\n    return `${urlWithSuffix[0]}.ngfactory${urlWithSuffix[1]}`;\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nexport function stripGeneratedFileSuffix(filePath) {\n    return filePath.replace(GENERATED_FILE, '.');\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nexport function isGeneratedFile(filePath) {\n    return GENERATED_FILE.test(filePath);\n}\n/**\n * @param {?} path\n * @param {?=} forceSourceFile\n * @return {?}\n */\nexport function splitTypescriptSuffix(path, forceSourceFile = false) {\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\n    }\n    const /** @type {?} */ lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\n/**\n * @param {?} fileName\n * @return {?}\n */\nexport function summaryFileName(fileName) {\n    const /** @type {?} */ fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return `${fileNameWithoutSuffix}.ngsummary.json`;\n}\n/**\n * @param {?} fileName\n * @param {?=} forceSourceFile\n * @return {?}\n */\nexport function summaryForJitFileName(fileName, forceSourceFile = false) {\n    const /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\n    return `${urlWithSuffix[0]}.ngsummary${urlWithSuffix[1]}`;\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nexport function stripSummaryForJitFileSuffix(filePath) {\n    return filePath.replace(JIT_SUMMARY_FILE, '.');\n}\n/**\n * @param {?} symbolName\n * @return {?}\n */\nexport function summaryForJitName(symbolName) {\n    return `${symbolName}NgSummary`;\n}\n/**\n * @param {?} symbolName\n * @return {?}\n */\nexport function stripSummaryForJitNameSuffix(symbolName) {\n    return symbolName.replace(JIT_SUMMARY_NAME, '');\n}\nconst /** @type {?} */ LOWERED_SYMBOL = /\\u0275\\d+/;\n/**\n * @param {?} name\n * @return {?}\n */\nexport function isLoweredSymbol(name) {\n    return LOWERED_SYMBOL.test(name);\n}\n/**\n * @param {?} id\n * @return {?}\n */\nexport function createLoweredSymbol(id) {\n    return `\\u0275${id}`;\n}\n//# sourceMappingURL=util.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst /** @type {?} */ CORE = '@angular/core';\nexport class Identifiers {\n}\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleName: CORE,\n};\nIdentifiers.ElementRef = { name: 'ElementRef', moduleName: CORE };\nIdentifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE };\nIdentifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE };\nIdentifiers.ChangeDetectorRef = {\n    name: 'ChangeDetectorRef',\n    moduleName: CORE,\n};\nIdentifiers.QueryList = { name: 'QueryList', moduleName: CORE };\nIdentifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE };\nIdentifiers.CodegenComponentFactoryResolver = {\n    name: 'CodegenComponentFactoryResolver',\n    moduleName: CORE,\n};\nIdentifiers.ComponentFactoryResolver = {\n    name: 'ComponentFactoryResolver',\n    moduleName: CORE,\n};\nIdentifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE };\nIdentifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE };\nIdentifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE };\nIdentifiers.createModuleFactory = {\n    name: 'cmf',\n    moduleName: CORE,\n};\nIdentifiers.moduleDef = {\n    name: 'mod',\n    moduleName: CORE,\n};\nIdentifiers.moduleProviderDef = {\n    name: 'mpd',\n    moduleName: CORE,\n};\nIdentifiers.RegisterModuleFactoryFn = {\n    name: 'registerModuleFactory',\n    moduleName: CORE,\n};\nIdentifiers.Injector = { name: 'Injector', moduleName: CORE };\nIdentifiers.ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n};\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n};\nIdentifiers.SecurityContext = {\n    name: 'SecurityContext',\n    moduleName: CORE,\n};\nIdentifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE };\nIdentifiers.TRANSLATIONS_FORMAT = {\n    name: 'TRANSLATIONS_FORMAT',\n    moduleName: CORE,\n};\nIdentifiers.inlineInterpolate = {\n    name: 'inlineInterpolate',\n    moduleName: CORE,\n};\nIdentifiers.interpolate = { name: 'interpolate', moduleName: CORE };\nIdentifiers.EMPTY_ARRAY = { name: 'EMPTY_ARRAY', moduleName: CORE };\nIdentifiers.EMPTY_MAP = { name: 'EMPTY_MAP', moduleName: CORE };\nIdentifiers.Renderer = { name: 'Renderer', moduleName: CORE };\nIdentifiers.viewDef = { name: 'vid', moduleName: CORE };\nIdentifiers.elementDef = { name: 'eld', moduleName: CORE };\nIdentifiers.anchorDef = { name: 'and', moduleName: CORE };\nIdentifiers.textDef = { name: 'ted', moduleName: CORE };\nIdentifiers.directiveDef = { name: 'did', moduleName: CORE };\nIdentifiers.providerDef = { name: 'prd', moduleName: CORE };\nIdentifiers.queryDef = { name: 'qud', moduleName: CORE };\nIdentifiers.pureArrayDef = { name: 'pad', moduleName: CORE };\nIdentifiers.pureObjectDef = { name: 'pod', moduleName: CORE };\nIdentifiers.purePipeDef = { name: 'ppd', moduleName: CORE };\nIdentifiers.pipeDef = { name: 'pid', moduleName: CORE };\nIdentifiers.nodeValue = { name: 'nov', moduleName: CORE };\nIdentifiers.ngContentDef = { name: 'ncd', moduleName: CORE };\nIdentifiers.unwrapValue = { name: 'unv', moduleName: CORE };\nIdentifiers.createRendererType2 = { name: 'crt', moduleName: CORE };\n// type only\nIdentifiers.RendererType2 = {\n    name: 'RendererType2',\n    moduleName: CORE,\n};\n// type only\nIdentifiers.ViewDefinition = {\n    name: 'ViewDefinition',\n    moduleName: CORE,\n};\nIdentifiers.createComponentFactory = { name: 'ccf', moduleName: CORE };\nfunction Identifiers_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS;\n    /** @type {?} */\n    Identifiers.ElementRef;\n    /** @type {?} */\n    Identifiers.NgModuleRef;\n    /** @type {?} */\n    Identifiers.ViewContainerRef;\n    /** @type {?} */\n    Identifiers.ChangeDetectorRef;\n    /** @type {?} */\n    Identifiers.QueryList;\n    /** @type {?} */\n    Identifiers.TemplateRef;\n    /** @type {?} */\n    Identifiers.CodegenComponentFactoryResolver;\n    /** @type {?} */\n    Identifiers.ComponentFactoryResolver;\n    /** @type {?} */\n    Identifiers.ComponentFactory;\n    /** @type {?} */\n    Identifiers.ComponentRef;\n    /** @type {?} */\n    Identifiers.NgModuleFactory;\n    /** @type {?} */\n    Identifiers.createModuleFactory;\n    /** @type {?} */\n    Identifiers.moduleDef;\n    /** @type {?} */\n    Identifiers.moduleProviderDef;\n    /** @type {?} */\n    Identifiers.RegisterModuleFactoryFn;\n    /** @type {?} */\n    Identifiers.Injector;\n    /** @type {?} */\n    Identifiers.ViewEncapsulation;\n    /** @type {?} */\n    Identifiers.ChangeDetectionStrategy;\n    /** @type {?} */\n    Identifiers.SecurityContext;\n    /** @type {?} */\n    Identifiers.LOCALE_ID;\n    /** @type {?} */\n    Identifiers.TRANSLATIONS_FORMAT;\n    /** @type {?} */\n    Identifiers.inlineInterpolate;\n    /** @type {?} */\n    Identifiers.interpolate;\n    /** @type {?} */\n    Identifiers.EMPTY_ARRAY;\n    /** @type {?} */\n    Identifiers.EMPTY_MAP;\n    /** @type {?} */\n    Identifiers.Renderer;\n    /** @type {?} */\n    Identifiers.viewDef;\n    /** @type {?} */\n    Identifiers.elementDef;\n    /** @type {?} */\n    Identifiers.anchorDef;\n    /** @type {?} */\n    Identifiers.textDef;\n    /** @type {?} */\n    Identifiers.directiveDef;\n    /** @type {?} */\n    Identifiers.providerDef;\n    /** @type {?} */\n    Identifiers.queryDef;\n    /** @type {?} */\n    Identifiers.pureArrayDef;\n    /** @type {?} */\n    Identifiers.pureObjectDef;\n    /** @type {?} */\n    Identifiers.purePipeDef;\n    /** @type {?} */\n    Identifiers.pipeDef;\n    /** @type {?} */\n    Identifiers.nodeValue;\n    /** @type {?} */\n    Identifiers.ngContentDef;\n    /** @type {?} */\n    Identifiers.unwrapValue;\n    /** @type {?} */\n    Identifiers.createRendererType2;\n    /** @type {?} */\n    Identifiers.RendererType2;\n    /** @type {?} */\n    Identifiers.ViewDefinition;\n    /** @type {?} */\n    Identifiers.createComponentFactory;\n}\n/**\n * @param {?} reference\n * @return {?}\n */\nexport function createTokenForReference(reference) {\n    return { identifier: { reference: reference } };\n}\n/**\n * @param {?} reflector\n * @param {?} reference\n * @return {?}\n */\nexport function createTokenForExternalReference(reflector, reference) {\n    return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n//# sourceMappingURL=identifiers.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {number} */\nconst LifecycleHooks = {\n    OnInit: 0,\n    OnDestroy: 1,\n    DoCheck: 2,\n    OnChanges: 3,\n    AfterContentInit: 4,\n    AfterContentChecked: 5,\n    AfterViewInit: 6,\n    AfterViewChecked: 7,\n};\nexport { LifecycleHooks };\nLifecycleHooks[LifecycleHooks.OnInit] = \"OnInit\";\nLifecycleHooks[LifecycleHooks.OnDestroy] = \"OnDestroy\";\nLifecycleHooks[LifecycleHooks.DoCheck] = \"DoCheck\";\nLifecycleHooks[LifecycleHooks.OnChanges] = \"OnChanges\";\nLifecycleHooks[LifecycleHooks.AfterContentInit] = \"AfterContentInit\";\nLifecycleHooks[LifecycleHooks.AfterContentChecked] = \"AfterContentChecked\";\nLifecycleHooks[LifecycleHooks.AfterViewInit] = \"AfterViewInit\";\nLifecycleHooks[LifecycleHooks.AfterViewChecked] = \"AfterViewChecked\";\nexport const /** @type {?} */ LIFECYCLE_HOOKS_VALUES = [\n    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n    LifecycleHooks.AfterViewChecked\n];\n/**\n * @param {?} reflector\n * @param {?} hook\n * @param {?} token\n * @return {?}\n */\nexport function hasLifecycleHook(reflector, hook, token) {\n    return reflector.hasLifecycleHook(token, getHookName(hook));\n}\n/**\n * @param {?} reflector\n * @param {?} token\n * @return {?}\n */\nexport function getAllLifecycleHooks(reflector, token) {\n    return LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(reflector, hook, token));\n}\n/**\n * @param {?} hook\n * @return {?}\n */\nfunction getHookName(hook) {\n    switch (hook) {\n        case LifecycleHooks.OnInit:\n            return 'ngOnInit';\n        case LifecycleHooks.OnDestroy:\n            return 'ngOnDestroy';\n        case LifecycleHooks.DoCheck:\n            return 'ngDoCheck';\n        case LifecycleHooks.OnChanges:\n            return 'ngOnChanges';\n        case LifecycleHooks.AfterContentInit:\n            return 'ngAfterContentInit';\n        case LifecycleHooks.AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case LifecycleHooks.AfterViewInit:\n            return 'ngAfterViewInit';\n        case LifecycleHooks.AfterViewChecked:\n            return 'ngAfterViewChecked';\n    }\n}\n//# sourceMappingURL=lifecycle_reflector.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { getHtmlTagDefinition } from \"./ml_parser/html_tags\";\nconst /** @type {?} */ _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' +\n    '([-\\\\w]+)|' +\n    '(?:\\\\.([-\\\\w]+))|' +\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +\n    '(\\\\))|' +\n    '(\\\\s*,\\\\s*)', // \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n    constructor() {\n        this.element = null;\n        this.classNames = [];\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    static parse(selector) {\n        const /** @type {?} */ results = [];\n        const /** @type {?} */ _addResult = (res, cssSel) => {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        let /** @type {?} */ cssSelector = new CssSelector();\n        let /** @type {?} */ match;\n        let /** @type {?} */ current = cssSelector;\n        let /** @type {?} */ inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1]) {\n                if (inNot) {\n                    throw new Error('Nesting :not is not allowed in a selector');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            if (match[2]) {\n                current.setElement(match[2]);\n            }\n            if (match[3]) {\n                current.addClassName(match[3]);\n            }\n            if (match[4]) {\n                current.addAttribute(match[4], match[6]);\n            }\n            if (match[7]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    }\n    /**\n     * @return {?}\n     */\n    isElementSelector() {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    }\n    /**\n     * @return {?}\n     */\n    hasElementSelector() { return !!this.element; }\n    /**\n     * @param {?=} element\n     * @return {?}\n     */\n    setElement(element = null) { this.element = element; }\n    /**\n     * Gets a template string for an element that matches the selector.\n     * @return {?}\n     */\n    getMatchingElementTemplate() {\n        const /** @type {?} */ tagName = this.element || 'div';\n        const /** @type {?} */ classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n        let /** @type {?} */ attrs = '';\n        for (let /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n            const /** @type {?} */ attrName = this.attrs[i];\n            const /** @type {?} */ attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n            attrs += ` ${attrName}${attrValue}`;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n            `<${tagName}${classAttr}${attrs}></${tagName}>`;\n    }\n    /**\n     * @param {?} name\n     * @param {?=} value\n     * @return {?}\n     */\n    addAttribute(name, value = '') {\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    addClassName(name) { this.classNames.push(name.toLowerCase()); }\n    /**\n     * @return {?}\n     */\n    toString() {\n        let /** @type {?} */ res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(klass => res += `.${klass}`);\n        }\n        if (this.attrs) {\n            for (let /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n                const /** @type {?} */ name = this.attrs[i];\n                const /** @type {?} */ value = this.attrs[i + 1];\n                res += `[${name}${value ? '=' + value : ''}]`;\n            }\n        }\n        this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n        return res;\n    }\n}\nfunction CssSelector_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CssSelector.prototype.element;\n    /** @type {?} */\n    CssSelector.prototype.classNames;\n    /** @type {?} */\n    CssSelector.prototype.attrs;\n    /** @type {?} */\n    CssSelector.prototype.notSelectors;\n}\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher {\n    constructor() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    /**\n     * @param {?} notSelectors\n     * @return {?}\n     */\n    static createNotMatcher(notSelectors) {\n        const /** @type {?} */ notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    }\n    /**\n     * @param {?} cssSelectors\n     * @param {?=} callbackCtxt\n     * @return {?}\n     */\n    addSelectables(cssSelectors, callbackCtxt) {\n        let /** @type {?} */ listContext = /** @type {?} */ ((null));\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (let /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    }\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param {?} cssSelector A css selector\n     * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n     * @param {?} listContext\n     * @return {?}\n     */\n    _addSelectable(cssSelector, callbackCtxt, listContext) {\n        let /** @type {?} */ matcher = this;\n        const /** @type {?} */ element = cssSelector.element;\n        const /** @type {?} */ classNames = cssSelector.classNames;\n        const /** @type {?} */ attrs = cssSelector.attrs;\n        const /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            const /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n                const /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                const /** @type {?} */ className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                const /** @type {?} */ isTerminal = i === attrs.length - 2;\n                const /** @type {?} */ name = attrs[i];\n                const /** @type {?} */ value = attrs[i + 1];\n                if (isTerminal) {\n                    const /** @type {?} */ terminalMap = matcher._attrValueMap;\n                    let /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    const /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n                    let /** @type {?} */ partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    }\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @param {?} selectable\n     * @return {?}\n     */\n    _addTerminal(map, name, selectable) {\n        let /** @type {?} */ terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    }\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @return {?}\n     */\n    _addPartial(map, name) {\n        let /** @type {?} */ matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    }\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param {?} cssSelector A css selector\n     * @param {?} matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return {?} boolean true if a match was found\n     */\n    match(cssSelector, matchedCallback) {\n        let /** @type {?} */ result = false;\n        const /** @type {?} */ element = /** @type {?} */ ((cssSelector.element));\n        const /** @type {?} */ classNames = cssSelector.classNames;\n        const /** @type {?} */ attrs = cssSelector.attrs;\n        for (let /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (let /** @type {?} */ i = 0; i < classNames.length; i++) {\n                const /** @type {?} */ className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (let /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                const /** @type {?} */ name = attrs[i];\n                const /** @type {?} */ value = attrs[i + 1];\n                const /** @type {?} */ terminalValuesMap = /** @type {?} */ ((this._attrValueMap.get(name)));\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                const /** @type {?} */ partialValuesMap = /** @type {?} */ ((this._attrValuePartialMap.get(name)));\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    }\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    _matchTerminal(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        let /** @type {?} */ selectables = map.get(name) || [];\n        const /** @type {?} */ starSelectables = /** @type {?} */ ((map.get('*')));\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        let /** @type {?} */ selectable;\n        let /** @type {?} */ result = false;\n        for (let /** @type {?} */ i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    }\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    _matchPartial(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        const /** @type {?} */ nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    }\n}\nfunction SelectorMatcher_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SelectorMatcher.prototype._elementMap;\n    /** @type {?} */\n    SelectorMatcher.prototype._elementPartialMap;\n    /** @type {?} */\n    SelectorMatcher.prototype._classMap;\n    /** @type {?} */\n    SelectorMatcher.prototype._classPartialMap;\n    /** @type {?} */\n    SelectorMatcher.prototype._attrValueMap;\n    /** @type {?} */\n    SelectorMatcher.prototype._attrValuePartialMap;\n    /** @type {?} */\n    SelectorMatcher.prototype._listContexts;\n}\nexport class SelectorListContext {\n    /**\n     * @param {?} selectors\n     */\n    constructor(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n}\nfunction SelectorListContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SelectorListContext.prototype.alreadyMatched;\n    /** @type {?} */\n    SelectorListContext.prototype.selectors;\n}\nexport class SelectorContext {\n    /**\n     * @param {?} selector\n     * @param {?} cbContext\n     * @param {?} listContext\n     */\n    constructor(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    /**\n     * @param {?} cssSelector\n     * @param {?} callback\n     * @return {?}\n     */\n    finalize(cssSelector, callback) {\n        let /** @type {?} */ result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            const /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    }\n}\nfunction SelectorContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SelectorContext.prototype.notSelectors;\n    /** @type {?} */\n    SelectorContext.prototype.selector;\n    /** @type {?} */\n    SelectorContext.prototype.cbContext;\n    /** @type {?} */\n    SelectorContext.prototype.listContext;\n}\n//# sourceMappingURL=selector.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { StaticSymbol } from \"./aot/static_symbol\";\nimport { ngfactoryFilePath } from \"./aot/util\";\nimport { assertArrayOfStrings, assertInterpolationSymbols } from \"./assertions\";\nimport * as cpl from \"./compile_metadata\";\nimport { ChangeDetectionStrategy, Type, ViewEncapsulation, createAttribute, createComponent, createHost, createInject, createInjectable, createInjectionToken, createOptional, createSelf, createSkipSelf } from \"./core\";\nimport { Identifiers } from \"./identifiers\";\nimport { getAllLifecycleHooks } from \"./lifecycle_reflector\";\nimport { CssSelector } from \"./selector\";\nimport { SyncAsync, ValueTransformer, isPromise, noUndefined, resolveForwardRef, stringify, syntaxError, visitValue } from \"./util\";\nexport const /** @type {?} */ ERROR_COMPONENT_TYPE = 'ngComponentType';\nexport class CompileMetadataResolver {\n    /**\n     * @param {?} _config\n     * @param {?} _htmlParser\n     * @param {?} _ngModuleResolver\n     * @param {?} _directiveResolver\n     * @param {?} _pipeResolver\n     * @param {?} _summaryResolver\n     * @param {?} _schemaRegistry\n     * @param {?} _directiveNormalizer\n     * @param {?} _console\n     * @param {?} _staticSymbolCache\n     * @param {?} _reflector\n     * @param {?=} _errorCollector\n     */\n    constructor(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        this._config = _config;\n        this._htmlParser = _htmlParser;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    getReflector() { return this._reflector; }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    clearCacheFor(type) {\n        const /** @type {?} */ dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    clearCache() {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    }\n    /**\n     * @param {?} baseType\n     * @param {?} name\n     * @return {?}\n     */\n    _createProxyClass(baseType, name) {\n        let /** @type {?} */ delegate = null;\n        const /** @type {?} */ proxyClass = /** @type {?} */ (function () {\n            if (!delegate) {\n                throw new Error(`Illegal state: Class ${name} for type ${stringify(baseType)} is not compiled yet!`);\n            }\n            return delegate.apply(this, arguments);\n        });\n        proxyClass.setDelegate = (d) => {\n            delegate = d;\n            (/** @type {?} */ (proxyClass)).prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        (/** @type {?} */ (proxyClass)).overriddenName = name;\n        return proxyClass;\n    }\n    /**\n     * @param {?} dirType\n     * @param {?} name\n     * @return {?}\n     */\n    getGeneratedClass(dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    }\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    getComponentViewClass(dirType) {\n        return this.getGeneratedClass(dirType, cpl.viewClassName(dirType, 0));\n    }\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    getHostComponentViewClass(dirType) {\n        return this.getGeneratedClass(dirType, cpl.hostViewClassName(dirType));\n    }\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    getHostComponentType(dirType) {\n        const /** @type {?} */ name = `${cpl.identifierName({ reference: dirType })}_Host`;\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        else {\n            const /** @type {?} */ HostClass = /** @type {?} */ (function HostClass() { });\n            HostClass.overriddenName = name;\n            return HostClass;\n        }\n    }\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    getRendererType(dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), cpl.rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return /** @type {?} */ ({});\n        }\n    }\n    /**\n     * @param {?} selector\n     * @param {?} dirType\n     * @param {?} inputs\n     * @param {?} outputs\n     * @return {?}\n     */\n    getComponentFactory(selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), cpl.componentFactoryName(dirType));\n        }\n        else {\n            const /** @type {?} */ hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            const /** @type {?} */ createComponentFactory = this._reflector.resolveExternalReference(Identifiers.createComponentFactory);\n            return createComponentFactory(selector, dirType, /** @type {?} */ (hostView), inputs, outputs, []);\n        }\n    }\n    /**\n     * @param {?} factory\n     * @param {?} ngContentSelectors\n     * @return {?}\n     */\n    initComponentFactory(factory, ngContentSelectors) {\n        if (!(factory instanceof StaticSymbol)) {\n            (/** @type {?} */ (factory)).ngContentSelectors.push(...ngContentSelectors);\n        }\n    }\n    /**\n     * @param {?} type\n     * @param {?} kind\n     * @return {?}\n     */\n    _loadSummary(type, kind) {\n        let /** @type {?} */ typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            const /** @type {?} */ summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary || null);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    }\n    /**\n     * @param {?} compMeta\n     * @param {?=} hostViewType\n     * @return {?}\n     */\n    getHostComponentMetadata(compMeta, hostViewType) {\n        const /** @type {?} */ hostType = this.getHostComponentType(compMeta.type.reference);\n        if (!hostViewType) {\n            hostViewType = this.getHostComponentViewClass(hostType);\n        }\n        // Note: ! is ok here as this method should only be called with normalized directive\n        // metadata, which always fills in the selector.\n        const /** @type {?} */ template = CssSelector.parse(/** @type {?} */ ((compMeta.selector)))[0].getMatchingElementTemplate();\n        const /** @type {?} */ templateUrl = '';\n        const /** @type {?} */ htmlAst = this._htmlParser.parse(template, templateUrl);\n        return cpl.CompileDirectiveMetadata.create({\n            isHost: true,\n            type: { reference: hostType, diDeps: [], lifecycleHooks: [] },\n            template: new cpl.CompileTemplateMetadata({\n                encapsulation: ViewEncapsulation.None,\n                template,\n                templateUrl,\n                htmlAst,\n                styles: [],\n                styleUrls: [],\n                ngContentSelectors: [],\n                animations: [],\n                isInline: true,\n                externalStylesheets: [],\n                interpolation: null,\n                preserveWhitespaces: false,\n            }),\n            exportAs: null,\n            changeDetection: ChangeDetectionStrategy.Default,\n            inputs: [],\n            outputs: [],\n            host: {},\n            isComponent: true,\n            selector: '*',\n            providers: [],\n            viewProviders: [],\n            queries: [],\n            viewQueries: [],\n            componentViewType: hostViewType,\n            rendererType: /** @type {?} */ ({ id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {} }),\n            entryComponents: [],\n            componentFactory: null\n        });\n    }\n    /**\n     * @param {?} ngModuleType\n     * @param {?} directiveType\n     * @param {?} isSync\n     * @return {?}\n     */\n    loadDirectiveMetadata(ngModuleType, directiveType, isSync) {\n        if (this._directiveCache.has(directiveType)) {\n            return null;\n        }\n        directiveType = resolveForwardRef(directiveType);\n        const { annotation, metadata } = /** @type {?} */ ((this.getNonNormalizedDirectiveMetadata(directiveType)));\n        const /** @type {?} */ createDirectiveMetadata = (templateMetadata) => {\n            const /** @type {?} */ normalizedDirMeta = new cpl.CompileDirectiveMetadata({\n                isHost: false,\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                this.initComponentFactory(/** @type {?} */ ((metadata.componentFactory)), templateMetadata.ngContentSelectors);\n            }\n            this._directiveCache.set(directiveType, normalizedDirMeta);\n            this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return null;\n        };\n        if (metadata.isComponent) {\n            const /** @type {?} */ template = /** @type {?} */ ((metadata.template));\n            const /** @type {?} */ templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType,\n                componentType: directiveType,\n                moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n                encapsulation: template.encapsulation,\n                template: template.template,\n                templateUrl: template.templateUrl,\n                styles: template.styles,\n                styleUrls: template.styleUrls,\n                animations: template.animations,\n                interpolation: template.interpolation,\n                preserveWhitespaces: template.preserveWhitespaces\n            });\n            if (isPromise(templateMeta) && isSync) {\n                this._reportError(componentStillLoadingError(directiveType), directiveType);\n                return null;\n            }\n            return SyncAsync.then(templateMeta, createDirectiveMetadata);\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    }\n    /**\n     * @param {?} directiveType\n     * @return {?}\n     */\n    getNonNormalizedDirectiveMetadata(directiveType) {\n        directiveType = resolveForwardRef(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        let /** @type {?} */ cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        const /** @type {?} */ dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        let /** @type {?} */ nonNormalizedTemplateMetadata = /** @type {?} */ ((undefined));\n        if (createComponent.isTypeOf(dirMeta)) {\n            // component\n            const /** @type {?} */ compMeta = /** @type {?} */ (dirMeta);\n            assertArrayOfStrings('styles', compMeta.styles);\n            assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', compMeta.interpolation);\n            const /** @type {?} */ animations = compMeta.animations;\n            nonNormalizedTemplateMetadata = new cpl.CompileTemplateMetadata({\n                encapsulation: noUndefined(compMeta.encapsulation),\n                template: noUndefined(compMeta.template),\n                templateUrl: noUndefined(compMeta.templateUrl),\n                htmlAst: null,\n                styles: compMeta.styles || [],\n                styleUrls: compMeta.styleUrls || [],\n                animations: animations || [],\n                interpolation: noUndefined(compMeta.interpolation),\n                isInline: !!compMeta.template,\n                externalStylesheets: [],\n                ngContentSelectors: [],\n                preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),\n            });\n        }\n        let /** @type {?} */ changeDetectionStrategy = /** @type {?} */ ((null));\n        let /** @type {?} */ viewProviders = [];\n        let /** @type {?} */ entryComponentMetadata = [];\n        let /** @type {?} */ selector = dirMeta.selector;\n        if (createComponent.isTypeOf(dirMeta)) {\n            // Component\n            const /** @type {?} */ compMeta = /** @type {?} */ (dirMeta);\n            changeDetectionStrategy = /** @type {?} */ ((compMeta.changeDetection));\n            if (compMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, `viewProviders for \"${stringifyType(directiveType)}\"`, [], directiveType);\n            }\n            if (compMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)\n                    .map((type) => /** @type {?} */ ((this._getEntryComponentMetadata(type))))\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                this._reportError(syntaxError(`Directive ${stringifyType(directiveType)} has no selector, please add it!`), directiveType);\n                selector = 'error';\n            }\n        }\n        let /** @type {?} */ providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, `providers for \"${stringifyType(directiveType)}\"`, [], directiveType);\n        }\n        let /** @type {?} */ queries = [];\n        let /** @type {?} */ viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        const /** @type {?} */ metadata = cpl.CompileDirectiveMetadata.create({\n            isHost: false,\n            selector: selector,\n            exportAs: noUndefined(dirMeta.exportAs),\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs || [],\n            outputs: dirMeta.outputs || [],\n            host: dirMeta.host || {},\n            providers: providers || [],\n            viewProviders: viewProviders || [],\n            queries: queries || [],\n            viewQueries: viewQueries || [],\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                null,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n            componentFactory: null\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    }\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} directiveType\n     * @return {?}\n     */\n    getDirectiveMetadata(directiveType) {\n        const /** @type {?} */ dirMeta = /** @type {?} */ ((this._directiveCache.get(directiveType)));\n        if (!dirMeta) {\n            this._reportError(syntaxError(`Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${stringifyType(directiveType)}.`), directiveType);\n        }\n        return dirMeta;\n    }\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    getDirectiveSummary(dirType) {\n        const /** @type {?} */ dirSummary = /** @type {?} */ (this._loadSummary(dirType, cpl.CompileSummaryKind.Directive));\n        if (!dirSummary) {\n            this._reportError(syntaxError(`Illegal state: Could not load the summary for directive ${stringifyType(dirType)}.`), dirType);\n        }\n        return dirSummary;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isDirective(type) {\n        return !!this._loadSummary(type, cpl.CompileSummaryKind.Directive) ||\n            this._directiveResolver.isDirective(type);\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isPipe(type) {\n        return !!this._loadSummary(type, cpl.CompileSummaryKind.Pipe) ||\n            this._pipeResolver.isPipe(type);\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isNgModule(type) {\n        return !!this._loadSummary(type, cpl.CompileSummaryKind.NgModule) ||\n            this._ngModuleResolver.isNgModule(type);\n    }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    getNgModuleSummary(moduleType) {\n        let /** @type {?} */ moduleSummary = /** @type {?} */ (this._loadSummary(moduleType, cpl.CompileSummaryKind.NgModule));\n        if (!moduleSummary) {\n            const /** @type {?} */ moduleMeta = this.getNgModuleMetadata(moduleType, false);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    }\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    loadNgModuleDirectiveAndPipeMetadata(moduleType, isSync, throwIfNotFound = true) {\n        const /** @type {?} */ ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        const /** @type {?} */ loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach((id) => {\n                const /** @type {?} */ promise = this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach((id) => this._loadPipeMetadata(id.reference));\n        }\n        return Promise.all(loading);\n    }\n    /**\n     * @param {?} moduleType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    getNgModuleMetadata(moduleType, throwIfNotFound = true) {\n        moduleType = resolveForwardRef(moduleType);\n        let /** @type {?} */ compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        const /** @type {?} */ meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        const /** @type {?} */ declaredDirectives = [];\n        const /** @type {?} */ exportedNonModuleIdentifiers = [];\n        const /** @type {?} */ declaredPipes = [];\n        const /** @type {?} */ importedModules = [];\n        const /** @type {?} */ exportedModules = [];\n        const /** @type {?} */ providers = [];\n        const /** @type {?} */ entryComponents = [];\n        const /** @type {?} */ bootstrapComponents = [];\n        const /** @type {?} */ schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach((importedType) => {\n                let /** @type {?} */ importedModuleType = /** @type {?} */ ((undefined));\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    const /** @type {?} */ moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push(...this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, `provider for the NgModule '${stringifyType(importedModuleType)}'`, [], importedType));\n                    }\n                }\n                if (importedModuleType) {\n                    if (this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    const /** @type {?} */ importedModuleSummary = this.getNgModuleSummary(importedModuleType);\n                    if (!importedModuleSummary) {\n                        this._reportError(syntaxError(`Unexpected ${this._getTypeDescriptor(importedType)} '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'. Please add a @NgModule annotation.`), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'`), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach((exportedType) => {\n                if (!isValidType(exportedType)) {\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(exportedType)}' exported by the module '${stringifyType(moduleType)}'`), moduleType);\n                    return;\n                }\n                const /** @type {?} */ exportedModuleSummary = this.getNgModuleSummary(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        const /** @type {?} */ transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach((declaredType) => {\n                if (!isValidType(declaredType)) {\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'`), moduleType);\n                    return;\n                }\n                const /** @type {?} */ declaredIdentifier = this._getIdentifierMetadata(declaredType);\n                if (this.isDirective(declaredType)) {\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (this.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    this._reportError(syntaxError(`Unexpected ${this._getTypeDescriptor(declaredType)} '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`), moduleType);\n                    return;\n                }\n            });\n        }\n        const /** @type {?} */ exportedDirectives = [];\n        const /** @type {?} */ exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach((exportedId) => {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                this._reportError(syntaxError(`Can't export ${this._getTypeDescriptor(exportedId.reference)} ${stringifyType(exportedId.reference)} from ${stringifyType(moduleType)} as it was neither declared nor imported!`), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push(...this._getProvidersMetadata(meta.providers, entryComponents, `provider for the NgModule '${stringifyType(moduleType)}'`, [], moduleType));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push(...flattenAndDedupeArray(meta.entryComponents)\n                .map(type => /** @type {?} */ ((this._getEntryComponentMetadata(type)))));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(type => {\n                if (!isValidType(type)) {\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(type)}' used in the bootstrap property of module '${stringifyType(moduleType)}'`), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push(...bootstrapComponents.map(type => /** @type {?} */ ((this._getEntryComponentMetadata(type.reference)))));\n        if (meta.schemas) {\n            schemas.push(...flattenAndDedupeArray(meta.schemas));\n        }\n        compileMeta = new cpl.CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers,\n            entryComponents,\n            bootstrapComponents,\n            schemas,\n            declaredDirectives,\n            exportedDirectives,\n            declaredPipes,\n            exportedPipes,\n            importedModules,\n            exportedModules,\n            transitiveModule,\n            id: meta.id || null,\n        });\n        entryComponents.forEach((id) => transitiveModule.addEntryComponent(id));\n        providers.forEach((provider) => transitiveModule.addProvider(provider, /** @type {?} */ ((compileMeta)).type));\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    }\n    /**\n     * @param {?} moduleType\n     * @param {?} importedModuleType\n     * @return {?}\n     */\n    _checkSelfImport(moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(`'${stringifyType(moduleType)}' module can't import itself`), moduleType);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _getTypeDescriptor(type) {\n        if (isValidType(type)) {\n            if (this.isDirective(type)) {\n                return 'directive';\n            }\n            if (this.isPipe(type)) {\n                return 'pipe';\n            }\n            if (this.isNgModule(type)) {\n                return 'module';\n            }\n        }\n        if ((/** @type {?} */ (type)).provide) {\n            return 'provider';\n        }\n        return 'value';\n    }\n    /**\n     * @param {?} type\n     * @param {?} moduleType\n     * @return {?}\n     */\n    _addTypeToModule(type, moduleType) {\n        const /** @type {?} */ oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(`Type ${stringifyType(type)} is part of the declarations of 2 modules: ${stringifyType(oldModule)} and ${stringifyType(moduleType)}! ` +\n                `Please consider moving ${stringifyType(type)} to a higher module that imports ${stringifyType(oldModule)} and ${stringifyType(moduleType)}. ` +\n                `You can also create a new NgModule that exports and includes ${stringifyType(type)} then import that NgModule in ${stringifyType(oldModule)} and ${stringifyType(moduleType)}.`), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    }\n    /**\n     * @param {?} importedModules\n     * @param {?} exportedModules\n     * @return {?}\n     */\n    _getTransitiveNgModuleMetadata(importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        const /** @type {?} */ result = new cpl.TransitiveCompileNgModuleMetadata();\n        const /** @type {?} */ modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach((modSummary) => {\n            modSummary.modules.forEach((mod) => result.addModule(mod));\n            modSummary.entryComponents.forEach((comp) => result.addEntryComponent(comp));\n            const /** @type {?} */ addedTokens = new Set();\n            modSummary.providers.forEach((entry) => {\n                const /** @type {?} */ tokenRef = cpl.tokenReference(entry.provider.token);\n                let /** @type {?} */ prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                const /** @type {?} */ moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach((modSummary) => {\n            modSummary.exportedDirectives.forEach((id) => result.addExportedDirective(id));\n            modSummary.exportedPipes.forEach((id) => result.addExportedPipe(id));\n        });\n        importedModules.forEach((modSummary) => {\n            modSummary.exportedDirectives.forEach((id) => result.addDirective(id));\n            modSummary.exportedPipes.forEach((id) => result.addPipe(id));\n        });\n        return result;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _getIdentifierMetadata(type) {\n        type = resolveForwardRef(type);\n        return { reference: type };\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isInjectable(type) {\n        const /** @type {?} */ annotations = this._reflector.annotations(type);\n        return annotations.some(ann => createInjectable.isTypeOf(ann));\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    getInjectableSummary(type) {\n        return {\n            summaryKind: cpl.CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    }\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    _getInjectableMetadata(type, dependencies = null) {\n        const /** @type {?} */ typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    }\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    _getTypeMetadata(type, dependencies = null, throwOnUnknownDeps = true) {\n        const /** @type {?} */ identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\n        };\n    }\n    /**\n     * @param {?} factory\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    _getFactoryMetadata(factory, dependencies = null) {\n        factory = resolveForwardRef(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    }\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} pipeType\n     * @return {?}\n     */\n    getPipeMetadata(pipeType) {\n        const /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(`Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${stringifyType(pipeType)}.`), pipeType);\n        }\n        return pipeMeta || null;\n    }\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    getPipeSummary(pipeType) {\n        const /** @type {?} */ pipeSummary = /** @type {?} */ (this._loadSummary(pipeType, cpl.CompileSummaryKind.Pipe));\n        if (!pipeSummary) {\n            this._reportError(syntaxError(`Illegal state: Could not load the summary for pipe ${stringifyType(pipeType)}.`), pipeType);\n        }\n        return pipeSummary;\n    }\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    getOrLoadPipeMetadata(pipeType) {\n        let /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    }\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    _loadPipeMetadata(pipeType) {\n        pipeType = resolveForwardRef(pipeType);\n        const /** @type {?} */ pipeAnnotation = /** @type {?} */ ((this._pipeResolver.resolve(pipeType)));\n        const /** @type {?} */ pipeMeta = new cpl.CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: !!pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    }\n    /**\n     * @param {?} typeOrFunc\n     * @param {?} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    _getDependenciesMetadata(typeOrFunc, dependencies, throwOnUnknownDeps = true) {\n        let /** @type {?} */ hasUnknownDeps = false;\n        const /** @type {?} */ params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        const /** @type {?} */ dependenciesMetadata = params.map((param) => {\n            let /** @type {?} */ isAttribute = false;\n            let /** @type {?} */ isHost = false;\n            let /** @type {?} */ isSelf = false;\n            let /** @type {?} */ isSkipSelf = false;\n            let /** @type {?} */ isOptional = false;\n            let /** @type {?} */ token = null;\n            if (Array.isArray(param)) {\n                param.forEach((paramEntry) => {\n                    if (createHost.isTypeOf(paramEntry)) {\n                        isHost = true;\n                    }\n                    else if (createSelf.isTypeOf(paramEntry)) {\n                        isSelf = true;\n                    }\n                    else if (createSkipSelf.isTypeOf(paramEntry)) {\n                        isSkipSelf = true;\n                    }\n                    else if (createOptional.isTypeOf(paramEntry)) {\n                        isOptional = true;\n                    }\n                    else if (createAttribute.isTypeOf(paramEntry)) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (createInject.isTypeOf(paramEntry)) {\n                        token = paramEntry.token;\n                    }\n                    else if (createInjectionToken.isTypeOf(paramEntry) || paramEntry instanceof StaticSymbol) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return /** @type {?} */ ((null));\n            }\n            return {\n                isAttribute,\n                isHost,\n                isSelf,\n                isSkipSelf,\n                isOptional,\n                token: this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            const /** @type {?} */ depsTokens = dependenciesMetadata.map((dep) => dep ? stringifyType(dep.token) : '?').join(', ');\n            const /** @type {?} */ message = `Can't resolve all parameters for ${stringifyType(typeOrFunc)}: (${depsTokens}).`;\n            if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(`Warning: ${message} This will become an error in Angular v6.x`);\n            }\n        }\n        return dependenciesMetadata;\n    }\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _getTokenMetadata(token) {\n        token = resolveForwardRef(token);\n        let /** @type {?} */ compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    }\n    /**\n     * @param {?} providers\n     * @param {?} targetEntryComponents\n     * @param {?=} debugInfo\n     * @param {?=} compileProviders\n     * @param {?=} type\n     * @return {?}\n     */\n    _getProvidersMetadata(providers, targetEntryComponents, debugInfo, compileProviders = [], type) {\n        providers.forEach((provider, providerIdx) => {\n            if (Array.isArray(provider)) {\n                this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = resolveForwardRef(provider);\n                let /** @type {?} */ providerMeta = /** @type {?} */ ((undefined));\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    this._validateProvider(provider);\n                    providerMeta = new cpl.ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new cpl.ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    this._reportError(syntaxError(`Encountered undefined provider! Usually this means you have a circular dependencies (might be caused by using 'barrel' index.ts files.`));\n                    return;\n                }\n                else {\n                    const /** @type {?} */ providersInfo = (/** @type {?} */ (providers.reduce((soFar, seenProvider, seenProviderIdx) => {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(`${stringifyType(seenProvider)}`);\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(`?${stringifyType(seenProvider)}?`);\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])))\n                        .join(', ');\n                    this._reportError(syntaxError(`Invalid ${debugInfo ? debugInfo : 'provider'} - only instances of Provider and Type are allowed, got: [${providersInfo}]`), type);\n                    return;\n                }\n                if (providerMeta.token ===\n                    this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push(...this._getEntryComponentsFromProvider(providerMeta, type));\n                }\n                else {\n                    compileProviders.push(this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    }\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    _validateProvider(provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(`Invalid provider for ${stringifyType(provider.provide)}. useClass cannot be ${provider.useClass}.\n           Usually it happens when:\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\n           2. Class was used before it was declared. Use forwardRef in this case.`));\n        }\n    }\n    /**\n     * @param {?} provider\n     * @param {?=} type\n     * @return {?}\n     */\n    _getEntryComponentsFromProvider(provider, type) {\n        const /** @type {?} */ components = [];\n        const /** @type {?} */ collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!`), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!`), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach((identifier) => {\n            const /** @type {?} */ entry = this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    }\n    /**\n     * @param {?} dirType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    _getEntryComponentMetadata(dirType, throwIfNotFound = true) {\n        const /** @type {?} */ dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: /** @type {?} */ ((dirMeta.metadata.componentFactory)) };\n        }\n        const /** @type {?} */ dirSummary = /** @type {?} */ (this._loadSummary(dirType, cpl.CompileSummaryKind.Directive));\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: /** @type {?} */ ((dirSummary.componentFactory)) };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(`${dirType.name} cannot be used as an entry component.`);\n        }\n        return null;\n    }\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    getProviderMetadata(provider) {\n        let /** @type {?} */ compileDeps = /** @type {?} */ ((undefined));\n        let /** @type {?} */ compileTypeMetadata = /** @type {?} */ ((null));\n        let /** @type {?} */ compileFactoryMetadata = /** @type {?} */ ((null));\n        let /** @type {?} */ token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    }\n    /**\n     * @param {?} queries\n     * @param {?} isViewQuery\n     * @param {?} directiveType\n     * @return {?}\n     */\n    _getQueriesMetadata(queries, isViewQuery, directiveType) {\n        const /** @type {?} */ res = [];\n        Object.keys(queries).forEach((propertyName) => {\n            const /** @type {?} */ query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    _queryVarBindings(selector) { return selector.split(/\\s*,\\s*/); }\n    /**\n     * @param {?} q\n     * @param {?} propertyName\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    _getQueryMetadata(q, propertyName, typeOrFunc) {\n        let /** @type {?} */ selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(varName => this._getTokenMetadata(varName));\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(`Can't construct a query for the property \"${propertyName}\" of \"${stringifyType(typeOrFunc)}\" since the query selector wasn't defined.`), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors,\n            first: q.first,\n            descendants: q.descendants, propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : /** @type {?} */ ((null))\n        };\n    }\n    /**\n     * @param {?} error\n     * @param {?=} type\n     * @param {?=} otherType\n     * @return {?}\n     */\n    _reportError(error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    }\n}\nfunction CompileMetadataResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompileMetadataResolver.prototype._nonNormalizedDirectiveCache;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._directiveCache;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._summaryCache;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._pipeCache;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._ngModuleCache;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._ngModuleOfTypes;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._config;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._htmlParser;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._ngModuleResolver;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._directiveResolver;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._pipeResolver;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._summaryResolver;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._schemaRegistry;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._directiveNormalizer;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._console;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._staticSymbolCache;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._reflector;\n    /** @type {?} */\n    CompileMetadataResolver.prototype._errorCollector;\n}\n/**\n * @param {?} tree\n * @param {?=} out\n * @return {?}\n */\nfunction flattenArray(tree, out = []) {\n    if (tree) {\n        for (let /** @type {?} */ i = 0; i < tree.length; i++) {\n            const /** @type {?} */ item = resolveForwardRef(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\n/**\n * @param {?} array\n * @return {?}\n */\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\n/**\n * @param {?} tree\n * @return {?}\n */\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof Type);\n}\n/**\n * @param {?} value\n * @param {?} targetIdentifiers\n * @return {?}\n */\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nclass _CompileValueConverter extends ValueTransformer {\n    /**\n     * @param {?} value\n     * @param {?} targetIdentifiers\n     * @return {?}\n     */\n    visitOther(value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    }\n}\n/**\n * @param {?} type\n * @return {?}\n */\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return `${type.name} in ${type.filePath}`;\n    }\n    else {\n        return stringify(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n * @param {?} compType\n * @return {?}\n */\nfunction componentStillLoadingError(compType) {\n    const /** @type {?} */ error = Error(`Can't compile synchronously as ${stringify(compType)} is still being loaded!`);\n    (/** @type {?} */ (error))[ERROR_COMPONENT_TYPE] = compType;\n    return error;\n}\n//# sourceMappingURL=metadata_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {number} */\nconst TypeModifier = {\n    Const: 0,\n};\nexport { TypeModifier };\nTypeModifier[TypeModifier.Const] = \"Const\";\n/**\n * @abstract\n */\nexport class Type {\n    /**\n     * @param {?=} modifiers\n     */\n    constructor(modifiers = null) {\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    hasModifier(modifier) { return /** @type {?} */ ((this.modifiers)).indexOf(modifier) !== -1; }\n}\nfunction Type_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Type.prototype.modifiers;\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Type.prototype.visitType = function (visitor, context) { };\n}\n/** @enum {number} */\nconst BuiltinTypeName = {\n    Dynamic: 0,\n    Bool: 1,\n    String: 2,\n    Int: 3,\n    Number: 4,\n    Function: 5,\n    Inferred: 6,\n};\nexport { BuiltinTypeName };\nBuiltinTypeName[BuiltinTypeName.Dynamic] = \"Dynamic\";\nBuiltinTypeName[BuiltinTypeName.Bool] = \"Bool\";\nBuiltinTypeName[BuiltinTypeName.String] = \"String\";\nBuiltinTypeName[BuiltinTypeName.Int] = \"Int\";\nBuiltinTypeName[BuiltinTypeName.Number] = \"Number\";\nBuiltinTypeName[BuiltinTypeName.Function] = \"Function\";\nBuiltinTypeName[BuiltinTypeName.Inferred] = \"Inferred\";\nexport class BuiltinType extends Type {\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     */\n    constructor(name, modifiers = null) {\n        super(modifiers);\n        this.name = name;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitType(visitor, context) {\n        return visitor.visitBuiltintType(this, context);\n    }\n}\nfunction BuiltinType_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BuiltinType.prototype.name;\n}\nexport class ExpressionType extends Type {\n    /**\n     * @param {?} value\n     * @param {?=} modifiers\n     */\n    constructor(value, modifiers = null) {\n        super(modifiers);\n        this.value = value;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitType(visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    }\n}\nfunction ExpressionType_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExpressionType.prototype.value;\n}\nexport class ArrayType extends Type {\n    /**\n     * @param {?} of\n     * @param {?=} modifiers\n     */\n    constructor(of, modifiers = null) {\n        super(modifiers);\n        this.of = of;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitType(visitor, context) {\n        return visitor.visitArrayType(this, context);\n    }\n}\nfunction ArrayType_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ArrayType.prototype.of;\n}\nexport class MapType extends Type {\n    /**\n     * @param {?} valueType\n     * @param {?=} modifiers\n     */\n    constructor(valueType, modifiers = null) {\n        super(modifiers);\n        this.valueType = valueType || null;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitType(visitor, context) { return visitor.visitMapType(this, context); }\n}\nfunction MapType_tsickle_Closure_declarations() {\n    /** @type {?} */\n    MapType.prototype.valueType;\n}\nexport const /** @type {?} */ DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const /** @type {?} */ INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const /** @type {?} */ BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const /** @type {?} */ INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const /** @type {?} */ NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const /** @type {?} */ STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const /** @type {?} */ FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\n/**\n * @record\n */\nexport function TypeVisitor() { }\nfunction TypeVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TypeVisitor.prototype.visitBuiltintType;\n    /** @type {?} */\n    TypeVisitor.prototype.visitExpressionType;\n    /** @type {?} */\n    TypeVisitor.prototype.visitArrayType;\n    /** @type {?} */\n    TypeVisitor.prototype.visitMapType;\n}\n/** @enum {number} */\nconst BinaryOperator = {\n    Equals: 0,\n    NotEquals: 1,\n    Identical: 2,\n    NotIdentical: 3,\n    Minus: 4,\n    Plus: 5,\n    Divide: 6,\n    Multiply: 7,\n    Modulo: 8,\n    And: 9,\n    Or: 10,\n    Lower: 11,\n    LowerEquals: 12,\n    Bigger: 13,\n    BiggerEquals: 14,\n};\nexport { BinaryOperator };\nBinaryOperator[BinaryOperator.Equals] = \"Equals\";\nBinaryOperator[BinaryOperator.NotEquals] = \"NotEquals\";\nBinaryOperator[BinaryOperator.Identical] = \"Identical\";\nBinaryOperator[BinaryOperator.NotIdentical] = \"NotIdentical\";\nBinaryOperator[BinaryOperator.Minus] = \"Minus\";\nBinaryOperator[BinaryOperator.Plus] = \"Plus\";\nBinaryOperator[BinaryOperator.Divide] = \"Divide\";\nBinaryOperator[BinaryOperator.Multiply] = \"Multiply\";\nBinaryOperator[BinaryOperator.Modulo] = \"Modulo\";\nBinaryOperator[BinaryOperator.And] = \"And\";\nBinaryOperator[BinaryOperator.Or] = \"Or\";\nBinaryOperator[BinaryOperator.Lower] = \"Lower\";\nBinaryOperator[BinaryOperator.LowerEquals] = \"LowerEquals\";\nBinaryOperator[BinaryOperator.Bigger] = \"Bigger\";\nBinaryOperator[BinaryOperator.BiggerEquals] = \"BiggerEquals\";\n/**\n * @template T\n * @param {?} base\n * @param {?} other\n * @return {?}\n */\nexport function nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n        return base == other;\n    }\n    return base.isEquivalent(other);\n}\n/**\n * @template T\n * @param {?} base\n * @param {?} other\n * @return {?}\n */\nexport function areAllEquivalent(base, other) {\n    const /** @type {?} */ len = base.length;\n    if (len !== other.length) {\n        return false;\n    }\n    for (let /** @type {?} */ i = 0; i < len; i++) {\n        if (!base[i].isEquivalent(other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @abstract\n */\nexport class Expression {\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    constructor(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    /**\n     * @param {?} name\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    prop(name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    }\n    /**\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    key(index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    }\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    callMethod(name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    }\n    /**\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    callFn(params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    }\n    /**\n     * @param {?} params\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    instantiate(params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    }\n    /**\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    conditional(trueCase, falseCase = null, sourceSpan) {\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    equals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    notEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    identical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    notIdentical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    minus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    plus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    divide(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    multiply(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    modulo(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    and(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    or(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    lower(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    lowerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    bigger(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    biggerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    }\n    /**\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    isBlank(sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    }\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    cast(type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    }\n    /**\n     * @return {?}\n     */\n    toStmt() { return new ExpressionStatement(this, null); }\n}\nfunction Expression_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Expression.prototype.type;\n    /** @type {?} */\n    Expression.prototype.sourceSpan;\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expression.prototype.visitExpression = function (visitor, context) { };\n    /**\n     * Calculates whether this expression produces the same value as the given expression.\n     * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n     * @abstract\n     * @param {?} e\n     * @return {?}\n     */\n    Expression.prototype.isEquivalent = function (e) { };\n}\n/** @enum {number} */\nconst BuiltinVar = {\n    This: 0,\n    Super: 1,\n    CatchError: 2,\n    CatchStack: 3,\n};\nexport { BuiltinVar };\nBuiltinVar[BuiltinVar.This] = \"This\";\nBuiltinVar[BuiltinVar.Super] = \"Super\";\nBuiltinVar[BuiltinVar.CatchError] = \"CatchError\";\nBuiltinVar[BuiltinVar.CatchStack] = \"CatchStack\";\nexport class ReadVarExpr extends Expression {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(name, type, sourceSpan) {\n        super(type, sourceSpan);\n        if (typeof name === 'string') {\n            this.name = name;\n            this.builtin = null;\n        }\n        else {\n            this.name = null;\n            this.builtin = /** @type {?} */ (name);\n        }\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set(value) {\n        if (!this.name) {\n            throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);\n        }\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    }\n}\nfunction ReadVarExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ReadVarExpr.prototype.name;\n    /** @type {?} */\n    ReadVarExpr.prototype.builtin;\n}\nexport class WriteVarExpr extends Expression {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.name = name;\n        this.value = value;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    }\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    toDeclStmt(type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    }\n}\nfunction WriteVarExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    WriteVarExpr.prototype.value;\n    /** @type {?} */\n    WriteVarExpr.prototype.name;\n}\nexport class WriteKeyExpr extends Expression {\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(receiver, index, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n        this.value = value;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    }\n}\nfunction WriteKeyExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    WriteKeyExpr.prototype.value;\n    /** @type {?} */\n    WriteKeyExpr.prototype.receiver;\n    /** @type {?} */\n    WriteKeyExpr.prototype.index;\n}\nexport class WritePropExpr extends Expression {\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(receiver, name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    }\n}\nfunction WritePropExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    WritePropExpr.prototype.value;\n    /** @type {?} */\n    WritePropExpr.prototype.receiver;\n    /** @type {?} */\n    WritePropExpr.prototype.name;\n}\n/** @enum {number} */\nconst BuiltinMethod = {\n    ConcatArray: 0,\n    SubscribeObservable: 1,\n    Bind: 2,\n};\nexport { BuiltinMethod };\nBuiltinMethod[BuiltinMethod.ConcatArray] = \"ConcatArray\";\nBuiltinMethod[BuiltinMethod.SubscribeObservable] = \"SubscribeObservable\";\nBuiltinMethod[BuiltinMethod.Bind] = \"Bind\";\nexport class InvokeMethodExpr extends Expression {\n    /**\n     * @param {?} receiver\n     * @param {?} method\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(receiver, method, args, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.args = args;\n        if (typeof method === 'string') {\n            this.name = method;\n            this.builtin = null;\n        }\n        else {\n            this.name = null;\n            this.builtin = /** @type {?} */ (method);\n        }\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    }\n}\nfunction InvokeMethodExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    InvokeMethodExpr.prototype.name;\n    /** @type {?} */\n    InvokeMethodExpr.prototype.builtin;\n    /** @type {?} */\n    InvokeMethodExpr.prototype.receiver;\n    /** @type {?} */\n    InvokeMethodExpr.prototype.args;\n}\nexport class InvokeFunctionExpr extends Expression {\n    /**\n     * @param {?} fn\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(fn, args, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.fn = fn;\n        this.args = args;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n            areAllEquivalent(this.args, e.args);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    }\n}\nfunction InvokeFunctionExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    InvokeFunctionExpr.prototype.fn;\n    /** @type {?} */\n    InvokeFunctionExpr.prototype.args;\n}\nexport class InstantiateExpr extends Expression {\n    /**\n     * @param {?} classExpr\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(classExpr, args, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.classExpr = classExpr;\n        this.args = args;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n            areAllEquivalent(this.args, e.args);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    }\n}\nfunction InstantiateExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    InstantiateExpr.prototype.classExpr;\n    /** @type {?} */\n    InstantiateExpr.prototype.args;\n}\nexport class LiteralExpr extends Expression {\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(value, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof LiteralExpr && this.value === e.value;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    }\n}\nfunction LiteralExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralExpr.prototype.value;\n}\nexport class ExternalExpr extends Expression {\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} typeParams\n     * @param {?=} sourceSpan\n     */\n    constructor(value, type, typeParams = null, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    }\n}\nfunction ExternalExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExternalExpr.prototype.value;\n    /** @type {?} */\n    ExternalExpr.prototype.typeParams;\n}\nexport class ExternalReference {\n    /**\n     * @param {?} moduleName\n     * @param {?} name\n     * @param {?=} runtime\n     */\n    constructor(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n}\nfunction ExternalReference_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExternalReference.prototype.moduleName;\n    /** @type {?} */\n    ExternalReference.prototype.name;\n    /** @type {?} */\n    ExternalReference.prototype.runtime;\n}\nexport class ConditionalExpr extends Expression {\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n        super(type || trueCase.type, sourceSpan);\n        this.condition = condition;\n        this.falseCase = falseCase;\n        this.trueCase = trueCase;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    }\n}\nfunction ConditionalExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ConditionalExpr.prototype.trueCase;\n    /** @type {?} */\n    ConditionalExpr.prototype.condition;\n    /** @type {?} */\n    ConditionalExpr.prototype.falseCase;\n}\nexport class NotExpr extends Expression {\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    constructor(condition, sourceSpan) {\n        super(BOOL_TYPE, sourceSpan);\n        this.condition = condition;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    }\n}\nfunction NotExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NotExpr.prototype.condition;\n}\nexport class AssertNotNull extends Expression {\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    constructor(condition, sourceSpan) {\n        super(condition.type, sourceSpan);\n        this.condition = condition;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitAssertNotNullExpr(this, context);\n    }\n}\nfunction AssertNotNull_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AssertNotNull.prototype.condition;\n}\nexport class CastExpr extends Expression {\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(value, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof CastExpr && this.value.isEquivalent(e.value);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    }\n}\nfunction CastExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CastExpr.prototype.value;\n}\nexport class FnParam {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     */\n    constructor(name, type = null) {\n        this.name = name;\n        this.type = type;\n    }\n    /**\n     * @param {?} param\n     * @return {?}\n     */\n    isEquivalent(param) { return this.name === param.name; }\n}\nfunction FnParam_tsickle_Closure_declarations() {\n    /** @type {?} */\n    FnParam.prototype.name;\n    /** @type {?} */\n    FnParam.prototype.type;\n}\nexport class FunctionExpr extends Expression {\n    /**\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(params, statements, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.params = params;\n        this.statements = statements;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n            areAllEquivalent(this.statements, e.statements);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    }\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    toDeclStmt(name, modifiers = null) {\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    }\n}\nfunction FunctionExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    FunctionExpr.prototype.params;\n    /** @type {?} */\n    FunctionExpr.prototype.statements;\n}\nexport class BinaryOperatorExpr extends Expression {\n    /**\n     * @param {?} operator\n     * @param {?} lhs\n     * @param {?} rhs\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(operator, lhs, rhs, type, sourceSpan) {\n        super(type || lhs.type, sourceSpan);\n        this.operator = operator;\n        this.rhs = rhs;\n        this.lhs = lhs;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    }\n}\nfunction BinaryOperatorExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BinaryOperatorExpr.prototype.lhs;\n    /** @type {?} */\n    BinaryOperatorExpr.prototype.operator;\n    /** @type {?} */\n    BinaryOperatorExpr.prototype.rhs;\n}\nexport class ReadPropExpr extends Expression {\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(receiver, name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set(value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    }\n}\nfunction ReadPropExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ReadPropExpr.prototype.receiver;\n    /** @type {?} */\n    ReadPropExpr.prototype.name;\n}\nexport class ReadKeyExpr extends Expression {\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(receiver, index, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set(value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    }\n}\nfunction ReadKeyExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ReadKeyExpr.prototype.receiver;\n    /** @type {?} */\n    ReadKeyExpr.prototype.index;\n}\nexport class LiteralArrayExpr extends Expression {\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    }\n}\nfunction LiteralArrayExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralArrayExpr.prototype.entries;\n}\nexport class LiteralMapEntry {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?} quoted\n     */\n    constructor(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return this.key === e.key && this.value.isEquivalent(e.value);\n    }\n}\nfunction LiteralMapEntry_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralMapEntry.prototype.key;\n    /** @type {?} */\n    LiteralMapEntry.prototype.value;\n    /** @type {?} */\n    LiteralMapEntry.prototype.quoted;\n}\nexport class LiteralMapExpr extends Expression {\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n        this.valueType = null;\n        if (type) {\n            this.valueType = type.valueType;\n        }\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    }\n}\nfunction LiteralMapExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LiteralMapExpr.prototype.valueType;\n    /** @type {?} */\n    LiteralMapExpr.prototype.entries;\n}\nexport class CommaExpr extends Expression {\n    /**\n     * @param {?} parts\n     * @param {?=} sourceSpan\n     */\n    constructor(parts, sourceSpan) {\n        super(parts[parts.length - 1].type, sourceSpan);\n        this.parts = parts;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    isEquivalent(e) {\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    }\n}\nfunction CommaExpr_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CommaExpr.prototype.parts;\n}\n/**\n * @record\n */\nexport function ExpressionVisitor() { }\nfunction ExpressionVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitReadVarExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitWriteVarExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitWriteKeyExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitWritePropExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitInvokeMethodExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitInvokeFunctionExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitInstantiateExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitLiteralExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitExternalExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitConditionalExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitNotExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitAssertNotNullExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitCastExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitFunctionExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitBinaryOperatorExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitReadPropExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitReadKeyExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitLiteralArrayExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitLiteralMapExpr;\n    /** @type {?} */\n    ExpressionVisitor.prototype.visitCommaExpr;\n}\nexport const /** @type {?} */ THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nexport const /** @type {?} */ SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nexport const /** @type {?} */ CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nexport const /** @type {?} */ CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nexport const /** @type {?} */ NULL_EXPR = new LiteralExpr(null, null, null);\nexport const /** @type {?} */ TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n/** @enum {number} */\nconst StmtModifier = {\n    Final: 0,\n    Private: 1,\n    Exported: 2,\n};\nexport { StmtModifier };\nStmtModifier[StmtModifier.Final] = \"Final\";\nStmtModifier[StmtModifier.Private] = \"Private\";\nStmtModifier[StmtModifier.Exported] = \"Exported\";\n/**\n * @abstract\n */\nexport class Statement {\n    /**\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    constructor(modifiers, sourceSpan) {\n        this.modifiers = modifiers || [];\n        this.sourceSpan = sourceSpan || null;\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    hasModifier(modifier) { return /** @type {?} */ ((this.modifiers)).indexOf(modifier) !== -1; }\n}\nfunction Statement_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Statement.prototype.modifiers;\n    /** @type {?} */\n    Statement.prototype.sourceSpan;\n    /**\n     * Calculates whether this statement produces the same value as the given statement.\n     * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n     * @abstract\n     * @param {?} stmt\n     * @return {?}\n     */\n    Statement.prototype.isEquivalent = function (stmt) { };\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Statement.prototype.visitStatement = function (visitor, context) { };\n}\nexport class DeclareVarStmt extends Statement {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    constructor(name, value, type, modifiers = null, sourceSpan) {\n        super(modifiers, sourceSpan);\n        this.name = name;\n        this.value = value;\n        this.type = type || value.type;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n            this.value.isEquivalent(stmt.value);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    }\n}\nfunction DeclareVarStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    DeclareVarStmt.prototype.type;\n    /** @type {?} */\n    DeclareVarStmt.prototype.name;\n    /** @type {?} */\n    DeclareVarStmt.prototype.value;\n}\nexport class DeclareFunctionStmt extends Statement {\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    constructor(name, params, statements, type, modifiers = null, sourceSpan) {\n        super(modifiers, sourceSpan);\n        this.name = name;\n        this.params = params;\n        this.statements = statements;\n        this.type = type || null;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n            areAllEquivalent(this.statements, stmt.statements);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    }\n}\nfunction DeclareFunctionStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    DeclareFunctionStmt.prototype.type;\n    /** @type {?} */\n    DeclareFunctionStmt.prototype.name;\n    /** @type {?} */\n    DeclareFunctionStmt.prototype.params;\n    /** @type {?} */\n    DeclareFunctionStmt.prototype.statements;\n}\nexport class ExpressionStatement extends Statement {\n    /**\n     * @param {?} expr\n     * @param {?=} sourceSpan\n     */\n    constructor(expr, sourceSpan) {\n        super(null, sourceSpan);\n        this.expr = expr;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    }\n}\nfunction ExpressionStatement_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExpressionStatement.prototype.expr;\n}\nexport class ReturnStatement extends Statement {\n    /**\n     * @param {?} value\n     * @param {?=} sourceSpan\n     */\n    constructor(value, sourceSpan) {\n        super(null, sourceSpan);\n        this.value = value;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    }\n}\nfunction ReturnStatement_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ReturnStatement.prototype.value;\n}\nexport class AbstractClassPart {\n    /**\n     * @param {?} type\n     * @param {?} modifiers\n     */\n    constructor(type, modifiers) {\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n        this.type = type || null;\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    hasModifier(modifier) { return /** @type {?} */ ((this.modifiers)).indexOf(modifier) !== -1; }\n}\nfunction AbstractClassPart_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AbstractClassPart.prototype.type;\n    /** @type {?} */\n    AbstractClassPart.prototype.modifiers;\n}\nexport class ClassField extends AbstractClassPart {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    constructor(name, type, modifiers = null) {\n        super(type, modifiers);\n        this.name = name;\n    }\n    /**\n     * @param {?} f\n     * @return {?}\n     */\n    isEquivalent(f) { return this.name === f.name; }\n}\nfunction ClassField_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ClassField.prototype.name;\n}\nexport class ClassMethod extends AbstractClassPart {\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    constructor(name, params, body, type, modifiers = null) {\n        super(type, modifiers);\n        this.name = name;\n        this.params = params;\n        this.body = body;\n    }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n    isEquivalent(m) {\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\n    }\n}\nfunction ClassMethod_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ClassMethod.prototype.name;\n    /** @type {?} */\n    ClassMethod.prototype.params;\n    /** @type {?} */\n    ClassMethod.prototype.body;\n}\nexport class ClassGetter extends AbstractClassPart {\n    /**\n     * @param {?} name\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    constructor(name, body, type, modifiers = null) {\n        super(type, modifiers);\n        this.name = name;\n        this.body = body;\n    }\n    /**\n     * @param {?} m\n     * @return {?}\n     */\n    isEquivalent(m) {\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\n    }\n}\nfunction ClassGetter_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ClassGetter.prototype.name;\n    /** @type {?} */\n    ClassGetter.prototype.body;\n}\nexport class ClassStmt extends Statement {\n    /**\n     * @param {?} name\n     * @param {?} parent\n     * @param {?} fields\n     * @param {?} getters\n     * @param {?} constructorMethod\n     * @param {?} methods\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    constructor(name, parent, fields, getters, constructorMethod, methods, modifiers = null, sourceSpan) {\n        super(modifiers, sourceSpan);\n        this.name = name;\n        this.parent = parent;\n        this.fields = fields;\n        this.getters = getters;\n        this.constructorMethod = constructorMethod;\n        this.methods = methods;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof ClassStmt && this.name === stmt.name &&\n            nullSafeIsEquivalent(this.parent, stmt.parent) &&\n            areAllEquivalent(this.fields, stmt.fields) &&\n            areAllEquivalent(this.getters, stmt.getters) &&\n            this.constructorMethod.isEquivalent(stmt.constructorMethod) &&\n            areAllEquivalent(this.methods, stmt.methods);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    }\n}\nfunction ClassStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ClassStmt.prototype.name;\n    /** @type {?} */\n    ClassStmt.prototype.parent;\n    /** @type {?} */\n    ClassStmt.prototype.fields;\n    /** @type {?} */\n    ClassStmt.prototype.getters;\n    /** @type {?} */\n    ClassStmt.prototype.constructorMethod;\n    /** @type {?} */\n    ClassStmt.prototype.methods;\n}\nexport class IfStmt extends Statement {\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     */\n    constructor(condition, trueCase, falseCase = [], sourceSpan) {\n        super(null, sourceSpan);\n        this.condition = condition;\n        this.trueCase = trueCase;\n        this.falseCase = falseCase;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\n            areAllEquivalent(this.falseCase, stmt.falseCase);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    }\n}\nfunction IfStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    IfStmt.prototype.condition;\n    /** @type {?} */\n    IfStmt.prototype.trueCase;\n    /** @type {?} */\n    IfStmt.prototype.falseCase;\n}\nexport class CommentStmt extends Statement {\n    /**\n     * @param {?} comment\n     * @param {?=} sourceSpan\n     */\n    constructor(comment, sourceSpan) {\n        super(null, sourceSpan);\n        this.comment = comment;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) { return stmt instanceof CommentStmt; }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitCommentStmt(this, context);\n    }\n}\nfunction CommentStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CommentStmt.prototype.comment;\n}\nexport class TryCatchStmt extends Statement {\n    /**\n     * @param {?} bodyStmts\n     * @param {?} catchStmts\n     * @param {?=} sourceSpan\n     */\n    constructor(bodyStmts, catchStmts, sourceSpan) {\n        super(null, sourceSpan);\n        this.bodyStmts = bodyStmts;\n        this.catchStmts = catchStmts;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\n            areAllEquivalent(this.catchStmts, stmt.catchStmts);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    }\n}\nfunction TryCatchStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TryCatchStmt.prototype.bodyStmts;\n    /** @type {?} */\n    TryCatchStmt.prototype.catchStmts;\n}\nexport class ThrowStmt extends Statement {\n    /**\n     * @param {?} error\n     * @param {?=} sourceSpan\n     */\n    constructor(error, sourceSpan) {\n        super(null, sourceSpan);\n        this.error = error;\n    }\n    /**\n     * @param {?} stmt\n     * @return {?}\n     */\n    isEquivalent(stmt) {\n        return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    visitStatement(visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    }\n}\nfunction ThrowStmt_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ThrowStmt.prototype.error;\n}\n/**\n * @record\n */\nexport function StatementVisitor() { }\nfunction StatementVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StatementVisitor.prototype.visitDeclareVarStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitDeclareFunctionStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitExpressionStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitReturnStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitDeclareClassStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitIfStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitTryCatchStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitThrowStmt;\n    /** @type {?} */\n    StatementVisitor.prototype.visitCommentStmt;\n}\nexport class AstTransformer {\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    transformExpr(expr, context) { return expr; }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    transformStmt(stmt, context) { return stmt; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadVarExpr(ast, context) { return this.transformExpr(ast, context); }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    visitWriteVarExpr(expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    visitWriteKeyExpr(expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    visitWritePropExpr(expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInvokeMethodExpr(ast, context) {\n        const /** @type {?} */ method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), /** @type {?} */ ((method)), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInvokeFunctionExpr(ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInstantiateExpr(ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralExpr(ast, context) { return this.transformExpr(ast, context); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExternalExpr(ast, context) {\n        return this.transformExpr(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitConditionalExpr(ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), /** @type {?} */ ((ast.falseCase)).visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNotExpr(ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAssertNotNullExpr(ast, context) {\n        return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitCastExpr(ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitFunctionExpr(ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBinaryOperatorExpr(ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadPropExpr(ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadKeyExpr(ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArrayExpr(ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMapExpr(ast, context) {\n        const /** @type {?} */ entries = ast.entries.map((entry) => new LiteralMapEntry(entry.key, entry.value.visitExpression(this, context), entry.quoted));\n        const /** @type {?} */ mapType = new MapType(ast.valueType, null);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitCommaExpr(ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    }\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    visitAllExpressions(exprs, context) {\n        return exprs.map(expr => expr.visitExpression(this, context));\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareVarStmt(stmt, context) {\n        return this.transformStmt(new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpressionStmt(stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitReturnStmt(stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, context) {\n        const /** @type {?} */ parent = /** @type {?} */ ((stmt.parent)).visitExpression(this, context);\n        const /** @type {?} */ getters = stmt.getters.map(getter => new ClassGetter(getter.name, this.visitAllStatements(getter.body, context), getter.type, getter.modifiers));\n        const /** @type {?} */ ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        const /** @type {?} */ methods = stmt.methods.map(method => new ClassMethod(method.name, method.params, this.visitAllStatements(method.body, context), method.type, method.modifiers));\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitIfStmt(stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitTryCatchStmt(stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitThrowStmt(stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitCommentStmt(stmt, context) {\n        return this.transformStmt(stmt, context);\n    }\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    visitAllStatements(stmts, context) {\n        return stmts.map(stmt => stmt.visitStatement(this, context));\n    }\n}\nexport class RecursiveAstVisitor {\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitType(ast, context) { return ast; }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpression(ast, context) {\n        if (ast.type) {\n            ast.type.visitType(this, context);\n        }\n        return ast;\n    }\n    /**\n     * @param {?} type\n     * @param {?} context\n     * @return {?}\n     */\n    visitBuiltintType(type, context) { return this.visitType(type, context); }\n    /**\n     * @param {?} type\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpressionType(type, context) {\n        type.value.visitExpression(this, context);\n        return this.visitType(type, context);\n    }\n    /**\n     * @param {?} type\n     * @param {?} context\n     * @return {?}\n     */\n    visitArrayType(type, context) { return this.visitType(type, context); }\n    /**\n     * @param {?} type\n     * @param {?} context\n     * @return {?}\n     */\n    visitMapType(type, context) { return this.visitType(type, context); }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadVarExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitWriteVarExpr(ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitWriteKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitWritePropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInvokeMethodExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInvokeFunctionExpr(ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitInstantiateExpr(ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitExternalExpr(ast, context) {\n        if (ast.typeParams) {\n            ast.typeParams.forEach(type => type.visitType(this, context));\n        }\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitConditionalExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context); /** @type {?} */\n        ((ast.falseCase)).visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNotExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAssertNotNullExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitCastExpr(ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitFunctionExpr(ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBinaryOperatorExpr(ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadPropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArrayExpr(ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMapExpr(ast, context) {\n        ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitCommaExpr(ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n        return this.visitExpression(ast, context);\n    }\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    visitAllExpressions(exprs, context) {\n        exprs.forEach(expr => expr.visitExpression(this, context));\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareVarStmt(stmt, context) {\n        stmt.value.visitExpression(this, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpressionStmt(stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitReturnStmt(stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, context) {\n        /** @type {?} */ ((stmt.parent)).visitExpression(this, context);\n        stmt.getters.forEach(getter => this.visitAllStatements(getter.body, context));\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(method => this.visitAllStatements(method.body, context));\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitIfStmt(stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitTryCatchStmt(stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitThrowStmt(stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitCommentStmt(stmt, context) { return stmt; }\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    visitAllStatements(stmts, context) {\n        stmts.forEach(stmt => stmt.visitStatement(this, context));\n    }\n}\n/**\n * @param {?} stmts\n * @return {?}\n */\nexport function findReadVarNames(stmts) {\n    const /** @type {?} */ visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nclass _ReadVarVisitor extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.varNames = new Set();\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReadVarExpr(ast, context) {\n        if (ast.name) {\n            this.varNames.add(ast.name);\n        }\n        return null;\n    }\n}\nfunction _ReadVarVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _ReadVarVisitor.prototype.varNames;\n}\n/**\n * @param {?} stmts\n * @return {?}\n */\nexport function collectExternalReferences(stmts) {\n    const /** @type {?} */ visitor = new _FindExternalReferencesVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.externalReferences;\n}\nclass _FindExternalReferencesVisitor extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.externalReferences = [];\n    }\n    /**\n     * @param {?} e\n     * @param {?} context\n     * @return {?}\n     */\n    visitExternalExpr(e, context) {\n        this.externalReferences.push(e.value);\n        return super.visitExternalExpr(e, context);\n    }\n}\nfunction _FindExternalReferencesVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _FindExternalReferencesVisitor.prototype.externalReferences;\n}\n/**\n * @param {?} stmt\n * @param {?} sourceSpan\n * @return {?}\n */\nexport function applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    const /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\n/**\n * @param {?} expr\n * @param {?} sourceSpan\n * @return {?}\n */\nexport function applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    const /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nclass _ApplySourceSpanTransformer extends AstTransformer {\n    /**\n     * @param {?} sourceSpan\n     */\n    constructor(sourceSpan) {\n        super();\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    _clone(obj) {\n        const /** @type {?} */ clone = Object.create(obj.constructor.prototype);\n        for (let /** @type {?} */ prop in obj) {\n            clone[prop] = obj[prop];\n        }\n        return clone;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    transformExpr(expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    transformStmt(stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    }\n}\nfunction _ApplySourceSpanTransformer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _ApplySourceSpanTransformer.prototype.sourceSpan;\n}\n/**\n * @param {?} name\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function importExpr(id, typeParams = null, sourceSpan) {\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} typeModifiers\n * @return {?}\n */\nexport function importType(id, typeParams = null, typeModifiers = null) {\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n/**\n * @param {?} expr\n * @param {?=} typeModifiers\n * @return {?}\n */\nexport function expressionType(expr, typeModifiers = null) {\n    return new ExpressionType(expr, typeModifiers);\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @return {?}\n */\nexport function literalMap(values, type = null) {\n    return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function assertNotNull(expr, sourceSpan) {\n    return new AssertNotNull(expr, sourceSpan);\n}\n/**\n * @param {?} params\n * @param {?} body\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function fn(params, body, type, sourceSpan) {\n    return new FunctionExpr(params, body, type, sourceSpan);\n}\n/**\n * @param {?} value\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nexport function literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\n//# sourceMappingURL=output_ast.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { tokenName, tokenReference } from \"./compile_metadata\";\nimport { Identifiers, createTokenForExternalReference } from \"./identifiers\";\nimport { ParseError } from \"./parse_util\";\nimport { ProviderAst, ProviderAstType } from \"./template_parser/template_ast\";\nexport class ProviderError extends ParseError {\n    /**\n     * @param {?} message\n     * @param {?} span\n     */\n    constructor(message, span) { super(span, message); }\n}\n/**\n * @record\n */\nexport function QueryWithId() { }\nfunction QueryWithId_tsickle_Closure_declarations() {\n    /** @type {?} */\n    QueryWithId.prototype.meta;\n    /** @type {?} */\n    QueryWithId.prototype.queryId;\n}\nexport class ProviderViewContext {\n    /**\n     * @param {?} reflector\n     * @param {?} component\n     */\n    constructor(reflector, component) {\n        this.reflector = reflector;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach((provider) => {\n            if (this.viewProviders.get(tokenReference(provider.token)) == null) {\n                this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n}\nfunction ProviderViewContext_tsickle_Closure_declarations() {\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ProviderViewContext.prototype.viewQueries;\n    /**\n     * \\@internal\n     * @type {?}\n     */\n    ProviderViewContext.prototype.viewProviders;\n    /** @type {?} */\n    ProviderViewContext.prototype.errors;\n    /** @type {?} */\n    ProviderViewContext.prototype.reflector;\n    /** @type {?} */\n    ProviderViewContext.prototype.component;\n}\nexport class ProviderElementContext {\n    /**\n     * @param {?} viewContext\n     * @param {?} _parent\n     * @param {?} _isViewRoot\n     * @param {?} _directiveAsts\n     * @param {?} attrs\n     * @param {?} refs\n     * @param {?} isTemplate\n     * @param {?} contentQueryStartId\n     * @param {?} _sourceSpan\n     */\n    constructor(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._queriedTokens = new Map();\n        this.transformedHasViewContainer = false;\n        this._attrs = {};\n        attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);\n        const /** @type {?} */ directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach((provider) => {\n            this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);\n        });\n        if (isTemplate) {\n            const /** @type {?} */ templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach((refAst) => {\n            let /** @type {?} */ defaultQueryValue = refAst.value ||\n                createTokenForExternalReference(this.viewContext.reflector, Identifiers.ElementRef);\n            this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, this._queriedTokens);\n        });\n        if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n            this.transformedHasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach((provider) => {\n            const /** @type {?} */ eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    afterElement() {\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach((provider) => {\n            this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    }\n    /**\n     * @return {?}\n     */\n    get transformProviders() {\n        // Note: Maps keep their insertion order.\n        const /** @type {?} */ lazyProviders = [];\n        const /** @type {?} */ eagerProviders = [];\n        this._transformedProviders.forEach(provider => {\n            if (provider.eager) {\n                eagerProviders.push(provider);\n            }\n            else {\n                lazyProviders.push(provider);\n            }\n        });\n        return lazyProviders.concat(eagerProviders);\n    }\n    /**\n     * @return {?}\n     */\n    get transformedDirectiveAsts() {\n        const /** @type {?} */ sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);\n        const /** @type {?} */ sortedDirectives = this._directiveAsts.slice();\n        sortedDirectives.sort((dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -\n            sortedProviderTypes.indexOf(dir2.directive.type));\n        return sortedDirectives;\n    }\n    /**\n     * @return {?}\n     */\n    get queryMatches() {\n        const /** @type {?} */ allMatches = [];\n        this._queriedTokens.forEach((matches) => { allMatches.push(...matches); });\n        return allMatches;\n    }\n    /**\n     * @param {?} token\n     * @param {?} defaultValue\n     * @param {?} queryReadTokens\n     * @return {?}\n     */\n    _addQueryReadsTo(token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach((query) => {\n            const /** @type {?} */ queryValue = query.meta.read || defaultValue;\n            const /** @type {?} */ tokenRef = tokenReference(queryValue);\n            let /** @type {?} */ queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    }\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _getQueriesFor(token) {\n        const /** @type {?} */ result = [];\n        let /** @type {?} */ currentEl = this;\n        let /** @type {?} */ distance = 0;\n        let /** @type {?} */ queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push(...queries);\n        }\n        return result;\n    }\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    _getOrCreateLocalProvider(requestingProviderType, token, eager) {\n        const /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n            requestingProviderType === ProviderAstType.PublicService) &&\n            resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        let /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        const /** @type {?} */ transformedProviders = resolvedProvider.providers.map((provider) => {\n            let /** @type {?} */ transformedUseValue = provider.useValue;\n            let /** @type {?} */ transformedUseExisting = /** @type {?} */ ((provider.useExisting));\n            let /** @type {?} */ transformedDeps = /** @type {?} */ ((undefined));\n            if (provider.useExisting != null) {\n                const /** @type {?} */ existingDiDep = /** @type {?} */ ((this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager)));\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = /** @type {?} */ ((null));\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                const /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map((dep) => /** @type {?} */ ((this._getDependency(resolvedProvider.providerType, dep, eager))));\n            }\n            else if (provider.useClass) {\n                const /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map((dep) => /** @type {?} */ ((this._getDependency(resolvedProvider.providerType, dep, eager))));\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    }\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    _getLocalDependency(requestingProviderType, dep, eager = false) {\n        if (dep.isAttribute) {\n            const /** @type {?} */ attrValue = this._attrs[/** @type {?} */ ((dep.token)).value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                    (/** @type {?} */ (this)).transformedHasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    }\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    _getDependency(requestingProviderType, dep, eager = false) {\n        let /** @type {?} */ currElement = this;\n        let /** @type {?} */ currEager = eager;\n        let /** @type {?} */ result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                const /** @type {?} */ prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(/** @type {?} */ ((dep.token))) ||\n                    this.viewContext.viewProviders.get(tokenReference(/** @type {?} */ ((dep.token)))) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? result = { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(`No provider for ${tokenName((/** @type {?} */ ((dep.token))))}`, this._sourceSpan));\n        }\n        return result;\n    }\n}\nfunction ProviderElementContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ProviderElementContext.prototype._contentQueries;\n    /** @type {?} */\n    ProviderElementContext.prototype._transformedProviders;\n    /** @type {?} */\n    ProviderElementContext.prototype._seenProviders;\n    /** @type {?} */\n    ProviderElementContext.prototype._allProviders;\n    /** @type {?} */\n    ProviderElementContext.prototype._attrs;\n    /** @type {?} */\n    ProviderElementContext.prototype._queriedTokens;\n    /** @type {?} */\n    ProviderElementContext.prototype.transformedHasViewContainer;\n    /** @type {?} */\n    ProviderElementContext.prototype.viewContext;\n    /** @type {?} */\n    ProviderElementContext.prototype._parent;\n    /** @type {?} */\n    ProviderElementContext.prototype._isViewRoot;\n    /** @type {?} */\n    ProviderElementContext.prototype._directiveAsts;\n    /** @type {?} */\n    ProviderElementContext.prototype._sourceSpan;\n}\nexport class NgModuleProviderAnalyzer {\n    /**\n     * @param {?} reflector\n     * @param {?} ngModule\n     * @param {?} extraProviders\n     * @param {?} sourceSpan\n     */\n    constructor(reflector, ngModule, extraProviders, sourceSpan) {\n        this.reflector = reflector;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach((ngModuleType) => {\n            const /** @type {?} */ ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, this._errors, this._allProviders);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(entry => entry.provider).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);\n    }\n    /**\n     * @return {?}\n     */\n    parse() {\n        Array.from(this._allProviders.values()).forEach((provider) => {\n            this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            const /** @type {?} */ errorString = this._errors.join('\\n');\n            throw new Error(`Provider parse errors:\\n${errorString}`);\n        }\n        // Note: Maps keep their insertion order.\n        const /** @type {?} */ lazyProviders = [];\n        const /** @type {?} */ eagerProviders = [];\n        this._transformedProviders.forEach(provider => {\n            if (provider.eager) {\n                eagerProviders.push(provider);\n            }\n            else {\n                lazyProviders.push(provider);\n            }\n        });\n        return lazyProviders.concat(eagerProviders);\n    }\n    /**\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    _getOrCreateLocalProvider(token, eager) {\n        const /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        let /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        const /** @type {?} */ transformedProviders = resolvedProvider.providers.map((provider) => {\n            let /** @type {?} */ transformedUseValue = provider.useValue;\n            let /** @type {?} */ transformedUseExisting = /** @type {?} */ ((provider.useExisting));\n            let /** @type {?} */ transformedDeps = /** @type {?} */ ((undefined));\n            if (provider.useExisting != null) {\n                const /** @type {?} */ existingDiDep = this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = /** @type {?} */ ((null));\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                const /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n            }\n            else if (provider.useClass) {\n                const /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    }\n    /**\n     * @param {?} dep\n     * @param {?=} eager\n     * @param {?=} requestorSourceSpan\n     * @return {?}\n     */\n    _getDependency(dep, eager = false, requestorSourceSpan) {\n        let /** @type {?} */ foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.reflector.resolveExternalReference(Identifiers.Injector) ||\n                tokenReference(dep.token) ===\n                    this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n                // access providers\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        let /** @type {?} */ result = dep;\n        if (dep.isSelf && !foundLocal) {\n            if (dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n            else {\n                this._errors.push(new ProviderError(`No provider for ${tokenName((/** @type {?} */ ((dep.token))))}`, requestorSourceSpan));\n            }\n        }\n        return result;\n    }\n}\nfunction NgModuleProviderAnalyzer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgModuleProviderAnalyzer.prototype._transformedProviders;\n    /** @type {?} */\n    NgModuleProviderAnalyzer.prototype._seenProviders;\n    /** @type {?} */\n    NgModuleProviderAnalyzer.prototype._allProviders;\n    /** @type {?} */\n    NgModuleProviderAnalyzer.prototype._errors;\n    /** @type {?} */\n    NgModuleProviderAnalyzer.prototype.reflector;\n}\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProvider(provider, { useExisting, useValue, deps }) {\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProviderAst(provider, { eager, providers }) {\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);\n}\n/**\n * @param {?} directives\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @return {?}\n */\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    const /** @type {?} */ providersByToken = new Map();\n    directives.forEach((directive) => {\n        const /** @type {?} */ dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    const /** @type {?} */ directivesWithComponentFirst = directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));\n    directivesWithComponentFirst.forEach((directive) => {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);\n    });\n    return providersByToken;\n}\n/**\n * @param {?} providers\n * @param {?} providerType\n * @param {?} eager\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @param {?} targetProvidersByToken\n * @return {?}\n */\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {\n    providers.forEach((provider) => {\n        let /** @type {?} */ resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(`Mixing multi and non multi provider is not possible for token ${tokenName(resolvedProvider.token)}`, sourceSpan));\n        }\n        if (!resolvedProvider) {\n            const /** @type {?} */ lifecycleHooks = provider.token.identifier &&\n                (/** @type {?} */ (provider.token.identifier)).lifecycleHooks ?\n                (/** @type {?} */ (provider.token.identifier)).lifecycleHooks :\n                [];\n            const /** @type {?} */ isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    let /** @type {?} */ viewQueryId = 1;\n    const /** @type {?} */ viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach((query) => _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }));\n    }\n    return viewQueries;\n}\n/**\n * @param {?} contentQueryStartId\n * @param {?} directives\n * @return {?}\n */\nfunction _getContentQueries(contentQueryStartId, directives) {\n    let /** @type {?} */ contentQueryId = contentQueryStartId;\n    const /** @type {?} */ contentQueries = new Map();\n    directives.forEach((directive, directiveIndex) => {\n        if (directive.queries) {\n            directive.queries.forEach((query) => _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }));\n        }\n    });\n    return contentQueries;\n}\n/**\n * @param {?} map\n * @param {?} query\n * @return {?}\n */\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach((token) => {\n        let /** @type {?} */ entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n//# sourceMappingURL=provider_analyzer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { visitValue } from \"../util\";\nimport * as o from \"./output_ast\";\nexport const /** @type {?} */ QUOTED_KEYS = '$quoted$';\n/**\n * @param {?} ctx\n * @param {?} value\n * @param {?=} type\n * @return {?}\n */\nexport function convertValueToOutputAst(ctx, value, type = null) {\n    return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n}\nclass _ValueOutputAstTransformer {\n    /**\n     * @param {?} ctx\n     */\n    constructor(ctx) {\n        this.ctx = ctx;\n    }\n    /**\n     * @param {?} arr\n     * @param {?} type\n     * @return {?}\n     */\n    visitArray(arr, type) {\n        return o.literalArr(arr.map(value => visitValue(value, this, null)), type);\n    }\n    /**\n     * @param {?} map\n     * @param {?} type\n     * @return {?}\n     */\n    visitStringMap(map, type) {\n        const /** @type {?} */ entries = [];\n        const /** @type {?} */ quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(key => {\n            entries.push(new o.LiteralMapEntry(key, visitValue(map[key], this, null), quotedSet.has(key)));\n        });\n        return new o.LiteralMapExpr(entries, type);\n    }\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    visitPrimitive(value, type) { return o.literal(value, type); }\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    visitOther(value, type) {\n        if (value instanceof o.Expression) {\n            return value;\n        }\n        else {\n            return this.ctx.importExpr(value);\n        }\n    }\n}\nfunction _ValueOutputAstTransformer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _ValueOutputAstTransformer.prototype.ctx;\n}\n//# sourceMappingURL=value_util.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { Identifiers, createTokenForExternalReference } from \"../identifiers\";\nimport { LifecycleHooks } from \"../lifecycle_reflector\";\nimport * as o from \"../output/output_ast\";\nimport { convertValueToOutputAst } from \"../output/value_util\";\nimport { ProviderAstType } from \"../template_parser/template_ast\";\n/**\n * @param {?} ctx\n * @param {?} providerAst\n * @return {?}\n */\nexport function providerDef(ctx, providerAst) {\n    let /** @type {?} */ flags = 0 /* None */;\n    if (!providerAst.eager) {\n        flags |= 4096 /* LazyProvider */;\n    }\n    if (providerAst.providerType === ProviderAstType.PrivateService) {\n        flags |= 8192 /* PrivateProvider */;\n    }\n    providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n        // for regular providers, we only support ngOnDestroy\n        if (lifecycleHook === LifecycleHooks.OnDestroy ||\n            providerAst.providerType === ProviderAstType.Directive ||\n            providerAst.providerType === ProviderAstType.Component) {\n            flags |= lifecycleHookToNodeFlag(lifecycleHook);\n        }\n    });\n    const { providerExpr, flags: providerFlags, depsExpr } = providerAst.multiProvider ?\n        multiProviderDef(ctx, flags, providerAst.providers) :\n        singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n    return {\n        providerExpr,\n        flags: providerFlags, depsExpr,\n        tokenExpr: tokenExpr(ctx, providerAst.token),\n    };\n}\n/**\n * @param {?} ctx\n * @param {?} flags\n * @param {?} providers\n * @return {?}\n */\nfunction multiProviderDef(ctx, flags, providers) {\n    const /** @type {?} */ allDepDefs = [];\n    const /** @type {?} */ allParams = [];\n    const /** @type {?} */ exprs = providers.map((provider, providerIndex) => {\n        let /** @type {?} */ expr;\n        if (provider.useClass) {\n            const /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            const /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            const /** @type {?} */ depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(ctx, provider.useValue);\n        }\n        return expr;\n    });\n    const /** @type {?} */ providerExpr = o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n    return {\n        providerExpr,\n        flags: flags | 1024 /* TypeFactoryProvider */,\n        depsExpr: o.literalArr(allDepDefs)\n    };\n    /**\n     * @param {?} providerIndex\n     * @param {?} deps\n     * @return {?}\n     */\n    function convertDeps(providerIndex, deps) {\n        return deps.map((dep, depIndex) => {\n            const /** @type {?} */ paramName = `p${providerIndex}_${depIndex}`;\n            allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n            allDepDefs.push(depDef(ctx, dep));\n            return o.variable(paramName);\n        });\n    }\n}\n/**\n * @param {?} ctx\n * @param {?} flags\n * @param {?} providerType\n * @param {?} providerMeta\n * @return {?}\n */\nfunction singleProviderDef(ctx, flags, providerType, providerMeta) {\n    let /** @type {?} */ providerExpr;\n    let /** @type {?} */ deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = ctx.importExpr(/** @type {?} */ ((providerMeta.useClass)).reference);\n        flags |= 16384 /* TypeDirective */;\n        deps = providerMeta.deps || /** @type {?} */ ((providerMeta.useClass)).diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n            flags |= 512 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n            flags |= 1024 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = o.NULL_EXPR;\n            flags |= 2048 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n            flags |= 256 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    const /** @type {?} */ depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n    return { providerExpr, flags, depsExpr };\n}\n/**\n * @param {?} ctx\n * @param {?} tokenMeta\n * @return {?}\n */\nfunction tokenExpr(ctx, tokenMeta) {\n    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n        o.literal(tokenMeta.value);\n}\n/**\n * @param {?} ctx\n * @param {?} dep\n * @return {?}\n */\nexport function depDef(ctx, dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isSelf, isHost\n    const /** @type {?} */ expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, /** @type {?} */ ((dep.token)));\n    let /** @type {?} */ flags = 0 /* None */;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : o.literalArr([o.literal(flags), expr]);\n}\n/**\n * @param {?} lifecycleHook\n * @return {?}\n */\nexport function lifecycleHookToNodeFlag(lifecycleHook) {\n    let /** @type {?} */ nodeFlag = 0 /* None */;\n    switch (lifecycleHook) {\n        case LifecycleHooks.AfterContentChecked:\n            nodeFlag = 2097152 /* AfterContentChecked */;\n            break;\n        case LifecycleHooks.AfterContentInit:\n            nodeFlag = 1048576 /* AfterContentInit */;\n            break;\n        case LifecycleHooks.AfterViewChecked:\n            nodeFlag = 8388608 /* AfterViewChecked */;\n            break;\n        case LifecycleHooks.AfterViewInit:\n            nodeFlag = 4194304 /* AfterViewInit */;\n            break;\n        case LifecycleHooks.DoCheck:\n            nodeFlag = 262144 /* DoCheck */;\n            break;\n        case LifecycleHooks.OnChanges:\n            nodeFlag = 524288 /* OnChanges */;\n            break;\n        case LifecycleHooks.OnDestroy:\n            nodeFlag = 131072 /* OnDestroy */;\n            break;\n        case LifecycleHooks.OnInit:\n            nodeFlag = 65536 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\n/**\n * @param {?} reflector\n * @param {?} ctx\n * @param {?} flags\n * @param {?} entryComponents\n * @return {?}\n */\nexport function componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\n    const /** @type {?} */ entryComponentFactories = entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n    const /** @type {?} */ token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n    const /** @type {?} */ classMeta = {\n        diDeps: [\n            { isValue: true, value: o.literalArr(entryComponentFactories) },\n            { token: token, isSkipSelf: true, isOptional: true },\n            { token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef) },\n        ],\n        lifecycleHooks: [],\n        reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n    };\n    const { providerExpr, flags: providerFlags, depsExpr } = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token,\n        multi: false,\n        useClass: classMeta,\n    });\n    return { providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token) };\n}\n//# sourceMappingURL=provider_compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { identifierName } from \"./compile_metadata\";\nimport { Identifiers } from \"./identifiers\";\nimport * as o from \"./output/output_ast\";\nimport { typeSourceSpan } from \"./parse_util\";\nimport { NgModuleProviderAnalyzer } from \"./provider_analyzer\";\nimport { componentFactoryResolverProviderDef, providerDef } from \"./view_compiler/provider_compiler\";\nexport class NgModuleCompileResult {\n    /**\n     * @param {?} ngModuleFactoryVar\n     */\n    constructor(ngModuleFactoryVar) {\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n    }\n}\nfunction NgModuleCompileResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgModuleCompileResult.prototype.ngModuleFactoryVar;\n}\nconst /** @type {?} */ LOG_VAR = o.variable('_l');\nexport class NgModuleCompiler {\n    /**\n     * @param {?} reflector\n     */\n    constructor(reflector) {\n        this.reflector = reflector;\n    }\n    /**\n     * @param {?} ctx\n     * @param {?} ngModuleMeta\n     * @param {?} extraProviders\n     * @return {?}\n     */\n    compile(ctx, ngModuleMeta, extraProviders) {\n        const /** @type {?} */ sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        const /** @type {?} */ entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\n        const /** @type {?} */ bootstrapComponents = ngModuleMeta.bootstrapComponents;\n        const /** @type {?} */ providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\n        const /** @type {?} */ providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0 /* None */, entryComponentFactories)]\n            .concat(providerParser.parse().map((provider) => providerDef(ctx, provider)))\n            .map(({ providerExpr, depsExpr, flags, tokenExpr }) => {\n            return o.importExpr(Identifiers.moduleProviderDef).callFn([\n                o.literal(flags), tokenExpr, providerExpr, depsExpr\n            ]);\n        });\n        const /** @type {?} */ ngModuleDef = o.importExpr(Identifiers.moduleDef).callFn([o.literalArr(providerDefs)]);\n        const /** @type {?} */ ngModuleDefFactory = o.fn([new o.FnParam(/** @type {?} */ ((LOG_VAR.name)))], [new o.ReturnStatement(ngModuleDef)], o.INFERRED_TYPE);\n        const /** @type {?} */ ngModuleFactoryVar = `${identifierName(ngModuleMeta.type)}NgFactory`;\n        this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, o.importExpr(Identifiers.createModuleFactory).callFn([\n            ctx.importExpr(ngModuleMeta.type.reference),\n            o.literalArr(bootstrapComponents.map(id => ctx.importExpr(id.reference))),\n            ngModuleDefFactory\n        ]));\n        if (ngModuleMeta.id) {\n            const /** @type {?} */ registerFactoryStmt = o.importExpr(Identifiers.RegisterModuleFactoryFn)\n                .callFn([o.literal(ngModuleMeta.id), o.variable(ngModuleFactoryVar)])\n                .toStmt();\n            ctx.statements.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(ngModuleFactoryVar);\n    }\n    /**\n     * @param {?} ctx\n     * @param {?} ngModuleReference\n     * @return {?}\n     */\n    createStub(ctx, ngModuleReference) {\n        this._createNgModuleFactory(ctx, ngModuleReference, o.NULL_EXPR);\n    }\n    /**\n     * @param {?} ctx\n     * @param {?} reference\n     * @param {?} value\n     * @return {?}\n     */\n    _createNgModuleFactory(ctx, reference, value) {\n        const /** @type {?} */ ngModuleFactoryVar = `${identifierName({ reference: reference })}NgFactory`;\n        const /** @type {?} */ ngModuleFactoryStmt = o.variable(ngModuleFactoryVar)\n            .set(value)\n            .toDeclStmt(o.importType(Identifiers.NgModuleFactory, [/** @type {?} */ ((o.expressionType(ctx.importExpr(reference))))], [o.TypeModifier.Const]), [o.StmtModifier.Final, o.StmtModifier.Exported]);\n        ctx.statements.push(ngModuleFactoryStmt);\n    }\n}\nfunction NgModuleCompiler_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgModuleCompiler.prototype.reflector;\n}\n//# sourceMappingURL=ng_module_compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { createNgModule } from \"./core\";\nimport { findLast } from \"./directive_resolver\";\nimport { stringify } from \"./util\";\n/**\n * Resolves types to {\\@link NgModule}.\n */\nexport class NgModuleResolver {\n    /**\n     * @param {?} _reflector\n     */\n    constructor(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isNgModule(type) { return this._reflector.annotations(type).some(createNgModule.isTypeOf); }\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    resolve(type, throwIfNotFound = true) {\n        const /** @type {?} */ ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(`No NgModule metadata found for '${stringify(type)}'.`);\n            }\n            return null;\n        }\n    }\n}\nfunction NgModuleResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgModuleResolver.prototype._reflector;\n}\n//# sourceMappingURL=ng_module_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { utf8Encode } from \"../util\";\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst /** @type {?} */ VERSION = 3;\nconst /** @type {?} */ JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nexport class SourceMapGenerator {\n    /**\n     * @param {?=} file\n     */\n    constructor(file = null) {\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    /**\n     * @param {?} url\n     * @param {?=} content\n     * @return {?}\n     */\n    addSource(url, content = null) {\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    }\n    /**\n     * @return {?}\n     */\n    addLine() {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    }\n    /**\n     * @param {?} col0\n     * @param {?=} sourceUrl\n     * @param {?=} sourceLine0\n     * @param {?=} sourceCol0\n     * @return {?}\n     */\n    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(`A line must be added before mappings can be added`);\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(`Unknown source file \"${sourceUrl}\"`);\n        }\n        if (col0 == null) {\n            throw new Error(`The column in the generated code must be provided`);\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(`Mapping should be added in output order`);\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(`The source location must be provided when a source url is provided`);\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });\n        return this;\n    }\n    /**\n     * @return {?}\n     */\n    get currentLine() { return this.lines.slice(-1)[0]; }\n    /**\n     * @return {?}\n     */\n    toJSON() {\n        if (!this.hasMappings) {\n            return null;\n        }\n        const /** @type {?} */ sourcesIndex = new Map();\n        const /** @type {?} */ sources = [];\n        const /** @type {?} */ sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(this.sourcesContent.get(url) || null);\n        });\n        let /** @type {?} */ mappings = '';\n        let /** @type {?} */ lastCol0 = 0;\n        let /** @type {?} */ lastSourceIndex = 0;\n        let /** @type {?} */ lastSourceLine0 = 0;\n        let /** @type {?} */ lastSourceCol0 = 0;\n        this.lines.forEach(segments => {\n            lastCol0 = 0;\n            mappings += segments\n                .map(segment => {\n                // zero-based starting column of the line in the generated code\n                let /** @type {?} */ segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the sources list\n                    segAsStr +=\n                        toBase64VLQ(/** @type {?} */ ((sourcesIndex.get(segment.sourceUrl))) - lastSourceIndex);\n                    lastSourceIndex = /** @type {?} */ ((sourcesIndex.get(segment.sourceUrl)));\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(/** @type {?} */ ((segment.sourceLine0)) - lastSourceLine0);\n                    lastSourceLine0 = /** @type {?} */ ((segment.sourceLine0));\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(/** @type {?} */ ((segment.sourceCol0)) - lastSourceCol0);\n                    lastSourceCol0 = /** @type {?} */ ((segment.sourceCol0));\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    }\n    /**\n     * @return {?}\n     */\n    toJsComment() {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    }\n}\nfunction SourceMapGenerator_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SourceMapGenerator.prototype.sourcesContent;\n    /** @type {?} */\n    SourceMapGenerator.prototype.lines;\n    /** @type {?} */\n    SourceMapGenerator.prototype.lastCol0;\n    /** @type {?} */\n    SourceMapGenerator.prototype.hasMappings;\n    /** @type {?} */\n    SourceMapGenerator.prototype.file;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nexport function toBase64String(value) {\n    let /** @type {?} */ b64 = '';\n    value = utf8Encode(value);\n    for (let /** @type {?} */ i = 0; i < value.length;) {\n        const /** @type {?} */ i1 = value.charCodeAt(i++);\n        const /** @type {?} */ i2 = value.charCodeAt(i++);\n        const /** @type {?} */ i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    let /** @type {?} */ out = '';\n    do {\n        let /** @type {?} */ digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nconst /** @type {?} */ B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(`Can only encode value in the range [0, 63]`);\n    }\n    return B64_DIGITS[value];\n}\n//# sourceMappingURL=source_map.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport * as o from \"./output_ast\";\nimport { SourceMapGenerator } from \"./source_map\";\nconst /** @type {?} */ _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst /** @type {?} */ _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst /** @type {?} */ _INDENT_WITH = '  ';\nexport const /** @type {?} */ CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const /** @type {?} */ CATCH_STACK_VAR = o.variable('stack', null, null);\n/**\n * @record\n */\nexport function OutputEmitter() { }\nfunction OutputEmitter_tsickle_Closure_declarations() {\n    /** @type {?} */\n    OutputEmitter.prototype.emitStatements;\n}\nclass _EmittedLine {\n    /**\n     * @param {?} indent\n     */\n    constructor(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n}\nfunction _EmittedLine_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _EmittedLine.prototype.partsLength;\n    /** @type {?} */\n    _EmittedLine.prototype.parts;\n    /** @type {?} */\n    _EmittedLine.prototype.srcSpans;\n    /** @type {?} */\n    _EmittedLine.prototype.indent;\n}\nexport class EmitterVisitorContext {\n    /**\n     * @param {?} _indent\n     */\n    constructor(_indent) {\n        this._indent = _indent;\n        this._classes = [];\n        this._preambleLineCount = 0;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    /**\n     * @return {?}\n     */\n    static createRoot() { return new EmitterVisitorContext(0); }\n    /**\n     * @return {?}\n     */\n    get _currentLine() { return this._lines[this._lines.length - 1]; }\n    /**\n     * @param {?=} from\n     * @param {?=} lastPart\n     * @return {?}\n     */\n    println(from, lastPart = '') {\n        this.print(from || null, lastPart, true);\n    }\n    /**\n     * @return {?}\n     */\n    lineIsEmpty() { return this._currentLine.parts.length === 0; }\n    /**\n     * @return {?}\n     */\n    lineLength() {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    }\n    /**\n     * @param {?} from\n     * @param {?} part\n     * @param {?=} newLine\n     * @return {?}\n     */\n    print(from, part, newLine = false) {\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    removeEmptyLastLine() {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    incIndent() {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    decIndent() {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    /**\n     * @param {?} clazz\n     * @return {?}\n     */\n    pushClass(clazz) { this._classes.push(clazz); }\n    /**\n     * @return {?}\n     */\n    popClass() { return /** @type {?} */ ((this._classes.pop())); }\n    /**\n     * @return {?}\n     */\n    get currentClass() {\n        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n    }\n    /**\n     * @return {?}\n     */\n    toSource() {\n        return this.sourceLines\n            .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n            .join('\\n');\n    }\n    /**\n     * @param {?} genFilePath\n     * @param {?=} startsAtLine\n     * @return {?}\n     */\n    toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n        const /** @type {?} */ map = new SourceMapGenerator(genFilePath);\n        let /** @type {?} */ firstOffsetMapped = false;\n        const /** @type {?} */ mapFirstOffsetIfNeeded = () => {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (let /** @type {?} */ i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach((line, lineIdx) => {\n            map.addLine();\n            const /** @type {?} */ spans = line.srcSpans;\n            const /** @type {?} */ parts = line.parts;\n            let /** @type {?} */ col0 = line.indent * _INDENT_WITH.length;\n            let /** @type {?} */ spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                const /** @type {?} */ span = /** @type {?} */ ((spans[spanIdx]));\n                const /** @type {?} */ source = span.start.file;\n                const /** @type {?} */ sourceLine = span.start.line;\n                const /** @type {?} */ sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    }\n    /**\n     * @param {?} count\n     * @return {?}\n     */\n    setPreambleLineCount(count) { return this._preambleLineCount = count; }\n    /**\n     * @param {?} line\n     * @param {?} column\n     * @return {?}\n     */\n    spanOf(line, column) {\n        const /** @type {?} */ emittedLine = this._lines[line - this._preambleLineCount];\n        if (emittedLine) {\n            let /** @type {?} */ columnsLeft = column - _createIndent(emittedLine.indent).length;\n            for (let /** @type {?} */ partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                const /** @type {?} */ part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    }\n    /**\n     * @return {?}\n     */\n    get sourceLines() {\n        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n            return this._lines.slice(0, -1);\n        }\n        return this._lines;\n    }\n}\nfunction EmitterVisitorContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    EmitterVisitorContext.prototype._lines;\n    /** @type {?} */\n    EmitterVisitorContext.prototype._classes;\n    /** @type {?} */\n    EmitterVisitorContext.prototype._preambleLineCount;\n    /** @type {?} */\n    EmitterVisitorContext.prototype._indent;\n}\n/**\n * @abstract\n */\nexport class AbstractEmitterVisitor {\n    /**\n     * @param {?} _escapeDollarInStrings\n     */\n    constructor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitExpressionStmt(stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReturnStmt(stmt, ctx) {\n        ctx.print(stmt, `return `);\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitIfStmt(stmt, ctx) {\n        ctx.print(stmt, `if (`);\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, `) {`);\n        const /** @type {?} */ hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, ` `);\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, ` `);\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, `} else {`);\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitThrowStmt(stmt, ctx) {\n        ctx.print(stmt, `throw `);\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, `;`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitCommentStmt(stmt, ctx) {\n        const /** @type {?} */ lines = stmt.comment.split('\\n');\n        lines.forEach((line) => { ctx.println(stmt, `// ${line}`); });\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitWriteVarExpr(expr, ctx) {\n        const /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, `${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitWriteKeyExpr(expr, ctx) {\n        const /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `[`);\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, `] = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitWritePropExpr(expr, ctx) {\n        const /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `.${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInvokeMethodExpr(expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        let /** @type {?} */ name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, `.${name}(`);\n        this.visitAllExpressions(expr.args, ctx, `,`);\n        ctx.print(expr, `)`);\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInvokeFunctionExpr(expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, `(`);\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, `)`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadVarExpr(ast, ctx) {\n        let /** @type {?} */ varName = /** @type {?} */ ((ast.name));\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case o.BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case o.BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case o.BuiltinVar.CatchError:\n                    varName = /** @type {?} */ ((CATCH_ERROR_VAR.name));\n                    break;\n                case o.BuiltinVar.CatchStack:\n                    varName = /** @type {?} */ ((CATCH_STACK_VAR.name));\n                    break;\n                default:\n                    throw new Error(`Unknown builtin variable ${ast.builtin}`);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInstantiateExpr(ast, ctx) {\n        ctx.print(ast, `new `);\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, `(`);\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, `)`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralExpr(ast, ctx) {\n        const /** @type {?} */ value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, `${value}`);\n        }\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitConditionalExpr(ast, ctx) {\n        ctx.print(ast, `(`);\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': '); /** @type {?} */\n        ((ast.falseCase)).visitExpression(this, ctx);\n        ctx.print(ast, `)`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitNotExpr(ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitAssertNotNullExpr(ast, ctx) {\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitBinaryOperatorExpr(ast, ctx) {\n        let /** @type {?} */ opStr;\n        switch (ast.operator) {\n            case o.BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case o.BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case o.BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case o.BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case o.BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case o.BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case o.BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case o.BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case o.BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case o.BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case o.BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case o.BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case o.BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case o.BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case o.BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        ctx.print(ast, `(`);\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, ` ${opStr} `);\n        ast.rhs.visitExpression(this, ctx);\n        ctx.print(ast, `)`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadPropExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `.`);\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadKeyExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `[`);\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, `]`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralArrayExpr(ast, ctx) {\n        ctx.print(ast, `[`);\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, `]`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralMapExpr(ast, ctx) {\n        ctx.print(ast, `{`);\n        this.visitAllObjects(entry => {\n            ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n            entry.value.visitExpression(this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, `}`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitCommaExpr(ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    }\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @return {?}\n     */\n    visitAllExpressions(expressions, ctx, separator) {\n        this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n    }\n    /**\n     * @template T\n     * @param {?} handler\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @return {?}\n     */\n    visitAllObjects(handler, expressions, ctx, separator) {\n        let /** @type {?} */ incrementedIndent = false;\n        for (let /** @type {?} */ i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    }\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitAllStatements(statements, ctx) {\n        statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n    }\n}\nfunction AbstractEmitterVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AbstractEmitterVisitor.prototype._escapeDollarInStrings;\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCastExpr = function (ast, context) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) { };\n    /**\n     * @abstract\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.getBuiltinMethodName = function (method) { };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) { };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) { };\n}\n/**\n * @param {?} input\n * @param {?} escapeDollar\n * @param {?=} alwaysQuote\n * @return {?}\n */\nexport function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n    if (input == null) {\n        return null;\n    }\n    const /** @type {?} */ body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return `\\\\${match[0]}`;\n        }\n    });\n    const /** @type {?} */ requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? `'${body}'` : body;\n}\n/**\n * @param {?} count\n * @return {?}\n */\nfunction _createIndent(count) {\n    let /** @type {?} */ res = '';\n    for (let /** @type {?} */ i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n//# sourceMappingURL=abstract_emitter.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { AbstractEmitterVisitor, CATCH_ERROR_VAR, CATCH_STACK_VAR, EmitterVisitorContext } from \"./abstract_emitter\";\nimport * as o from \"./output_ast\";\nconst /** @type {?} */ _debugFilePath = '/debug/lib';\n/**\n * @param {?} ast\n * @return {?}\n */\nexport function debugOutputAstAsTypeScript(ast) {\n    const /** @type {?} */ converter = new _TsEmitterVisitor();\n    const /** @type {?} */ ctx = EmitterVisitorContext.createRoot();\n    const /** @type {?} */ asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach((ast) => {\n        if (ast instanceof o.Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof o.Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof o.Type) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(`Don't know how to print debug info for ${ast}`);\n        }\n    });\n    return ctx.toSource();\n}\nexport class TypeScriptEmitter {\n    /**\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?=} preamble\n     * @param {?=} emitSourceMaps\n     * @param {?=} referenceFilter\n     * @return {?}\n     */\n    emitStatementsAndContext(genFilePath, stmts, preamble = '', emitSourceMaps = true, referenceFilter) {\n        const /** @type {?} */ converter = new _TsEmitterVisitor(referenceFilter);\n        const /** @type {?} */ ctx = EmitterVisitorContext.createRoot();\n        converter.visitAllStatements(stmts, ctx);\n        const /** @type {?} */ preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach((reexports, exportedModuleName) => {\n            const /** @type {?} */ reexportsCode = reexports.map(reexport => `${reexport.name} as ${reexport.as}`).join(',');\n            preambleLines.push(`export {${reexportsCode}} from '${exportedModuleName}';`);\n        });\n        converter.importsWithPrefixes.forEach((prefix, importedModuleName) => {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(`imp` +\n                `ort * as ${prefix} from '${importedModuleName}';`);\n        });\n        const /** @type {?} */ sm = emitSourceMaps ?\n            ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() :\n            '';\n        const /** @type {?} */ lines = [...preambleLines, ctx.toSource(), sm];\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        ctx.setPreambleLineCount(preambleLines.length);\n        return { sourceText: lines.join('\\n'), context: ctx };\n    }\n    /**\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?=} preamble\n     * @return {?}\n     */\n    emitStatements(genFilePath, stmts, preamble = '') {\n        return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n    }\n}\nclass _TsEmitterVisitor extends AbstractEmitterVisitor {\n    /**\n     * @param {?=} referenceFilter\n     */\n    constructor(referenceFilter) {\n        super(false);\n        this.referenceFilter = referenceFilter;\n        this.typeExpression = 0;\n        this.importsWithPrefixes = new Map();\n        this.reexports = new Map();\n    }\n    /**\n     * @param {?} t\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    visitType(t, ctx, defaultType = 'any') {\n        if (t) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralExpr(ast, ctx) {\n        const /** @type {?} */ value = ast.value;\n        if (value == null && ast.type != o.INFERRED_TYPE) {\n            ctx.print(ast, `(${value} as any)`);\n            return null;\n        }\n        return super.visitLiteralExpr(ast, ctx);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralArrayExpr(ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        const /** @type {?} */ result = super.visitLiteralArrayExpr(ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitExternalExpr(ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitAssertNotNullExpr(ast, ctx) {\n        const /** @type {?} */ result = super.visitAssertNotNullExpr(ast, ctx);\n        ctx.print(ast, '!');\n        return result;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareVarStmt(stmt, ctx) {\n        if (stmt.hasModifier(o.StmtModifier.Exported) && stmt.value instanceof o.ExternalExpr &&\n            !stmt.type) {\n            // check for a reexport\n            const { name, moduleName } = stmt.value.value;\n            if (moduleName) {\n                let /** @type {?} */ reexports = this.reexports.get(moduleName);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(moduleName, reexports);\n                }\n                reexports.push({ name: /** @type {?} */ ((name)), as: stmt.name });\n                return null;\n            }\n        }\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            ctx.print(stmt, `export `);\n        }\n        if (stmt.hasModifier(o.StmtModifier.Final)) {\n            ctx.print(stmt, `const`);\n        }\n        else {\n            ctx.print(stmt, `var`);\n        }\n        ctx.print(stmt, ` ${stmt.name}`);\n        this._printColonType(stmt.type, ctx);\n        ctx.print(stmt, ` = `);\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, `;`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitCastExpr(ast, ctx) {\n        ctx.print(ast, `(<`); /** @type {?} */\n        ((ast.type)).visitType(this, ctx);\n        ctx.print(ast, `>`);\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, `)`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInstantiateExpr(ast, ctx) {\n        ctx.print(ast, `new `);\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, `(`);\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, `)`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, ctx) {\n        ctx.pushClass(stmt);\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            ctx.print(stmt, `export `);\n        }\n        ctx.print(stmt, `class ${stmt.name}`);\n        if (stmt.parent != null) {\n            ctx.print(stmt, ` extends `);\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, ` {`);\n        ctx.incIndent();\n        stmt.fields.forEach((field) => this._visitClassField(field, ctx));\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach((getter) => this._visitClassGetter(getter, ctx));\n        stmt.methods.forEach((method) => this._visitClassMethod(method, ctx));\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        ctx.popClass();\n        return null;\n    }\n    /**\n     * @param {?} field\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassField(field, ctx) {\n        if (field.hasModifier(o.StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, `/*private*/ `);\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        ctx.println(null, `;`);\n    }\n    /**\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassGetter(getter, ctx) {\n        if (getter.hasModifier(o.StmtModifier.Private)) {\n            ctx.print(null, `private `);\n        }\n        ctx.print(null, `get ${getter.name}()`);\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, ` {`);\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, `}`);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassConstructor(stmt, ctx) {\n        ctx.print(stmt, `constructor(`);\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n    }\n    /**\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassMethod(method, ctx) {\n        if (method.hasModifier(o.StmtModifier.Private)) {\n            ctx.print(null, `private `);\n        }\n        ctx.print(null, `${method.name}(`);\n        this._visitParams(method.params, ctx);\n        ctx.print(null, `)`);\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, ` {`);\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, `}`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitFunctionExpr(ast, ctx) {\n        ctx.print(ast, `(`);\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, `)`);\n        this._printColonType(ast.type, ctx, 'void');\n        ctx.println(ast, ` => {`);\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, `}`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, ctx) {\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            ctx.print(stmt, `export `);\n        }\n        ctx.print(stmt, `function ${stmt.name}(`);\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, `)`);\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, ` {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitTryCatchStmt(stmt, ctx) {\n        ctx.println(stmt, `try {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `} catch (${CATCH_ERROR_VAR.name}) {`);\n        ctx.incIndent();\n        const /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR.set(CATCH_ERROR_VAR.prop('stack', null)).toDeclStmt(null, [\n                o.StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitBuiltintType(type, ctx) {\n        let /** @type {?} */ typeStr;\n        switch (type.name) {\n            case o.BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case o.BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case o.BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case o.BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case o.BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case o.BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            default:\n                throw new Error(`Unsupported builtin type ${type.name}`);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitExpressionType(ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    }\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitArrayType(type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, `[]`);\n        return null;\n    }\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitMapType(type, ctx) {\n        ctx.print(null, `{[key: string]:`);\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, `}`);\n        return null;\n    }\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    getBuiltinMethodName(method) {\n        let /** @type {?} */ name;\n        switch (method) {\n            case o.BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case o.BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case o.BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(`Unknown builtin method: ${method}`);\n        }\n        return name;\n    }\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitParams(params, ctx) {\n        this.visitAllObjects(param => {\n            ctx.print(null, param.name);\n            this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    }\n    /**\n     * @param {?} value\n     * @param {?} typeParams\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitIdentifier(value, typeParams, ctx) {\n        const { name, moduleName } = value;\n        if (this.referenceFilter && this.referenceFilter(value)) {\n            ctx.print(null, '(null as any)');\n            return;\n        }\n        if (moduleName) {\n            let /** @type {?} */ prefix = this.importsWithPrefixes.get(moduleName);\n            if (prefix == null) {\n                prefix = `i${this.importsWithPrefixes.size}`;\n                this.importsWithPrefixes.set(moduleName, prefix);\n            }\n            ctx.print(null, `${prefix}.`);\n        }\n        ctx.print(null, /** @type {?} */ ((name)));\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            const /** @type {?} */ suppliedParameters = typeParams || [];\n            if (suppliedParameters.length > 0) {\n                ctx.print(null, `<`);\n                this.visitAllObjects(type => type.visitType(this, ctx), /** @type {?} */ ((typeParams)), ctx, ',');\n                ctx.print(null, `>`);\n            }\n        }\n    }\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _printColonType(type, ctx, defaultType) {\n        if (type !== o.INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    }\n}\nfunction _TsEmitterVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _TsEmitterVisitor.prototype.typeExpression;\n    /** @type {?} */\n    _TsEmitterVisitor.prototype.importsWithPrefixes;\n    /** @type {?} */\n    _TsEmitterVisitor.prototype.reexports;\n    /** @type {?} */\n    _TsEmitterVisitor.prototype.referenceFilter;\n}\n//# sourceMappingURL=ts_emitter.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { createPipe } from \"./core\";\nimport { findLast } from \"./directive_resolver\";\nimport { resolveForwardRef, stringify } from \"./util\";\n/**\n * Resolve a `Type` for {\\@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n */\nexport class PipeResolver {\n    /**\n     * @param {?} _reflector\n     */\n    constructor(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    isPipe(type) {\n        const /** @type {?} */ typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\n    }\n    /**\n     * Return {\\@link Pipe} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    resolve(type, throwIfNotFound = true) {\n        const /** @type {?} */ metas = this._reflector.annotations(resolveForwardRef(type));\n        if (metas) {\n            const /** @type {?} */ annotation = findLast(metas, createPipe.isTypeOf);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(`No Pipe decorator found on ${stringify(type)}`);\n        }\n        return null;\n    }\n}\nfunction PipeResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PipeResolver.prototype._reflector;\n}\n//# sourceMappingURL=pipe_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { SecurityContext } from \"../core\";\n/**\n * Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'.\n */\nexport const /** @type {?} */ SECURITY_SCHEMA = {};\n/**\n * @param {?} ctx\n * @param {?} specs\n * @return {?}\n */\nfunction registerContext(ctx, specs) {\n    for (const /** @type {?} */ spec of specs)\n        SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n// Case is insignificant below, all element and attribute names are lower-cased for lookup.\nregisterContext(SecurityContext.HTML, [\n    'iframe|srcdoc',\n    '*|innerHTML',\n    '*|outerHTML',\n]);\nregisterContext(SecurityContext.STYLE, ['*|style']);\n// NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\nregisterContext(SecurityContext.URL, [\n    '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n    'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n    'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n    'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n]);\nregisterContext(SecurityContext.RESOURCE_URL, [\n    'applet|code',\n    'applet|codebase',\n    'base|href',\n    'embed|src',\n    'frame|src',\n    'head|profile',\n    'html|manifest',\n    'iframe|src',\n    'link|href',\n    'media|src',\n    'object|codebase',\n    'object|data',\n    'script|src',\n]);\n//# sourceMappingURL=dom_security_schema.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nexport class ElementSchemaRegistry {\n}\nfunction ElementSchemaRegistry_tsickle_Closure_declarations() {\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} elementName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.securityContext = function (elementName, propName, isAttribute) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.allKnownElementNames = function () { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateProperty = function (name) { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateAttribute = function (name) { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) { };\n    /**\n     * @abstract\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) { };\n}\n//# sourceMappingURL=element_schema_registry.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SecurityContext } from \"../core\";\nimport { isNgContainer, isNgContent } from \"../ml_parser/tags\";\nimport { dashCaseToCamelCase } from \"../util\";\nimport { SECURITY_SCHEMA } from \"./dom_security_schema\";\nimport { ElementSchemaRegistry } from \"./element_schema_registry\";\nconst /** @type {?} */ BOOLEAN = 'boolean';\nconst /** @type {?} */ NUMBER = 'number';\nconst /** @type {?} */ STRING = 'string';\nconst /** @type {?} */ OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\nconst /** @type {?} */ SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nconst /** @type {?} */ _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nexport class DomElementSchemaRegistry extends ElementSchemaRegistry {\n    constructor() {\n        super();\n        this._schema = {};\n        SCHEMA.forEach(encodedType => {\n            const /** @type {?} */ type = {};\n            const [strType, strProperties] = encodedType.split('|');\n            const /** @type {?} */ properties = strProperties.split(',');\n            const [typeNames, superName] = strType.split('^');\n            typeNames.split(',').forEach(tag => this._schema[tag.toLowerCase()] = type);\n            const /** @type {?} */ superType = superName && this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach((prop) => { type[prop] = superType[prop]; });\n            }\n            properties.forEach((property) => {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n    }\n    /**\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    hasProperty(tagName, propName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        const /** @type {?} */ elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    }\n    /**\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    hasElement(tagName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    }\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is white list based. All attributes in the schema above are assumed to have the\n     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\n     * attack vectors are assigned their appropriate context.\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    securityContext(tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        let /** @type {?} */ ctx = SECURITY_SCHEMA[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA['*|' + propName];\n        return ctx ? ctx : SecurityContext.NONE;\n    }\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    getMappedPropName(propName) { return _ATTR_TO_PROP[propName] || propName; }\n    /**\n     * @return {?}\n     */\n    getDefaultComponentElementName() { return 'ng-component'; }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    validateProperty(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const /** @type {?} */ msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...` +\n                `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n                ` current module.`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    validateAttribute(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const /** @type {?} */ msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    /**\n     * @return {?}\n     */\n    allKnownElementNames() { return Object.keys(this._schema); }\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    normalizeAnimationStyleProperty(propName) {\n        return dashCaseToCamelCase(propName);\n    }\n    /**\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n        let /** @type {?} */ unit = '';\n        const /** @type {?} */ strVal = val.toString().trim();\n        let /** @type {?} */ errorMsg = /** @type {?} */ ((null));\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                const /** @type {?} */ valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    }\n}\nfunction DomElementSchemaRegistry_tsickle_Closure_declarations() {\n    /** @type {?} */\n    DomElementSchemaRegistry.prototype._schema;\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\n//# sourceMappingURL=dom_element_schema_registry.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport class ShadowCss {\n    constructor() {\n        this.strictStyling = true;\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} selector\n     * @param {?=} hostSelector\n     * @return {?}\n     */\n    shimCssText(cssText, selector, hostSelector = '') {\n        const /** @type {?} */ sourceMappingUrl = extractSourceMappingUrl(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _insertDirectives(cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _insertPolyfillDirectivesInCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function (...m) { return m[2] + '{'; });\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _insertPolyfillRulesInCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, (...m) => {\n            const /** @type {?} */ rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    _scopeCssText(cssText, scopeSelector, hostSelector) {\n        const /** @type {?} */ unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _extractUnscopedRulesFromCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        let /** @type {?} */ r = '';\n        let /** @type {?} */ m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            const /** @type {?} */ rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _convertColonHost(cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _convertColonHostContext(cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} regExp\n     * @param {?} partReplacer\n     * @return {?}\n     */\n    _convertColonRule(cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function (...m) {\n            if (m[2]) {\n                const /** @type {?} */ parts = m[2].split(',');\n                const /** @type {?} */ r = [];\n                for (let /** @type {?} */ i = 0; i < parts.length; i++) {\n                    const /** @type {?} */ p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    }\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    _colonHostContextPartReplacer(host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    }\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    _colonHostPartReplacer(host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    }\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    _convertShadowDOMSelectors(cssText) {\n        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    _scopeSelectors(cssText, scopeSelector, hostSelector) {\n        return processRules(cssText, (rule) => {\n            let /** @type {?} */ selector = rule.selector;\n            let /** @type {?} */ content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    }\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @param {?} strict\n     * @return {?}\n     */\n    _scopeSelector(selector, scopeSelector, hostSelector, strict) {\n        return selector.split(',')\n            .map(part => part.trim().split(_shadowDeepSelectors))\n            .map((deepParts) => {\n            const [shallowPart, ...otherParts] = deepParts;\n            const /** @type {?} */ applyScope = (shallowPart) => {\n                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n            .join(', ');\n    }\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    _selectorNeedsScoping(selector, scopeSelector) {\n        const /** @type {?} */ re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    }\n    /**\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    _makeScopeMatcher(scopeSelector) {\n        const /** @type {?} */ lre = /\\[/g;\n        const /** @type {?} */ rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    }\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    _applySelectorScope(selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    }\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            const /** @type {?} */ replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {\n                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {\n                    return before + replaceBy + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    }\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {\n        const /** @type {?} */ isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n        const /** @type {?} */ attrName = '[' + scopeSelector + ']';\n        const /** @type {?} */ _scopeSelectorPart = (p) => {\n            let /** @type {?} */ scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                const /** @type {?} */ t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    const /** @type {?} */ matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        const /** @type {?} */ safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        let /** @type {?} */ scopedSelector = '';\n        let /** @type {?} */ startIndex = 0;\n        let /** @type {?} */ res;\n        const /** @type {?} */ sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        const /** @type {?} */ hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        let /** @type {?} */ shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            const /** @type {?} */ separator = res[1];\n            const /** @type {?} */ part = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n            const /** @type {?} */ scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n            scopedSelector += `${scopedPart} ${separator} `;\n            startIndex = sep.lastIndex;\n        }\n        const /** @type {?} */ part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    _insertPolyfillHostInCssText(selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    }\n}\nfunction ShadowCss_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ShadowCss.prototype.strictStyling;\n}\nclass SafeSelector {\n    /**\n     * @param {?} selector\n     */\n    constructor(selector) {\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, (_, keep) => {\n            const /** @type {?} */ replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(keep);\n            this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n            const /** @type {?} */ replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(exp);\n            this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    restore(content) {\n        return content.replace(/__ph-(\\d+)__/g, (ph, index) => this.placeholders[+index]);\n    }\n    /**\n     * @return {?}\n     */\n    content() { return this._content; }\n}\nfunction SafeSelector_tsickle_Closure_declarations() {\n    /** @type {?} */\n    SafeSelector.prototype.placeholders;\n    /** @type {?} */\n    SafeSelector.prototype.index;\n    /** @type {?} */\n    SafeSelector.prototype._content;\n}\nconst /** @type {?} */ _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst /** @type {?} */ _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst /** @type {?} */ _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst /** @type {?} */ _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst /** @type {?} */ _polyfillHostContext = '-shadowcsscontext';\nconst /** @type {?} */ _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst /** @type {?} */ _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nconst /** @type {?} */ _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nconst /** @type {?} */ _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst /** @type {?} */ _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst /** @type {?} */ _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst /** @type {?} */ _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst /** @type {?} */ _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nconst /** @type {?} */ _polyfillHostRe = /-shadowcsshost/gim;\nconst /** @type {?} */ _colonHostRe = /:host/gim;\nconst /** @type {?} */ _colonHostContextRe = /:host-context/gim;\nconst /** @type {?} */ _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\n// all comments except inline source mapping\nconst /** @type {?} */ _sourceMappingUrlRe = /\\/\\*\\s*#\\s*sourceMappingURL=[\\s\\S]+?\\*\\//;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction extractSourceMappingUrl(input) {\n    const /** @type {?} */ matcher = input.match(_sourceMappingUrlRe);\n    return matcher ? matcher[0] : '';\n}\nconst /** @type {?} */ _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst /** @type {?} */ _curlyRe = /([{}])/g;\nconst /** @type {?} */ OPEN_CURLY = '{';\nconst /** @type {?} */ CLOSE_CURLY = '}';\nconst /** @type {?} */ BLOCK_PLACEHOLDER = '%BLOCK%';\nexport class CssRule {\n    /**\n     * @param {?} selector\n     * @param {?} content\n     */\n    constructor(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n}\nfunction CssRule_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CssRule.prototype.selector;\n    /** @type {?} */\n    CssRule.prototype.content;\n}\n/**\n * @param {?} input\n * @param {?} ruleCallback\n * @return {?}\n */\nexport function processRules(input, ruleCallback) {\n    const /** @type {?} */ inputWithEscapedBlocks = escapeBlocks(input);\n    let /** @type {?} */ nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {\n        const /** @type {?} */ selector = m[2];\n        let /** @type {?} */ content = '';\n        let /** @type {?} */ suffix = m[4];\n        let /** @type {?} */ contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        const /** @type {?} */ rule = ruleCallback(new CssRule(selector, content));\n        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n    });\n}\nclass StringWithEscapedBlocks {\n    /**\n     * @param {?} escapedString\n     * @param {?} blocks\n     */\n    constructor(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n}\nfunction StringWithEscapedBlocks_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StringWithEscapedBlocks.prototype.escapedString;\n    /** @type {?} */\n    StringWithEscapedBlocks.prototype.blocks;\n}\n/**\n * @param {?} input\n * @return {?}\n */\nfunction escapeBlocks(input) {\n    const /** @type {?} */ inputParts = input.split(_curlyRe);\n    const /** @type {?} */ resultParts = [];\n    const /** @type {?} */ escapedBlocks = [];\n    let /** @type {?} */ bracketCount = 0;\n    let /** @type {?} */ currentBlockParts = [];\n    for (let /** @type {?} */ partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        const /** @type {?} */ part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n//# sourceMappingURL=shadow_css.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CompileStylesheetMetadata, identifierModuleUrl, identifierName } from \"./compile_metadata\";\nimport { ViewEncapsulation } from \"./core\";\nimport * as o from \"./output/output_ast\";\nimport { ShadowCss } from \"./shadow_css\";\nconst /** @type {?} */ COMPONENT_VARIABLE = '%COMP%';\nconst /** @type {?} */ HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst /** @type {?} */ CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nexport class StylesCompileDependency {\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} setValue\n     */\n    constructor(name, moduleUrl, setValue) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.setValue = setValue;\n    }\n}\nfunction StylesCompileDependency_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StylesCompileDependency.prototype.name;\n    /** @type {?} */\n    StylesCompileDependency.prototype.moduleUrl;\n    /** @type {?} */\n    StylesCompileDependency.prototype.setValue;\n}\nexport class CompiledStylesheet {\n    /**\n     * @param {?} outputCtx\n     * @param {?} stylesVar\n     * @param {?} dependencies\n     * @param {?} isShimmed\n     * @param {?} meta\n     */\n    constructor(outputCtx, stylesVar, dependencies, isShimmed, meta) {\n        this.outputCtx = outputCtx;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n}\nfunction CompiledStylesheet_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompiledStylesheet.prototype.outputCtx;\n    /** @type {?} */\n    CompiledStylesheet.prototype.stylesVar;\n    /** @type {?} */\n    CompiledStylesheet.prototype.dependencies;\n    /** @type {?} */\n    CompiledStylesheet.prototype.isShimmed;\n    /** @type {?} */\n    CompiledStylesheet.prototype.meta;\n}\nexport class StyleCompiler {\n    /**\n     * @param {?} _urlResolver\n     */\n    constructor(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} comp\n     * @return {?}\n     */\n    compileComponent(outputCtx, comp) {\n        const /** @type {?} */ template = /** @type {?} */ ((comp.template));\n        return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\n            styles: template.styles,\n            styleUrls: template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), this.needsStyleShim(comp), true);\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @param {?=} shim\n     * @return {?}\n     */\n    compileStyles(outputCtx, comp, stylesheet, shim = this.needsStyleShim(comp)) {\n        return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n    }\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    needsStyleShim(comp) {\n        return /** @type {?} */ ((comp.template)).encapsulation === ViewEncapsulation.Emulated;\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @param {?} shim\n     * @param {?} isComponentStylesheet\n     * @return {?}\n     */\n    _compileStyles(outputCtx, comp, stylesheet, shim, isComponentStylesheet) {\n        const /** @type {?} */ styleExpressions = stylesheet.styles.map(plainStyle => o.literal(this._shimIfNeeded(plainStyle, shim)));\n        const /** @type {?} */ dependencies = [];\n        stylesheet.styleUrls.forEach((styleUrl) => {\n            const /** @type {?} */ exprIndex = styleExpressions.length;\n            // Note: This placeholder will be filled later.\n            styleExpressions.push(/** @type {?} */ ((null)));\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, (value) => styleExpressions[exprIndex] = outputCtx.importExpr(value)));\n        });\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        const /** @type {?} */ stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        const /** @type {?} */ stmt = o.variable(stylesVar)\n            .set(o.literalArr(styleExpressions, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const])))\n            .toDeclStmt(null, isComponentStylesheet ? [o.StmtModifier.Final] : [\n            o.StmtModifier.Final, o.StmtModifier.Exported\n        ]);\n        outputCtx.statements.push(stmt);\n        return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n    }\n    /**\n     * @param {?} style\n     * @param {?} shim\n     * @return {?}\n     */\n    _shimIfNeeded(style, shim) {\n        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n    }\n}\nfunction StyleCompiler_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StyleCompiler.prototype._shadowCss;\n    /** @type {?} */\n    StyleCompiler.prototype._urlResolver;\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction getStylesVarName(component) {\n    let /** @type {?} */ result = `styles`;\n    if (component) {\n        result += `_${identifierName(component.type)}`;\n    }\n    return result;\n}\n//# sourceMappingURL=style_compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as html from \"./ast\";\nimport { ParseTreeResult } from \"./parser\";\nimport { NGSP_UNICODE } from \"./tags\";\nexport const /** @type {?} */ PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst /** @type {?} */ SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst /** @type {?} */ WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst /** @type {?} */ NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst /** @type {?} */ WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\n/**\n * @param {?} attrs\n * @return {?}\n */\nfunction hasPreserveWhitespacesAttr(attrs) {\n    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n * @param {?} value\n * @return {?}\n */\nexport function replaceNgsp(value) {\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nclass WhitespaceVisitor {\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(element, context) {\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n            // don't descent into elements where we need to preserve whitespaces\n            // but still visit all attributes to eliminate one used as a market to preserve WS\n            return new html.Element(element.name, html.visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n        }\n        return new html.Element(element.name, element.attrs, html.visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) {\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) {\n        const /** @type {?} */ isNotBlank = text.value.match(NO_WS_REGEXP);\n        if (isNotBlank) {\n            return new html.Text(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan);\n        }\n        return null;\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { return comment; }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(expansion, context) { return expansion; }\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(expansionCase, context) { return expansionCase; }\n}\n/**\n * @param {?} htmlAstWithErrors\n * @return {?}\n */\nexport function removeWhitespaces(htmlAstWithErrors) {\n    return new ParseTreeResult(html.visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\n//# sourceMappingURL=html_whitespaces.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ParseError } from \"../parse_util\";\nimport * as html from \"./ast\";\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nconst /** @type {?} */ PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n * @param {?} nodes\n * @return {?}\n */\nexport function expandNodes(nodes) {\n    const /** @type {?} */ expander = new _Expander();\n    return new ExpansionResult(html.visitAll(expander, nodes), expander.isExpanded, expander.errors);\n}\nexport class ExpansionResult {\n    /**\n     * @param {?} nodes\n     * @param {?} expanded\n     * @param {?} errors\n     */\n    constructor(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n}\nfunction ExpansionResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ExpansionResult.prototype.nodes;\n    /** @type {?} */\n    ExpansionResult.prototype.expanded;\n    /** @type {?} */\n    ExpansionResult.prototype.errors;\n}\nexport class ExpansionError extends ParseError {\n    /**\n     * @param {?} span\n     * @param {?} errorMsg\n     */\n    constructor(span, errorMsg) { super(span, errorMsg); }\n}\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * \\@internal\n */\nclass _Expander {\n    constructor() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(element, context) {\n        return new html.Element(element.name, element.attrs, html.visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) { return attribute; }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(text, context) { return text; }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { return comment; }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    }\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(icuCase, context) {\n        throw new Error('Should not be reached');\n    }\n}\nfunction _Expander_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _Expander.prototype.isExpanded;\n    /** @type {?} */\n    _Expander.prototype.errors;\n}\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandPluralForm(ast, errors) {\n    const /** @type {?} */ children = ast.cases.map(c => {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, `Plural cases should be \"=<number>\" or one of ${PLURAL_CASES.join(\", \")}`));\n        }\n        const /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push(...expansionResult.errors);\n        return new html.Element(`ng-template`, [new html.Attribute('ngPluralCase', `${c.value}`, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    const /** @type {?} */ switchAttr = new html.Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new html.Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandDefaultForm(ast, errors) {\n    const /** @type {?} */ children = ast.cases.map(c => {\n        const /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push(...expansionResult.errors);\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new html.Element(`ng-template`, [new html.Attribute('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new html.Element(`ng-template`, [new html.Attribute('ngSwitchCase', `${c.value}`, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    const /** @type {?} */ switchAttr = new html.Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new html.Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n//# sourceMappingURL=icu_ast_expander.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { SecurityContext } from \"../core\";\nimport { EmptyExpr, RecursiveAstVisitor } from \"../expression_parser/ast\";\nimport { mergeNsAndName } from \"../ml_parser/tags\";\nimport { ParseError, ParseErrorLevel, ParseSourceSpan } from \"../parse_util\";\nimport { CssSelector } from \"../selector\";\nimport { splitAtColon, splitAtPeriod } from \"../util\";\nimport { BoundElementPropertyAst, BoundEventAst, PropertyBindingType, VariableAst } from \"./template_ast\";\nconst /** @type {?} */ PROPERTY_PARTS_SEPARATOR = '.';\nconst /** @type {?} */ ATTRIBUTE_PREFIX = 'attr';\nconst /** @type {?} */ CLASS_PREFIX = 'class';\nconst /** @type {?} */ STYLE_PREFIX = 'style';\nconst /** @type {?} */ ANIMATE_PROP_PREFIX = 'animate-';\n/** @enum {number} */\nconst BoundPropertyType = {\n    DEFAULT: 0,\n    LITERAL_ATTR: 1,\n    ANIMATION: 2,\n};\nexport { BoundPropertyType };\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n/**\n * Represents a parsed property.\n */\nexport class BoundProperty {\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} sourceSpan\n     */\n    constructor(name, expression, type, sourceSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n        this.isLiteral = this.type === BoundPropertyType.LITERAL_ATTR;\n        this.isAnimation = this.type === BoundPropertyType.ANIMATION;\n    }\n}\nfunction BoundProperty_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BoundProperty.prototype.isLiteral;\n    /** @type {?} */\n    BoundProperty.prototype.isAnimation;\n    /** @type {?} */\n    BoundProperty.prototype.name;\n    /** @type {?} */\n    BoundProperty.prototype.expression;\n    /** @type {?} */\n    BoundProperty.prototype.type;\n    /** @type {?} */\n    BoundProperty.prototype.sourceSpan;\n}\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n    /**\n     * @param {?} _exprParser\n     * @param {?} _interpolationConfig\n     * @param {?} _schemaRegistry\n     * @param {?} pipes\n     * @param {?} _targetErrors\n     */\n    constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this._targetErrors = _targetErrors;\n        this.pipesByName = new Map();\n        this._usedPipes = new Map();\n        pipes.forEach(pipe => this.pipesByName.set(pipe.name, pipe));\n    }\n    /**\n     * @return {?}\n     */\n    getUsedPipes() { return Array.from(this._usedPipes.values()); }\n    /**\n     * @param {?} dirMeta\n     * @param {?} elementSelector\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {\n        if (dirMeta.hostProperties) {\n            const /** @type {?} */ boundProps = [];\n            Object.keys(dirMeta.hostProperties).forEach(propName => {\n                const /** @type {?} */ expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n                }\n                else {\n                    this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n                }\n            });\n            return boundProps.map((prop) => this.createElementPropertyAst(elementSelector, prop));\n        }\n        return null;\n    }\n    /**\n     * @param {?} dirMeta\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    createDirectiveHostEventAsts(dirMeta, sourceSpan) {\n        if (dirMeta.hostListeners) {\n            const /** @type {?} */ targetEventAsts = [];\n            Object.keys(dirMeta.hostListeners).forEach(propName => {\n                const /** @type {?} */ expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts);\n                }\n                else {\n                    this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n                }\n            });\n            return targetEventAsts;\n        }\n        return null;\n    }\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    parseInterpolation(value, sourceSpan) {\n        const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            const /** @type {?} */ ast = /** @type {?} */ ((this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig)));\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (/** @type {?} */ e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    }\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetVars\n     * @return {?}\n     */\n    parseInlineTemplateBinding(prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {\n        const /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n        for (let /** @type {?} */ i = 0; i < bindings.length; i++) {\n            const /** @type {?} */ binding = bindings[i];\n            if (binding.keyIsVar) {\n                targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n            }\n            else if (binding.expression) {\n                this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([binding.key, '']);\n                this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n        }\n    }\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _parseTemplateBindings(prefixToken, value, sourceSpan) {\n        const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            const /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach((binding) => {\n                if (binding.expression) {\n                    this._checkPipes(binding.expression, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach((warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n            return bindingsResult.templateBindings;\n        }\n        catch (/** @type {?} */ e) {\n            this._reportError(`${e}`, sourceSpan);\n            return [];\n        }\n    }\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    parseLiteralAttr(name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        if (_isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                    ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));\n        }\n    }\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} isHost\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    parsePropertyBinding(name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {\n        let /** @type {?} */ isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (_isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\n        }\n    }\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    parsePropertyInterpolation(name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        const /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @param {?} name\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    _parsePropertyAst(name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, /** @type {?} */ ((ast.source))]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n    }\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    _parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        const /** @type {?} */ ast = this._parseBinding(expression || 'undefined', false, sourceSpan);\n        targetMatchableAttrs.push([name, /** @type {?} */ ((ast.source))]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n    }\n    /**\n     * @param {?} value\n     * @param {?} isHostBinding\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _parseBinding(value, isHostBinding, sourceSpan) {\n        const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            const /** @type {?} */ ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (/** @type {?} */ e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    }\n    /**\n     * @param {?} elementSelector\n     * @param {?} boundProp\n     * @return {?}\n     */\n    createElementPropertyAst(elementSelector, boundProp) {\n        if (boundProp.isAnimation) {\n            return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan);\n        }\n        let /** @type {?} */ unit = null;\n        let /** @type {?} */ bindingType = /** @type {?} */ ((undefined));\n        let /** @type {?} */ boundPropertyName = null;\n        const /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        let /** @type {?} */ securityContexts = /** @type {?} */ ((undefined));\n        // Check check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts[1];\n                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                const /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    const /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    const /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = PropertyBindingType.Attribute;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Class;\n                securityContexts = [SecurityContext.NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Style;\n                securityContexts = [SecurityContext.STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);\n            bindingType = PropertyBindingType.Property;\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n        }\n        return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);\n    }\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        if (_isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n        }\n        else {\n            this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n        }\n    }\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    _parseAnimationEvent(name, expression, sourceSpan, targetEvents) {\n        const /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n        const /** @type {?} */ eventName = matches[0];\n        const /** @type {?} */ phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    const /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n                    targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n                    break;\n                default:\n                    this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n        }\n    }\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    _parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        const [target, eventName] = splitAtColon(name, [/** @type {?} */ ((null)), name]);\n        const /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n        targetMatchableAttrs.push([/** @type {?} */ ((name)), /** @type {?} */ ((ast.source))]);\n        targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    }\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _parseAction(value, sourceSpan) {\n        const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            const /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(`Empty expressions are not allowed`, sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (/** @type {?} */ e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    }\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    }\n    /**\n     * @param {?} errors\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _reportExpressionParserErrors(errors, sourceSpan) {\n        for (const /** @type {?} */ error of errors) {\n            this._reportError(error.message, sourceSpan);\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _checkPipes(ast, sourceSpan) {\n        if (ast) {\n            const /** @type {?} */ collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach((ast, pipeName) => {\n                const /** @type {?} */ pipeMeta = this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    }\n    /**\n     * @param {?} propName the name of the property / attribute\n     * @param {?} sourceSpan\n     * @param {?} isAttr true when binding to an attribute\n     * @return {?}\n     */\n    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n        const /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(/** @type {?} */ ((report.msg)), sourceSpan, ParseErrorLevel.ERROR);\n        }\n    }\n}\nfunction BindingParser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BindingParser.prototype.pipesByName;\n    /** @type {?} */\n    BindingParser.prototype._usedPipes;\n    /** @type {?} */\n    BindingParser.prototype._exprParser;\n    /** @type {?} */\n    BindingParser.prototype._interpolationConfig;\n    /** @type {?} */\n    BindingParser.prototype._schemaRegistry;\n    /** @type {?} */\n    BindingParser.prototype._targetErrors;\n}\nexport class PipeCollector extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.pipes = new Map();\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPipe(ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n}\nfunction PipeCollector_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PipeCollector.prototype.pipes;\n}\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name) {\n    return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nexport function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    const /** @type {?} */ ctxs = [];\n    CssSelector.parse(selector).forEach((selector) => {\n        const /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        const /** @type {?} */ notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n            .map((selector) => selector.element));\n        const /** @type {?} */ possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));\n        ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));\n    });\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n//# sourceMappingURL=binding_parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { identifierName } from \"../compile_metadata\";\nimport { ASTWithSource, EmptyExpr } from \"../expression_parser/ast\";\nimport { Identifiers, createTokenForExternalReference, createTokenForReference } from \"../identifiers\";\nimport * as html from \"../ml_parser/ast\";\nimport { ParseTreeResult } from \"../ml_parser/html_parser\";\nimport { removeWhitespaces, replaceNgsp } from \"../ml_parser/html_whitespaces\";\nimport { expandNodes } from \"../ml_parser/icu_ast_expander\";\nimport { InterpolationConfig } from \"../ml_parser/interpolation_config\";\nimport { isNgTemplate, splitNsName } from \"../ml_parser/tags\";\nimport { ParseError, ParseErrorLevel, ParseSourceSpan } from \"../parse_util\";\nimport { ProviderElementContext, ProviderViewContext } from \"../provider_analyzer\";\nimport { CssSelector, SelectorMatcher } from \"../selector\";\nimport { isStyleUrlResolvable } from \"../style_url_resolver\";\nimport { syntaxError } from \"../util\";\nimport { BindingParser } from \"./binding_parser\";\nimport { AttrAst, BoundDirectivePropertyAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ReferenceAst, TextAst, VariableAst, templateVisitAll } from \"./template_ast\";\nimport { PreparsedElementType, preparseElement } from \"./template_preparser\";\nconst /** @type {?} */ BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nconst /** @type {?} */ KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst /** @type {?} */ KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst /** @type {?} */ KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst /** @type {?} */ KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst /** @type {?} */ KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst /** @type {?} */ KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst /** @type {?} */ IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst /** @type {?} */ IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst /** @type {?} */ IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst /** @type {?} */ IDENT_EVENT_IDX = 10;\n// deprecated in 4.x\nconst /** @type {?} */ TEMPLATE_ELEMENT = 'template';\n// deprecated in 4.x\nconst /** @type {?} */ TEMPLATE_ATTR = 'template';\nconst /** @type {?} */ TEMPLATE_ATTR_PREFIX = '*';\nconst /** @type {?} */ CLASS_ATTR = 'class';\nconst /** @type {?} */ TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\nconst /** @type {?} */ TEMPLATE_ELEMENT_DEPRECATION_WARNING = 'The <template> element is deprecated. Use <ng-template> instead';\nconst /** @type {?} */ TEMPLATE_ATTR_DEPRECATION_WARNING = 'The template attribute is deprecated. Use an ng-template element instead.';\nlet /** @type {?} */ warningCounts = {};\n/**\n * @param {?} warnings\n * @return {?}\n */\nfunction warnOnlyOnce(warnings) {\n    return (error) => {\n        if (warnings.indexOf(error.msg) !== -1) {\n            warningCounts[error.msg] = (warningCounts[error.msg] || 0) + 1;\n            return warningCounts[error.msg] <= 1;\n        }\n        return true;\n    };\n}\nexport class TemplateParseError extends ParseError {\n    /**\n     * @param {?} message\n     * @param {?} span\n     * @param {?} level\n     */\n    constructor(message, span, level) {\n        super(span, message, level);\n    }\n}\nexport class TemplateParseResult {\n    /**\n     * @param {?=} templateAst\n     * @param {?=} usedPipes\n     * @param {?=} errors\n     */\n    constructor(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n}\nfunction TemplateParseResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TemplateParseResult.prototype.templateAst;\n    /** @type {?} */\n    TemplateParseResult.prototype.usedPipes;\n    /** @type {?} */\n    TemplateParseResult.prototype.errors;\n}\nexport class TemplateParser {\n    /**\n     * @param {?} _config\n     * @param {?} _reflector\n     * @param {?} _exprParser\n     * @param {?} _schemaRegistry\n     * @param {?} _htmlParser\n     * @param {?} _console\n     * @param {?} transforms\n     */\n    constructor(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._reflector = _reflector;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @param {?} preserveWhitespaces\n     * @return {?}\n     */\n    parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n        const /** @type {?} */ result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n        const /** @type {?} */ warnings = /** @type {?} */ ((result.errors)).filter(error => error.level === ParseErrorLevel.WARNING).filter(warnOnlyOnce([TEMPLATE_ATTR_DEPRECATION_WARNING, TEMPLATE_ELEMENT_DEPRECATION_WARNING]));\n        const /** @type {?} */ errors = /** @type {?} */ ((result.errors)).filter(error => error.level === ParseErrorLevel.ERROR);\n        if (warnings.length > 0) {\n            this._console.warn(`Template parse warnings:\\n${warnings.join('\\n')}`);\n        }\n        if (errors.length > 0) {\n            const /** @type {?} */ errorString = errors.join('\\n');\n            throw syntaxError(`Template parse errors:\\n${errorString}`, errors);\n        }\n        return { template: /** @type {?} */ ((result.templateAst)), pipes: /** @type {?} */ ((result.usedPipes)) };\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @param {?} preserveWhitespaces\n     * @return {?}\n     */\n    tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n        let /** @type {?} */ htmlParseResult = typeof template === 'string' ? /** @type {?} */ ((this._htmlParser)).parse(template, templateUrl, true, this.getInterpolationConfig(component)) :\n            template;\n        if (!preserveWhitespaces) {\n            htmlParseResult = removeWhitespaces(htmlParseResult);\n        }\n        return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n    }\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?} component\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @return {?}\n     */\n    tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {\n        let /** @type {?} */ result;\n        const /** @type {?} */ errors = htmlAstWithErrors.errors;\n        const /** @type {?} */ usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            const /** @type {?} */ uniqDirectives = removeSummaryDuplicates(directives);\n            const /** @type {?} */ uniqPipes = removeSummaryDuplicates(pipes);\n            const /** @type {?} */ providerViewContext = new ProviderViewContext(this._reflector, component);\n            let /** @type {?} */ interpolationConfig = /** @type {?} */ ((undefined));\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            const /** @type {?} */ bindingParser = new BindingParser(this._exprParser, /** @type {?} */ ((interpolationConfig)), this._schemaRegistry, uniqPipes, errors);\n            const /** @type {?} */ parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = html.visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push(...providerViewContext.errors);\n            usedPipes.push(...bindingParser.getUsedPipes());\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach((transform) => { result = templateVisitAll(transform, result); });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    }\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?=} forced\n     * @return {?}\n     */\n    expandHtml(htmlAstWithErrors, forced = false) {\n        const /** @type {?} */ errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            const /** @type {?} */ expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push(...expandedHtmlAst.errors);\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    }\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    getInterpolationConfig(component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n        return undefined;\n    }\n    /**\n     * \\@internal\n     * @param {?} result\n     * @param {?} errors\n     * @return {?}\n     */\n    _assertNoReferenceDuplicationOnTemplate(result, errors) {\n        const /** @type {?} */ existingReferences = [];\n        result.filter(element => !!(/** @type {?} */ (element)).references)\n            .forEach(element => (/** @type {?} */ (element)).references.forEach((reference) => {\n            const /** @type {?} */ name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                const /** @type {?} */ error = new TemplateParseError(`Reference \"#${name}\" is defined several times`, reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }));\n    }\n}\nfunction TemplateParser_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TemplateParser.prototype._config;\n    /** @type {?} */\n    TemplateParser.prototype._reflector;\n    /** @type {?} */\n    TemplateParser.prototype._exprParser;\n    /** @type {?} */\n    TemplateParser.prototype._schemaRegistry;\n    /** @type {?} */\n    TemplateParser.prototype._htmlParser;\n    /** @type {?} */\n    TemplateParser.prototype._console;\n    /** @type {?} */\n    TemplateParser.prototype.transforms;\n}\nclass TemplateParseVisitor {\n    /**\n     * @param {?} reflector\n     * @param {?} config\n     * @param {?} providerViewContext\n     * @param {?} directives\n     * @param {?} _bindingParser\n     * @param {?} _schemaRegistry\n     * @param {?} _schemas\n     * @param {?} _targetErrors\n     */\n    constructor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        this.reflector = reflector;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach((directive, index) => {\n            const /** @type {?} */ selector = CssSelector.parse(/** @type {?} */ ((directive.selector)));\n            this.selectorMatcher.addSelectables(selector, directive);\n            this.directivesIndex.set(directive, index);\n        });\n    }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(expansion, context) { return null; }\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(expansionCase, context) { return null; }\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    visitText(text, parent) {\n        const /** @type {?} */ ngContentIndex = /** @type {?} */ ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));\n        const /** @type {?} */ valueNoNgsp = replaceNgsp(text.value);\n        const /** @type {?} */ expr = this._bindingParser.parseInterpolation(valueNoNgsp, /** @type {?} */ ((text.sourceSpan)));\n        return expr ? new BoundTextAst(expr, ngContentIndex, /** @type {?} */ ((text.sourceSpan))) :\n            new TextAst(valueNoNgsp, ngContentIndex, /** @type {?} */ ((text.sourceSpan)));\n    }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { return null; }\n    /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    visitElement(element, parent) {\n        const /** @type {?} */ queryStartIndex = this.contentQueryStartId;\n        const /** @type {?} */ nodeName = element.name;\n        const /** @type {?} */ preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        const /** @type {?} */ matchableAttrs = [];\n        const /** @type {?} */ elementOrDirectiveProps = [];\n        const /** @type {?} */ elementOrDirectiveRefs = [];\n        const /** @type {?} */ elementVars = [];\n        const /** @type {?} */ events = [];\n        const /** @type {?} */ templateElementOrDirectiveProps = [];\n        const /** @type {?} */ templateMatchableAttrs = [];\n        const /** @type {?} */ templateElementVars = [];\n        let /** @type {?} */ hasInlineTemplates = false;\n        const /** @type {?} */ attrs = [];\n        const /** @type {?} */ isTemplateElement = isTemplate(element, this.config.enableLegacyTemplate, (m, span) => this._reportError(m, span, ParseErrorLevel.WARNING));\n        element.attrs.forEach(attr => {\n            const /** @type {?} */ hasBinding = this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            let /** @type {?} */ templateBindingsSource;\n            let /** @type {?} */ prefixToken;\n            let /** @type {?} */ normalizedName = this._normalizeAttributeName(attr.name);\n            if (this.config.enableLegacyTemplate && normalizedName == TEMPLATE_ATTR) {\n                this._reportError(TEMPLATE_ATTR_DEPRECATION_WARNING, attr.sourceSpan, ParseErrorLevel.WARNING);\n                templateBindingsSource = attr.value;\n            }\n            else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                templateBindingsSource = attr.value;\n                prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';\n            }\n            const /** @type {?} */ hasTemplateBinding = templateBindingsSource != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    this._reportError(`Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *`, attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                this._bindingParser.parseInlineTemplateBinding(/** @type {?} */ ((prefixToken)), /** @type {?} */ ((templateBindingsSource)), attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        const /** @type {?} */ elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\n        const { directives: directiveMetas, matchElement } = this._parseDirectives(this.selectorMatcher, elementCssSelector);\n        const /** @type {?} */ references = [];\n        const /** @type {?} */ boundDirectivePropNames = new Set();\n        const /** @type {?} */ directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, /** @type {?} */ ((element.sourceSpan)), references, boundDirectivePropNames);\n        const /** @type {?} */ elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        const /** @type {?} */ isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        const /** @type {?} */ providerContext = new ProviderElementContext(this.providerViewContext, /** @type {?} */ ((parent.providerContext)), isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, /** @type {?} */ ((element.sourceSpan)));\n        const /** @type {?} */ children = html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? /** @type {?} */ ((parent.providerContext)) : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        const /** @type {?} */ projectionSelector = preparsedElement.projectAs != null ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        const /** @type {?} */ ngContentIndex = /** @type {?} */ ((parent.findNgContentIndex(projectionSelector)));\n        let /** @type {?} */ parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(`<ng-content> element cannot have content.`, /** @type {?} */ ((element.sourceSpan)));\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? /** @type {?} */ ((null)) : ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        else if (isTemplateElement) {\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, /** @type {?} */ ((element.sourceSpan)));\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? /** @type {?} */ ((null)) : ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        else {\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, /** @type {?} */ ((element.sourceSpan)));\n            const /** @type {?} */ ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan, element.endSourceSpan || null);\n        }\n        if (hasInlineTemplates) {\n            const /** @type {?} */ templateQueryStartIndex = this.contentQueryStartId;\n            const /** @type {?} */ templateSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\n            const { directives: templateDirectiveMetas } = this._parseDirectives(this.selectorMatcher, templateSelector);\n            const /** @type {?} */ templateBoundDirectivePropNames = new Set();\n            const /** @type {?} */ templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], /** @type {?} */ ((element.sourceSpan)), [], templateBoundDirectivePropNames);\n            const /** @type {?} */ templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, /** @type {?} */ ((element.sourceSpan)));\n            const /** @type {?} */ templateProviderContext = new ProviderElementContext(this.providerViewContext, /** @type {?} */ ((parent.providerContext)), parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, /** @type {?} */ ((element.sourceSpan)));\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        return parsedElement;\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} attr\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetEvents\n     * @param {?} targetRefs\n     * @param {?} targetVars\n     * @return {?}\n     */\n    _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        const /** @type {?} */ name = this._normalizeAttributeName(attr.name);\n        const /** @type {?} */ value = attr.value;\n        const /** @type {?} */ srcSpan = attr.sourceSpan;\n        const /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n        let /** @type {?} */ hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    const /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                const /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        return hasBinding;\n    }\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    _normalizeAttributeName(attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    }\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetVars\n     * @return {?}\n     */\n    _parseVariable(identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    }\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetRefs\n     * @return {?}\n     */\n    _parseReference(identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    }\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    _parseAssignmentEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n    /**\n     * @param {?} selectorMatcher\n     * @param {?} elementCssSelector\n     * @return {?}\n     */\n    _parseDirectives(selectorMatcher, elementCssSelector) {\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        const /** @type {?} */ directives = new Array(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        let /** @type {?} */ matchElement = false;\n        selectorMatcher.match(elementCssSelector, (selector, directive) => {\n            directives[/** @type {?} */ ((this.directivesIndex.get(directive)))] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(dir => !!dir),\n            matchElement,\n        };\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} elementName\n     * @param {?} directives\n     * @param {?} props\n     * @param {?} elementOrDirectiveRefs\n     * @param {?} elementSourceSpan\n     * @param {?} targetReferences\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        const /** @type {?} */ matchedReferences = new Set();\n        let /** @type {?} */ component = /** @type {?} */ ((null));\n        const /** @type {?} */ directiveAsts = directives.map((directive) => {\n            const /** @type {?} */ sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, `Directive ${identifierName(directive.type)}`);\n            if (directive.isComponent) {\n                component = directive;\n            }\n            const /** @type {?} */ directiveProperties = [];\n            let /** @type {?} */ hostProperties = /** @type {?} */ ((this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan)));\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);\n            const /** @type {?} */ hostEvents = /** @type {?} */ ((this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan)));\n            this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach((elOrDirRef) => {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (elOrDirRef.isReferenceToDirective(directive))) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            const /** @type {?} */ contentQueryStartId = this.contentQueryStartId;\n            this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach((elOrDirRef) => {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    this._reportError(`There is no directive with \"exportAs\" set to \"${elOrDirRef.value}\"`, elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                let /** @type {?} */ refToken = /** @type {?} */ ((null));\n                if (isTemplateElement) {\n                    refToken = createTokenForExternalReference(this.reflector, Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    }\n    /**\n     * @param {?} directiveProperties\n     * @param {?} boundProps\n     * @param {?} targetBoundDirectiveProps\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            const /** @type {?} */ boundPropsByName = new Map();\n            boundProps.forEach(boundProp => {\n                const /** @type {?} */ prevValue = boundPropsByName.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(dirProp => {\n                const /** @type {?} */ elProp = directiveProperties[dirProp];\n                const /** @type {?} */ boundProp = boundPropsByName.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} props\n     * @param {?} boundDirectivePropNames\n     * @return {?}\n     */\n    _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {\n        const /** @type {?} */ boundElementProps = [];\n        props.forEach((prop) => {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                boundElementProps.push(this._bindingParser.createElementPropertyAst(elementName, prop));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    }\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    _findComponentDirectives(directives) {\n        return directives.filter(directive => directive.directive.isComponent);\n    }\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    _findComponentDirectiveNames(directives) {\n        return this._findComponentDirectives(directives)\n            .map(directive => /** @type {?} */ ((identifierName(directive.directive.type))));\n    }\n    /**\n     * @param {?} directives\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _assertOnlyOneComponent(directives, sourceSpan) {\n        const /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(`More than one component matched on this element.\\n` +\n                `Make sure that only one component's selector can match a given element.\\n` +\n                `Conflicting components: ${componentTypeNames.join(',')}`, sourceSpan);\n        }\n    }\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param {?} matchElement Whether any directive has matched on the tag name\n     * @param {?} element the html element\n     * @return {?}\n     */\n    _assertElementExists(matchElement, element) {\n        const /** @type {?} */ elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            let /** @type {?} */ errorMsg = `'${elName}' is not a known element:\\n`;\n            errorMsg +=\n                `1. If '${elName}' is an Angular component, then verify that it is part of this module.\\n`;\n            if (elName.indexOf('-') > -1) {\n                errorMsg +=\n                    `2. If '${elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n            }\n            else {\n                errorMsg +=\n                    `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n            }\n            this._reportError(errorMsg, /** @type {?} */ ((element.sourceSpan)));\n        }\n    }\n    /**\n     * @param {?} directives\n     * @param {?} elementProps\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {\n        const /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(`Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);\n        }\n        elementProps.forEach(prop => {\n            this._reportError(`Property binding ${prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`, sourceSpan);\n        });\n    }\n    /**\n     * @param {?} directives\n     * @param {?} events\n     * @return {?}\n     */\n    _assertAllEventsPublishedByDirectives(directives, events) {\n        const /** @type {?} */ allDirectiveEvents = new Set();\n        directives.forEach(directive => {\n            Object.keys(directive.directive.outputs).forEach(k => {\n                const /** @type {?} */ eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(event => {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                this._reportError(`Event binding ${event.fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`, event.sourceSpan);\n            }\n        });\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} boundProps\n     * @return {?}\n     */\n    _checkPropertiesInSchema(elementName, boundProps) {\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter((boundProp) => {\n            if (boundProp.type === PropertyBindingType.Property &&\n                !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {\n                let /** @type {?} */ errorMsg = `Can't bind to '${boundProp.name}' since it isn't a known property of '${elementName}'.`;\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        `\\n1. If '${boundProp.name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +\n                            `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        `\\n1. If '${elementName}' is an Angular component and it has '${boundProp.name}' input, then verify that it is part of this module.` +\n                            `\\n2. If '${elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +\n                            `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n                }\n                this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    }\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    }\n}\nfunction TemplateParseVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TemplateParseVisitor.prototype.selectorMatcher;\n    /** @type {?} */\n    TemplateParseVisitor.prototype.directivesIndex;\n    /** @type {?} */\n    TemplateParseVisitor.prototype.ngContentCount;\n    /** @type {?} */\n    TemplateParseVisitor.prototype.contentQueryStartId;\n    /** @type {?} */\n    TemplateParseVisitor.prototype.reflector;\n    /** @type {?} */\n    TemplateParseVisitor.prototype.config;\n    /** @type {?} */\n    TemplateParseVisitor.prototype.providerViewContext;\n    /** @type {?} */\n    TemplateParseVisitor.prototype._bindingParser;\n    /** @type {?} */\n    TemplateParseVisitor.prototype._schemaRegistry;\n    /** @type {?} */\n    TemplateParseVisitor.prototype._schemas;\n    /** @type {?} */\n    TemplateParseVisitor.prototype._targetErrors;\n}\nclass NonBindableVisitor {\n    /**\n     * @param {?} ast\n     * @param {?} parent\n     * @return {?}\n     */\n    visitElement(ast, parent) {\n        const /** @type {?} */ preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        const /** @type {?} */ attrNameAndValues = ast.attrs.map((attr) => [attr.name, attr.value]);\n        const /** @type {?} */ selector = createElementCssSelector(ast.name, attrNameAndValues);\n        const /** @type {?} */ ngContentIndex = parent.findNgContentIndex(selector);\n        const /** @type {?} */ children = html.visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, html.visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    }\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    visitComment(comment, context) { return null; }\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttribute(attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    }\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    visitText(text, parent) {\n        const /** @type {?} */ ngContentIndex = /** @type {?} */ ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));\n        return new TextAst(text.value, ngContentIndex, /** @type {?} */ ((text.sourceSpan)));\n    }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansion(expansion, context) { return expansion; }\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    visitExpansionCase(expansionCase, context) { return expansionCase; }\n}\n/**\n * A reference to an element or directive in a template. E.g., the reference in this template:\n *\n * <div #myMenu=\"coolMenu\">\n *\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n */\nclass ElementOrDirectiveRef {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    constructor(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * Gets whether this is a reference to the given directive.\n     * @param {?} directive\n     * @return {?}\n     */\n    isReferenceToDirective(directive) {\n        return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n    }\n}\nfunction ElementOrDirectiveRef_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ElementOrDirectiveRef.prototype.name;\n    /** @type {?} */\n    ElementOrDirectiveRef.prototype.value;\n    /** @type {?} */\n    ElementOrDirectiveRef.prototype.sourceSpan;\n}\n/**\n * Splits a raw, potentially comma-delimted `exportAs` value into an array of names.\n * @param {?} exportAs\n * @return {?}\n */\nfunction splitExportAs(exportAs) {\n    return exportAs ? exportAs.split(',').map(e => e.trim()) : [];\n}\n/**\n * @param {?} classAttrValue\n * @return {?}\n */\nexport function splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nclass ElementContext {\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} _ngContentIndexMatcher\n     * @param {?} _wildcardNgContentIndex\n     * @param {?} providerContext\n     */\n    constructor(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} directives\n     * @param {?} providerContext\n     * @return {?}\n     */\n    static create(isTemplateElement, directives, providerContext) {\n        const /** @type {?} */ matcher = new SelectorMatcher();\n        let /** @type {?} */ wildcardNgContentIndex = /** @type {?} */ ((null));\n        const /** @type {?} */ component = directives.find(directive => directive.directive.isComponent);\n        if (component) {\n            const /** @type {?} */ ngContentSelectors = /** @type {?} */ ((component.directive.template)).ngContentSelectors;\n            for (let /** @type {?} */ i = 0; i < ngContentSelectors.length; i++) {\n                const /** @type {?} */ selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    findNgContentIndex(selector) {\n        const /** @type {?} */ ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, (selector, ngContentIndex) => { ngContentIndices.push(ngContentIndex); });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    }\n}\nfunction ElementContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ElementContext.prototype.isTemplateElement;\n    /** @type {?} */\n    ElementContext.prototype._ngContentIndexMatcher;\n    /** @type {?} */\n    ElementContext.prototype._wildcardNgContentIndex;\n    /** @type {?} */\n    ElementContext.prototype.providerContext;\n}\n/**\n * @param {?} elementName\n * @param {?} attributes\n * @return {?}\n */\nexport function createElementCssSelector(elementName, attributes) {\n    const /** @type {?} */ cssSelector = new CssSelector();\n    const /** @type {?} */ elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (let /** @type {?} */ i = 0; i < attributes.length; i++) {\n        const /** @type {?} */ attrName = attributes[i][0];\n        const /** @type {?} */ attrNameNoNs = splitNsName(attrName)[1];\n        const /** @type {?} */ attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            const /** @type {?} */ classes = splitClasses(attrValue);\n            classes.forEach(className => cssSelector.addClassName(className));\n        }\n    }\n    return cssSelector;\n}\nconst /** @type {?} */ EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nconst /** @type {?} */ NON_BINDABLE_VISITOR = new NonBindableVisitor();\n/**\n * @param {?} node\n * @return {?}\n */\nfunction _isEmptyTextNode(node) {\n    return node instanceof html.Text && node.value.trim().length == 0;\n}\n/**\n * @template T\n * @param {?} items\n * @return {?}\n */\nexport function removeSummaryDuplicates(items) {\n    const /** @type {?} */ map = new Map();\n    items.forEach((item) => {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n/**\n * @param {?} el\n * @param {?} enableLegacyTemplate\n * @param {?} reportDeprecation\n * @return {?}\n */\nfunction isTemplate(el, enableLegacyTemplate, reportDeprecation) {\n    if (isNgTemplate(el.name))\n        return true;\n    const /** @type {?} */ tagNoNs = splitNsName(el.name)[1];\n    // `<template>` is HTML and case insensitive\n    if (tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n        if (enableLegacyTemplate && tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n            reportDeprecation(TEMPLATE_ELEMENT_DEPRECATION_WARNING, /** @type {?} */ ((el.sourceSpan)));\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=template_parser.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as cdAst from \"../expression_parser/ast\";\nimport { Identifiers } from \"../identifiers\";\nimport * as o from \"../output/output_ast\";\nexport class EventHandlerVars {\n}\nEventHandlerVars.event = o.variable('$event');\nfunction EventHandlerVars_tsickle_Closure_declarations() {\n    /** @type {?} */\n    EventHandlerVars.event;\n}\n/**\n * @record\n */\nexport function LocalResolver() { }\nfunction LocalResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LocalResolver.prototype.getLocal;\n}\nexport class ConvertActionBindingResult {\n    /**\n     * @param {?} stmts\n     * @param {?} allowDefault\n     */\n    constructor(stmts, allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n    }\n}\nfunction ConvertActionBindingResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ConvertActionBindingResult.prototype.stmts;\n    /** @type {?} */\n    ConvertActionBindingResult.prototype.allowDefault;\n}\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertActionBinding(localResolver, implicitReceiver, action, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    const /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: (argCount) => {\n            // Note: no caching for literal arrays in actions.\n            return (args) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys) => {\n            // Note: no caching for literal maps in actions.\n            return (values) => {\n                const /** @type {?} */ entries = keys.map((k, i) => ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }));\n                return o.literalMap(entries);\n            };\n        },\n        createPipeConverter: (name) => {\n            throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n    }, action);\n    const /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    const /** @type {?} */ actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    const /** @type {?} */ lastIndex = actionStmts.length - 1;\n    let /** @type {?} */ preventDefaultVar = /** @type {?} */ ((null));\n    if (lastIndex >= 0) {\n        const /** @type {?} */ lastStatement = actionStmts[lastIndex];\n        const /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n                    .toDeclStmt(null, [o.StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * @record\n */\nexport function BuiltinConverter() { }\nfunction BuiltinConverter_tsickle_Closure_declarations() {\n    /* TODO: handle strange member:\n    (args: o.Expression[]): o.Expression;\n    */\n}\n/**\n * @record\n */\nexport function BuiltinConverterFactory() { }\nfunction BuiltinConverterFactory_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BuiltinConverterFactory.prototype.createLiteralArrayConverter;\n    /** @type {?} */\n    BuiltinConverterFactory.prototype.createLiteralMapConverter;\n    /** @type {?} */\n    BuiltinConverterFactory.prototype.createPipeConverter;\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nexport function convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nexport class ConvertPropertyBindingResult {\n    /**\n     * @param {?} stmts\n     * @param {?} currValExpr\n     */\n    constructor(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n}\nfunction ConvertPropertyBindingResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ConvertPropertyBindingResult.prototype.stmts;\n    /** @type {?} */\n    ConvertPropertyBindingResult.prototype.currValExpr;\n}\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    const /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n    const /** @type {?} */ stmts = [];\n    const /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    const /** @type {?} */ outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    if (visitor.temporaryCount) {\n        for (let /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n            stmts.push(temporaryDeclaration(bindingId, i));\n        }\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [o.StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory, ast) {\n    const /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId, temporaryNumber) {\n    return `tmp_${bindingId}_${temporaryNumber}`;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nexport function temporaryDeclaration(bindingId, temporaryNumber) {\n    return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (let /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\n/** @enum {number} */\nconst _Mode = {\n    Statement: 0,\n    Expression: 1,\n};\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(`Expected a statement, but saw ${ast}`);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(`Expected an expression, but saw ${ast}`);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n    /**\n     * @param {?} _converterFactory\n     */\n    constructor(_converterFactory) {\n        super();\n        this._converterFactory = _converterFactory;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitPipe(ast, context) {\n        const /** @type {?} */ args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralArray(ast, context) {\n        const /** @type {?} */ args = ast.expressions.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitLiteralMap(ast, context) {\n        const /** @type {?} */ args = ast.values.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    }\n}\nfunction _BuiltinAstConverter_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _BuiltinAstConverter.prototype._converterFactory;\n}\nclass _AstToIrVisitor {\n    /**\n     * @param {?} _localResolver\n     * @param {?} _implicitReceiver\n     * @param {?} bindingId\n     */\n    constructor(_localResolver, _implicitReceiver, bindingId) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitBinary(ast, mode) {\n        let /** @type {?} */ op;\n        switch (ast.operation) {\n            case '+':\n                op = o.BinaryOperator.Plus;\n                break;\n            case '-':\n                op = o.BinaryOperator.Minus;\n                break;\n            case '*':\n                op = o.BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = o.BinaryOperator.Divide;\n                break;\n            case '%':\n                op = o.BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = o.BinaryOperator.And;\n                break;\n            case '||':\n                op = o.BinaryOperator.Or;\n                break;\n            case '==':\n                op = o.BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = o.BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = o.BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = o.BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = o.BinaryOperator.Lower;\n                break;\n            case '>':\n                op = o.BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = o.BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = o.BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(`Unsupported operation ${ast.operation}`);\n        }\n        return convertToStatementIfNeeded(mode, new o.BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitChain(ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitConditional(ast, mode) {\n        const /** @type {?} */ value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression)));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitPipe(ast, mode) {\n        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitFunctionCall(ast, mode) {\n        const /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        let /** @type {?} */ fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this._visit(/** @type {?} */ ((ast.target)), _Mode.Expression).callFn(convertedArgs);\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitImplicitReceiver(ast, mode) {\n        ensureExpressionMode(mode, ast);\n        return this._implicitReceiver;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitInterpolation(ast, mode) {\n        ensureExpressionMode(mode, ast);\n        const /** @type {?} */ args = [o.literal(ast.expressions.length)];\n        for (let /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n            args.push(o.literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(o.literal(ast.strings[ast.strings.length - 1]));\n        return ast.expressions.length <= 9 ?\n            o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n            o.importExpr(Identifiers.interpolate).callFn([args[0], o.literalArr(args.slice(1))]);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitKeyedRead(ast, mode) {\n        const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitKeyedWrite(ast, mode) {\n        const /** @type {?} */ obj = this._visit(ast.obj, _Mode.Expression);\n        const /** @type {?} */ key = this._visit(ast.key, _Mode.Expression);\n        const /** @type {?} */ value = this._visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitLiteralArray(ast, mode) {\n        throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitLiteralMap(ast, mode) {\n        throw new Error(`Illegal State: literal maps should have been converted into functions`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitLiteralPrimitive(ast, mode) {\n        return convertToStatementIfNeeded(mode, o.literal(ast.value));\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    _getLocal(name) { return this._localResolver.getLocal(name); }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitMethodCall(ast, mode) {\n        const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            const /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n            let /** @type {?} */ result = null;\n            const /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                const /** @type {?} */ varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    result = varExpr.callFn(args);\n                }\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitPrefixNot(ast, mode) {\n        return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitNonNullAssert(ast, mode) {\n        return convertToStatementIfNeeded(mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitPropertyRead(ast, mode) {\n        const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            let /** @type {?} */ result = null;\n            const /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitPropertyWrite(ast, mode) {\n        const /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n        if (receiver === this._implicitReceiver) {\n            const /** @type {?} */ varExpr = this._getLocal(ast.name);\n            if (varExpr) {\n                throw new Error('Cannot assign to a reference or variable!');\n            }\n        }\n        return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this._visit(ast.value, _Mode.Expression)));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitSafePropertyRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitSafeMethodCall(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    /**\n     * @param {?} asts\n     * @param {?} mode\n     * @return {?}\n     */\n    visitAll(asts, mode) { return asts.map(ast => this._visit(ast, mode)); }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    visitQuote(ast, mode) {\n        throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _visit(ast, mode) {\n        const /** @type {?} */ result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} leftMostSafe\n     * @param {?} mode\n     * @return {?}\n     */\n    convertSafeAccess(ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  ,   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        let /** @type {?} */ guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        let /** @type {?} */ temporary = /** @type {?} */ ((undefined));\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        const /** @type {?} */ condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new cdAst.MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        const /** @type {?} */ access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    leftMostSafeNode(ast) {\n        const /** @type {?} */ visit = (visitor, ast) => {\n            return (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead(ast) { return visit(this, ast.obj); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall(ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitNonNullAssert(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead(ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote(ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall(ast) { return visit(this, ast.receiver) || ast; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    needsTemporary(ast) {\n        const /** @type {?} */ visit = (visitor, ast) => {\n            return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        const /** @type {?} */ visitSome = (visitor, ast) => {\n            return ast.some(ast => visit(visitor, ast));\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary(ast) { return visit(this, ast.left) || visit(this, ast.right); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional(ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                    visit(this, ast.falseExp);\n            },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall(ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation(ast) { return visitSome(this, ast.expressions); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray(ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap(ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall(ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe(ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot(ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitNonNullAssert(ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote(ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall(ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead(ast) { return false; }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    allocateTemporary() {\n        const /** @type {?} */ tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    }\n    /**\n     * @param {?} temporary\n     * @return {?}\n     */\n    releaseTemporary(temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(`Temporary ${temporary.name} released out of order`);\n        }\n    }\n}\nfunction _AstToIrVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _AstToIrVisitor.prototype._nodeMap;\n    /** @type {?} */\n    _AstToIrVisitor.prototype._resultMap;\n    /** @type {?} */\n    _AstToIrVisitor.prototype._currentTemporary;\n    /** @type {?} */\n    _AstToIrVisitor.prototype.temporaryCount;\n    /** @type {?} */\n    _AstToIrVisitor.prototype._localResolver;\n    /** @type {?} */\n    _AstToIrVisitor.prototype._implicitReceiver;\n    /** @type {?} */\n    _AstToIrVisitor.prototype.bindingId;\n}\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        (/** @type {?} */ (arg)).forEach((entry) => flattenStatements(entry, output));\n    }\n    else {\n        output.push(arg);\n    }\n}\nclass DefaultLocalResolver {\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getLocal(name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    }\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId) {\n    return o.variable(`currVal_${bindingId}`); // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId) {\n    return o.variable(`pd_${bindingId}`);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof o.ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof o.ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nclass BuiltinFunctionCall extends cdAst.FunctionCall {\n    /**\n     * @param {?} span\n     * @param {?} args\n     * @param {?} converter\n     */\n    constructor(span, args, converter) {\n        super(span, null, args);\n        this.args = args;\n        this.converter = converter;\n    }\n}\nfunction BuiltinFunctionCall_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BuiltinFunctionCall.prototype.args;\n    /** @type {?} */\n    BuiltinFunctionCall.prototype.converter;\n}\n//# sourceMappingURL=expression_converter.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { StaticSymbol } from \"../aot/static_symbol\";\nimport { EventHandlerVars, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins } from \"../compiler_util/expression_converter\";\nimport * as o from \"../output/output_ast\";\nimport { templateVisitAll } from \"../template_parser/template_ast\";\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n    /**\n     * @param {?} options\n     * @param {?} reflector\n     */\n    constructor(options, reflector) {\n        this.options = options;\n        this.reflector = reflector;\n    }\n    /**\n     * Important notes:\n     * - This must not produce new `import` statements, but only refer to types outside\n     *   of the file via the variables provided via externalReferenceVars.\n     *   This allows Typescript to reuse the old program's structure as no imports have changed.\n     * - This must not produce any exports, as this would pollute the .d.ts file\n     *   and also violate the point above.\n     * @param {?} componentId\n     * @param {?} component\n     * @param {?} template\n     * @param {?} usedPipes\n     * @param {?} externalReferenceVars\n     * @return {?}\n     */\n    compileComponent(componentId, component, template, usedPipes, externalReferenceVars) {\n        const /** @type {?} */ pipes = new Map();\n        usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n        let /** @type {?} */ embeddedViewCount = 0;\n        const /** @type {?} */ viewBuilderFactory = (parent) => {\n            const /** @type {?} */ embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(this.options, this.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, viewBuilderFactory);\n        };\n        const /** @type {?} */ visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        return visitor.build(componentId);\n    }\n}\nfunction TypeCheckCompiler_tsickle_Closure_declarations() {\n    /** @type {?} */\n    TypeCheckCompiler.prototype.options;\n    /** @type {?} */\n    TypeCheckCompiler.prototype.reflector;\n}\n/**\n * @record\n */\nfunction ViewBuilderFactory() { }\nfunction ViewBuilderFactory_tsickle_Closure_declarations() {\n    /* TODO: handle strange member:\n    (parent: ViewBuilder): ViewBuilder;\n    */\n}\n/**\n * @record\n */\nfunction Expression() { }\nfunction Expression_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Expression.prototype.context;\n    /** @type {?} */\n    Expression.prototype.sourceSpan;\n    /** @type {?} */\n    Expression.prototype.value;\n}\nconst /** @type {?} */ DYNAMIC_VAR_NAME = '_any';\nclass TypeCheckLocalResolver {\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getLocal(name) {\n        if (name === EventHandlerVars.event.name) {\n            // References to the event should not be type-checked.\n            // TODO(chuckj): determine a better type for the event.\n            return o.variable(DYNAMIC_VAR_NAME);\n        }\n        return null;\n    }\n}\nconst /** @type {?} */ defaultResolver = new TypeCheckLocalResolver();\nclass ViewBuilder {\n    /**\n     * @param {?} options\n     * @param {?} reflector\n     * @param {?} externalReferenceVars\n     * @param {?} parent\n     * @param {?} component\n     * @param {?} isHostComponent\n     * @param {?} embeddedViewIndex\n     * @param {?} pipes\n     * @param {?} viewBuilderFactory\n     */\n    constructor(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, viewBuilderFactory) {\n        this.options = options;\n        this.reflector = reflector;\n        this.externalReferenceVars = externalReferenceVars;\n        this.parent = parent;\n        this.component = component;\n        this.isHostComponent = isHostComponent;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.pipes = pipes;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.refOutputVars = new Map();\n        this.variables = [];\n        this.children = [];\n        this.updates = [];\n        this.actions = [];\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    getOutputVar(type) {\n        let /** @type {?} */ varName;\n        if (type === this.component && this.isHostComponent) {\n            varName = DYNAMIC_VAR_NAME;\n        }\n        else if (type instanceof StaticSymbol) {\n            varName = this.externalReferenceVars.get(type);\n        }\n        else {\n            varName = DYNAMIC_VAR_NAME;\n        }\n        if (!varName) {\n            throw new Error(`Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n        }\n        return varName;\n    }\n    /**\n     * @param {?} variables\n     * @param {?} astNodes\n     * @return {?}\n     */\n    visitAll(variables, astNodes) {\n        this.variables = variables;\n        templateVisitAll(this, astNodes);\n    }\n    /**\n     * @param {?} componentId\n     * @param {?=} targetStatements\n     * @return {?}\n     */\n    build(componentId, targetStatements = []) {\n        this.children.forEach((child) => child.build(componentId, targetStatements));\n        const /** @type {?} */ viewStmts = [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n        let /** @type {?} */ bindingCount = 0;\n        this.updates.forEach((expression) => {\n            const { sourceSpan, context, value } = this.preprocessUpdateExpression(expression);\n            const /** @type {?} */ bindingId = `${bindingCount++}`;\n            const /** @type {?} */ nameResolver = context === this.component ? this : defaultResolver;\n            const { stmts, currValExpr } = convertPropertyBinding(nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n            stmts.push(new o.ExpressionStatement(currValExpr));\n            viewStmts.push(...stmts.map((stmt) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n        });\n        this.actions.forEach(({ sourceSpan, context, value }) => {\n            const /** @type {?} */ bindingId = `${bindingCount++}`;\n            const /** @type {?} */ nameResolver = context === this.component ? this : defaultResolver;\n            const { stmts } = convertActionBinding(nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n            viewStmts.push(...stmts.map((stmt) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n        });\n        const /** @type {?} */ viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n        const /** @type {?} */ viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBoundText(ast, context) {\n        const /** @type {?} */ astWithSource = /** @type {?} */ (ast.value);\n        const /** @type {?} */ inter = /** @type {?} */ (astWithSource.ast);\n        inter.expressions.forEach((expr) => this.updates.push({ context: this.component, value: expr, sourceSpan: ast.sourceSpan }));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEmbeddedTemplate(ast, context) {\n        this.visitElementOrTemplate(ast);\n        // Note: The old view compiler used to use an `any` type\n        // for the context in any embedded view.\n        // We keep this behaivor behind a flag for now.\n        if (this.options.fullTemplateTypeCheck) {\n            const /** @type {?} */ childVisitor = this.viewBuilderFactory(this);\n            this.children.push(childVisitor);\n            childVisitor.visitAll(ast.variables, ast.children);\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(ast, context) {\n        this.visitElementOrTemplate(ast);\n        let /** @type {?} */ inputDefs = [];\n        let /** @type {?} */ updateRendererExpressions = [];\n        let /** @type {?} */ outputDefs = [];\n        ast.inputs.forEach((inputAst) => {\n            this.updates.push({ context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan });\n        });\n        templateVisitAll(this, ast.children);\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    visitElementOrTemplate(ast) {\n        ast.directives.forEach((dirAst) => { this.visitDirective(dirAst); });\n        ast.references.forEach((ref) => {\n            let /** @type {?} */ outputVarType = /** @type {?} */ ((null));\n            // Note: The old view compiler used to use an `any` type\n            // for directives exposed via `exportAs`.\n            // We keep this behaivor behind a flag for now.\n            if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n                outputVarType = ref.value.identifier.reference;\n            }\n            else {\n                outputVarType = o.BuiltinTypeName.Dynamic;\n            }\n            this.refOutputVars.set(ref.name, outputVarType);\n        });\n        ast.outputs.forEach((outputAst) => {\n            this.actions.push({ context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan });\n        });\n    }\n    /**\n     * @param {?} dirAst\n     * @return {?}\n     */\n    visitDirective(dirAst) {\n        const /** @type {?} */ dirType = dirAst.directive.type.reference;\n        dirAst.inputs.forEach((input) => this.updates.push({ context: this.component, value: input.value, sourceSpan: input.sourceSpan }));\n        // Note: The old view compiler used to use an `any` type\n        // for expressions in host properties / events.\n        // We keep this behaivor behind a flag for now.\n        if (this.options.fullTemplateTypeCheck) {\n            dirAst.hostProperties.forEach((inputAst) => this.updates.push({ context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan }));\n            dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n                context: dirType,\n                value: hostEventAst.handler,\n                sourceSpan: hostEventAst.sourceSpan\n            }));\n        }\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getLocal(name) {\n        if (name == EventHandlerVars.event.name) {\n            return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n        }\n        for (let /** @type {?} */ currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {\n            let /** @type {?} */ outputVarType;\n            // check references\n            outputVarType = currBuilder.refOutputVars.get(name);\n            if (outputVarType == null) {\n                // check variables\n                const /** @type {?} */ varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n                if (varAst) {\n                    outputVarType = o.BuiltinTypeName.Dynamic;\n                }\n            }\n            if (outputVarType != null) {\n                return o.variable(this.getOutputVar(outputVarType));\n            }\n        }\n        return null;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    pipeOutputVar(name) {\n        const /** @type {?} */ pipe = this.pipes.get(name);\n        if (!pipe) {\n            throw new Error(`Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n        }\n        return this.getOutputVar(pipe);\n    }\n    /**\n     * @param {?} expression\n     * @return {?}\n     */\n    preprocessUpdateExpression(expression) {\n        return {\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: (argCount) => (args) => {\n                    const /** @type {?} */ arr = o.literalArr(args);\n                    // Note: The old view compiler used to use an `any` type\n                    // for arrays.\n                    return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n                },\n                createLiteralMapConverter: (keys) => (values) => {\n                    const /** @type {?} */ entries = keys.map((k, i) => ({\n                        key: k.key,\n                        value: values[i],\n                        quoted: k.quoted,\n                    }));\n                    const /** @type {?} */ map = o.literalMap(entries);\n                    // Note: The old view compiler used to use an `any` type\n                    // for maps.\n                    return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n                createPipeConverter: (name, argCount) => (args) => {\n                    // Note: The old view compiler used to use an `any` type\n                    // for pipes.\n                    const /** @type {?} */ pipeExpr = this.options.fullTemplateTypeCheck ?\n                        o.variable(this.pipeOutputVar(name)) :\n                        o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n                    return pipeExpr.callMethod('transform', args);\n                },\n            }, expression.value)\n        };\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNgContent(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitDirectiveProperty(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReference(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitVariable(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEvent(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElementProperty(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttr(ast, context) { }\n}\nfunction ViewBuilder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ViewBuilder.prototype.refOutputVars;\n    /** @type {?} */\n    ViewBuilder.prototype.variables;\n    /** @type {?} */\n    ViewBuilder.prototype.children;\n    /** @type {?} */\n    ViewBuilder.prototype.updates;\n    /** @type {?} */\n    ViewBuilder.prototype.actions;\n    /** @type {?} */\n    ViewBuilder.prototype.options;\n    /** @type {?} */\n    ViewBuilder.prototype.reflector;\n    /** @type {?} */\n    ViewBuilder.prototype.externalReferenceVars;\n    /** @type {?} */\n    ViewBuilder.prototype.parent;\n    /** @type {?} */\n    ViewBuilder.prototype.component;\n    /** @type {?} */\n    ViewBuilder.prototype.isHostComponent;\n    /** @type {?} */\n    ViewBuilder.prototype.embeddedViewIndex;\n    /** @type {?} */\n    ViewBuilder.prototype.pipes;\n    /** @type {?} */\n    ViewBuilder.prototype.viewBuilderFactory;\n}\n//# sourceMappingURL=type_check_compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { rendererTypeName, tokenReference, viewClassName } from \"../compile_metadata\";\nimport { EventHandlerVars, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins } from \"../compiler_util/expression_converter\";\nimport { ChangeDetectionStrategy } from \"../core\";\nimport { Identifiers } from \"../identifiers\";\nimport { LifecycleHooks } from \"../lifecycle_reflector\";\nimport { isNgContainer } from \"../ml_parser/tags\";\nimport * as o from \"../output/output_ast\";\nimport { convertValueToOutputAst } from \"../output/value_util\";\nimport { ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, templateVisitAll } from \"../template_parser/template_ast\";\nimport { componentFactoryResolverProviderDef, depDef, lifecycleHookToNodeFlag, providerDef } from \"./provider_compiler\";\nconst /** @type {?} */ CLASS_ATTR = 'class';\nconst /** @type {?} */ STYLE_ATTR = 'style';\nconst /** @type {?} */ IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nexport class ViewCompileResult {\n    /**\n     * @param {?} viewClassVar\n     * @param {?} rendererTypeVar\n     */\n    constructor(viewClassVar, rendererTypeVar) {\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n}\nfunction ViewCompileResult_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ViewCompileResult.prototype.viewClassVar;\n    /** @type {?} */\n    ViewCompileResult.prototype.rendererTypeVar;\n}\nexport class ViewCompiler {\n    /**\n     * @param {?} _reflector\n     */\n    constructor(_reflector) {\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} component\n     * @param {?} template\n     * @param {?} styles\n     * @param {?} usedPipes\n     * @return {?}\n     */\n    compileComponent(outputCtx, component, template, styles, usedPipes) {\n        let /** @type {?} */ embeddedViewCount = 0;\n        const /** @type {?} */ staticQueryIds = findStaticQueryIds(template);\n        let /** @type {?} */ renderComponentVarName = /** @type {?} */ ((undefined));\n        if (!component.isHost) {\n            const /** @type {?} */ template = /** @type {?} */ ((component.template));\n            const /** @type {?} */ customRenderData = [];\n            if (template.animations && template.animations.length) {\n                customRenderData.push(new o.LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template.animations), true));\n            }\n            const /** @type {?} */ renderComponentVar = o.variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = /** @type {?} */ ((renderComponentVar.name));\n            outputCtx.statements.push(renderComponentVar\n                .set(o.importExpr(Identifiers.createRendererType2).callFn([new o.LiteralMapExpr([\n                    new o.LiteralMapEntry('encapsulation', o.literal(template.encapsulation), false),\n                    new o.LiteralMapEntry('styles', styles, false),\n                    new o.LiteralMapEntry('data', new o.LiteralMapExpr(customRenderData), false)\n                ])]))\n                .toDeclStmt(o.importType(Identifiers.RendererType2), [o.StmtModifier.Final, o.StmtModifier.Exported]));\n        }\n        const /** @type {?} */ viewBuilderFactory = (parent) => {\n            const /** @type {?} */ embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);\n        };\n        const /** @type {?} */ visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        outputCtx.statements.push(...visitor.build());\n        return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n    }\n}\nfunction ViewCompiler_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ViewCompiler.prototype._reflector;\n}\n/**\n * @record\n */\nfunction ViewBuilderFactory() { }\nfunction ViewBuilderFactory_tsickle_Closure_declarations() {\n    /* TODO: handle strange member:\n    (parent: ViewBuilder): ViewBuilder;\n    */\n}\n/**\n * @record\n */\nfunction UpdateExpression() { }\nfunction UpdateExpression_tsickle_Closure_declarations() {\n    /** @type {?} */\n    UpdateExpression.prototype.context;\n    /** @type {?} */\n    UpdateExpression.prototype.nodeIndex;\n    /** @type {?} */\n    UpdateExpression.prototype.bindingIndex;\n    /** @type {?} */\n    UpdateExpression.prototype.sourceSpan;\n    /** @type {?} */\n    UpdateExpression.prototype.value;\n}\nconst /** @type {?} */ LOG_VAR = o.variable('_l');\nconst /** @type {?} */ VIEW_VAR = o.variable('_v');\nconst /** @type {?} */ CHECK_VAR = o.variable('_ck');\nconst /** @type {?} */ COMP_VAR = o.variable('_co');\nconst /** @type {?} */ EVENT_NAME_VAR = o.variable('en');\nconst /** @type {?} */ ALLOW_DEFAULT_VAR = o.variable(`ad`);\nclass ViewBuilder {\n    /**\n     * @param {?} reflector\n     * @param {?} outputCtx\n     * @param {?} parent\n     * @param {?} component\n     * @param {?} embeddedViewIndex\n     * @param {?} usedPipes\n     * @param {?} staticQueryIds\n     * @param {?} viewBuilderFactory\n     */\n    constructor(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {\n        this.reflector = reflector;\n        this.outputCtx = outputCtx;\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.staticQueryIds = staticQueryIds;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType = this.embeddedViewIndex > 0 ?\n            o.DYNAMIC_TYPE :\n            /** @type {?} */ ((o.expressionType(outputCtx.importExpr(this.component.type.reference))));\n        this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\n    }\n    /**\n     * @param {?} variables\n     * @param {?} astNodes\n     * @return {?}\n     */\n    visitAll(variables, astNodes) {\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach((pipe) => {\n                if (pipe.pure) {\n                    this.purePipeNodeIndices[pipe.name] = this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            const /** @type {?} */ queryIds = staticViewQueryIds(this.staticQueryIds);\n            this.component.viewQueries.forEach((query, queryIndex) => {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                const /** @type {?} */ queryId = queryIndex + 1;\n                const /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1 /* All */;\n                const /** @type {?} */ flags = 134217728 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);\n                this.nodes.push(() => ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: o.importExpr(Identifiers.queryDef).callFn([\n                        o.literal(flags), o.literal(queryId),\n                        new o.LiteralMapExpr([new o.LiteralMapEntry(query.propertyName, o.literal(bindingType), false)])\n                    ])\n                }));\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(() => ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: o.importExpr(Identifiers.anchorDef).callFn([\n                    o.literal(0 /* None */), o.NULL_EXPR, o.NULL_EXPR, o.literal(0)\n                ])\n            }));\n        }\n    }\n    /**\n     * @param {?=} targetStatements\n     * @return {?}\n     */\n    build(targetStatements = []) {\n        this.children.forEach((child) => child.build(targetStatements));\n        const { updateRendererStmts, updateDirectivesStmts, nodeDefExprs } = this._createNodeExpressions();\n        const /** @type {?} */ updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        const /** @type {?} */ updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        let /** @type {?} */ viewFlags = 0 /* None */;\n        if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        const /** @type {?} */ viewFactory = new o.DeclareFunctionStmt(this.viewName, [new o.FnParam(/** @type {?} */ ((LOG_VAR.name)))], [new o.ReturnStatement(o.importExpr(Identifiers.viewDef).callFn([\n                o.literal(viewFlags),\n                o.literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], o.importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [o.StmtModifier.Exported] : []);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    }\n    /**\n     * @param {?} updateStmts\n     * @return {?}\n     */\n    _createUpdateFn(updateStmts) {\n        let /** @type {?} */ updateFn;\n        if (updateStmts.length > 0) {\n            const /** @type {?} */ preStmts = [];\n            if (!this.component.isHost && o.findReadVarNames(updateStmts).has(/** @type {?} */ ((COMP_VAR.name)))) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = o.fn([\n                new o.FnParam(/** @type {?} */ ((CHECK_VAR.name)), o.INFERRED_TYPE),\n                new o.FnParam(/** @type {?} */ ((VIEW_VAR.name)), o.INFERRED_TYPE)\n            ], [...preStmts, ...updateStmts], o.INFERRED_TYPE);\n        }\n        else {\n            updateFn = o.NULL_EXPR;\n        }\n        return updateFn;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitNgContent(ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(() => ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 8 /* TypeNgContent */,\n            nodeDef: o.importExpr(Identifiers.ngContentDef).callFn([\n                o.literal(ast.ngContentIndex), o.literal(ast.index)\n            ])\n        }));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitText(ast, context) {\n        // Static text nodes have no check function\n        const /** @type {?} */ checkIndex = -1;\n        this.nodes.push(() => ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: o.importExpr(Identifiers.textDef).callFn([\n                o.literal(checkIndex),\n                o.literal(ast.ngContentIndex),\n                o.literalArr([o.literal(ast.value)]),\n            ])\n        }));\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitBoundText(ast, context) {\n        const /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(/** @type {?} */ ((null)));\n        const /** @type {?} */ astWithSource = /** @type {?} */ (ast.value);\n        const /** @type {?} */ inter = /** @type {?} */ (astWithSource.ast);\n        const /** @type {?} */ updateRendererExpressions = inter.expressions.map((expr, bindingIndex) => this._preprocessUpdateExpression({ nodeIndex, bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }));\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        const /** @type {?} */ checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = () => ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: o.importExpr(Identifiers.textDef).callFn([\n                o.literal(checkIndex),\n                o.literal(ast.ngContentIndex),\n                o.literalArr(inter.strings.map(s => o.literal(s))),\n            ]),\n            updateRenderer: updateRendererExpressions\n        });\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEmbeddedTemplate(ast, context) {\n        const /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(/** @type {?} */ ((null)));\n        const { flags, queryMatchesExpr, hostEvents } = this._visitElementOrTemplate(nodeIndex, ast);\n        const /** @type {?} */ childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        const /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = () => ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: o.importExpr(Identifiers.anchorDef).callFn([\n                o.literal(flags),\n                queryMatchesExpr,\n                o.literal(ast.ngContentIndex),\n                o.literal(childCount),\n                this._createElementHandleEventFn(nodeIndex, hostEvents),\n                o.variable(childVisitor.viewName),\n            ])\n        });\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElement(ast, context) {\n        const /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        // Using a null element name creates an anchor.\n        const /** @type {?} */ elName = isNgContainer(ast.name) ? null : ast.name;\n        const { flags, usedEvents, queryMatchesExpr, hostBindings: dirHostBindings, hostEvents } = this._visitElementOrTemplate(nodeIndex, ast);\n        let /** @type {?} */ inputDefs = [];\n        let /** @type {?} */ updateRendererExpressions = [];\n        let /** @type {?} */ outputDefs = [];\n        if (elName) {\n            const /** @type {?} */ hostBindings = ast.inputs\n                .map((inputAst) => ({\n                context: /** @type {?} */ (COMP_VAR),\n                inputAst,\n                dirAst: /** @type {?} */ (null),\n            }))\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map((hostBinding, bindingIndex) => this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex,\n                        bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }));\n                inputDefs = hostBindings.map(hostBinding => elementBindingDef(hostBinding.inputAst, hostBinding.dirAst));\n            }\n            outputDefs = usedEvents.map(([target, eventName]) => o.literalArr([o.literal(target), o.literal(eventName)]));\n        }\n        templateVisitAll(this, ast.children);\n        const /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        const /** @type {?} */ compAst = ast.directives.find(dirAst => dirAst.directive.isComponent);\n        let /** @type {?} */ compRendererType = /** @type {?} */ (o.NULL_EXPR);\n        let /** @type {?} */ compView = /** @type {?} */ (o.NULL_EXPR);\n        if (compAst) {\n            compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n            compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n        }\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        const /** @type {?} */ checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = () => ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: o.importExpr(Identifiers.elementDef).callFn([\n                o.literal(checkIndex),\n                o.literal(flags),\n                queryMatchesExpr,\n                o.literal(ast.ngContentIndex),\n                o.literal(childCount),\n                o.literal(elName),\n                elName ? fixedAttrsDef(ast) : o.NULL_EXPR,\n                inputDefs.length ? o.literalArr(inputDefs) : o.NULL_EXPR,\n                outputDefs.length ? o.literalArr(outputDefs) : o.NULL_EXPR,\n                this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        });\n    }\n    /**\n     * @param {?} nodeIndex\n     * @param {?} ast\n     * @return {?}\n     */\n    _visitElementOrTemplate(nodeIndex, ast) {\n        let /** @type {?} */ flags = 0 /* None */;\n        if (ast.hasViewContainer) {\n            flags |= 16777216 /* EmbeddedViews */;\n        }\n        const /** @type {?} */ usedEvents = new Map();\n        ast.outputs.forEach((event) => {\n            const { name, target } = elementEventNameAndTarget(event, null);\n            usedEvents.set(elementEventFullName(target, name), [target, name]);\n        });\n        ast.directives.forEach((dirAst) => {\n            dirAst.hostEvents.forEach((event) => {\n                const { name, target } = elementEventNameAndTarget(event, dirAst);\n                usedEvents.set(elementEventFullName(target, name), [target, name]);\n            });\n        });\n        const /** @type {?} */ hostBindings = [];\n        const /** @type {?} */ hostEvents = [];\n        this._visitComponentFactoryResolverProvider(ast.directives);\n        ast.providers.forEach((providerAst, providerIndex) => {\n            let /** @type {?} */ dirAst = /** @type {?} */ ((undefined));\n            let /** @type {?} */ dirIndex = /** @type {?} */ ((undefined));\n            ast.directives.forEach((localDirAst, i) => {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                    dirIndex = i;\n                }\n            });\n            if (dirAst) {\n                const { hostBindings: dirHostBindings, hostEvents: dirHostEvents } = this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, /** @type {?} */ ((this.staticQueryIds.get(/** @type {?} */ (ast)))));\n                hostBindings.push(...dirHostBindings);\n                hostEvents.push(...dirHostEvents);\n            }\n            else {\n                this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        let /** @type {?} */ queryMatchExprs = [];\n        ast.queryMatches.forEach((match) => {\n            let /** @type {?} */ valueType = /** @type {?} */ ((undefined));\n            if (tokenReference(match.value) ===\n                this.reflector.resolveExternalReference(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) ===\n                this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) ===\n                this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(o.literalArr([o.literal(match.queryId), o.literal(valueType)]));\n            }\n        });\n        ast.references.forEach((ref) => {\n            let /** @type {?} */ valueType = /** @type {?} */ ((undefined));\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) ===\n                this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(o.literalArr([o.literal(ref.name), o.literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach((outputAst) => {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: /** @type {?} */ ((null)) });\n        });\n        return {\n            flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n            hostBindings,\n            hostEvents: hostEvents\n        };\n    }\n    /**\n     * @param {?} providerAst\n     * @param {?} dirAst\n     * @param {?} directiveIndex\n     * @param {?} elementNodeIndex\n     * @param {?} refs\n     * @param {?} queryMatches\n     * @param {?} usedEvents\n     * @param {?} queryIds\n     * @return {?}\n     */\n    _visitDirective(providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {\n        const /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        dirAst.directive.queries.forEach((query, queryIndex) => {\n            const /** @type {?} */ queryId = dirAst.contentQueryStartId + queryIndex;\n            const /** @type {?} */ flags = 67108864 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);\n            const /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1 /* All */;\n            this.nodes.push(() => ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: o.importExpr(Identifiers.queryDef).callFn([\n                    o.literal(flags), o.literal(queryId),\n                    new o.LiteralMapExpr([new o.LiteralMapEntry(query.propertyName, o.literal(bindingType), false)])\n                ]),\n            }));\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        const /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        let { flags, queryMatchExprs, providerExpr, depsExpr } = this._visitProviderOrDirective(providerAst, queryMatches);\n        refs.forEach((ref) => {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(o.literalArr([o.literal(ref.name), o.literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 32768 /* Component */;\n        }\n        const /** @type {?} */ inputDefs = dirAst.inputs.map((inputAst, inputIndex) => {\n            const /** @type {?} */ mapValue = o.literalArr([o.literal(inputIndex), o.literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new o.LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        const /** @type {?} */ outputDefs = [];\n        const /** @type {?} */ dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach((propName) => {\n            const /** @type {?} */ eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new o.LiteralMapEntry(propName, o.literal(eventName), false));\n            }\n        });\n        let /** @type {?} */ updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map((input, bindingIndex) => this._preprocessUpdateExpression({\n                    nodeIndex,\n                    bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }));\n        }\n        const /** @type {?} */ dirContextExpr = o.importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n        const /** @type {?} */ hostBindings = dirAst.hostProperties.map((inputAst) => ({\n            context: dirContextExpr,\n            dirAst,\n            inputAst,\n        }));\n        const /** @type {?} */ hostEvents = dirAst.hostEvents.map((hostEventAst) => ({\n            context: dirContextExpr,\n            eventAst: hostEventAst, dirAst,\n        }));\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        const /** @type {?} */ checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = () => ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 16384 /* TypeDirective */ | flags,\n            nodeDef: o.importExpr(Identifiers.directiveDef).callFn([\n                o.literal(checkIndex),\n                o.literal(flags),\n                queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n                o.literal(childCount),\n                providerExpr,\n                depsExpr,\n                inputDefs.length ? new o.LiteralMapExpr(inputDefs) : o.NULL_EXPR,\n                outputDefs.length ? new o.LiteralMapExpr(outputDefs) : o.NULL_EXPR,\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        });\n        return { hostBindings, hostEvents };\n    }\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    _visitProvider(providerAst, queryMatches) {\n        this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n    }\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    _visitComponentFactoryResolverProvider(directives) {\n        const /** @type {?} */ componentDirMeta = directives.find(dirAst => dirAst.directive.isComponent);\n        if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n            const { providerExpr, depsExpr, flags, tokenExpr } = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192 /* PrivateProvider */, componentDirMeta.directive.entryComponents);\n            this._addProviderNode({\n                providerExpr,\n                depsExpr,\n                flags,\n                tokenExpr,\n                queryMatchExprs: [],\n                sourceSpan: componentDirMeta.sourceSpan\n            });\n        }\n    }\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    _addProviderNode(data) {\n        const /** @type {?} */ nodeIndex = this.nodes.length;\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes.push(() => ({\n            sourceSpan: data.sourceSpan,\n            nodeFlags: data.flags,\n            nodeDef: o.importExpr(Identifiers.providerDef).callFn([\n                o.literal(data.flags),\n                data.queryMatchExprs.length ? o.literalArr(data.queryMatchExprs) : o.NULL_EXPR,\n                data.tokenExpr, data.providerExpr, data.depsExpr\n            ])\n        }));\n    }\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    _visitProviderOrDirective(providerAst, queryMatches) {\n        let /** @type {?} */ flags = 0 /* None */;\n        let /** @type {?} */ queryMatchExprs = [];\n        queryMatches.forEach((match) => {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(o.literalArr([o.literal(match.queryId), o.literal(4 /* Provider */)]));\n            }\n        });\n        const { providerExpr, depsExpr, flags: providerFlags, tokenExpr } = providerDef(this.outputCtx, providerAst);\n        return {\n            flags: flags | providerFlags,\n            queryMatchExprs,\n            providerExpr,\n            depsExpr,\n            tokenExpr,\n            sourceSpan: providerAst.sourceSpan\n        };\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    getLocal(name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        let /** @type {?} */ currViewExpr = VIEW_VAR;\n        for (let /** @type {?} */ currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(o.DYNAMIC_TYPE)) {\n            // check references\n            const /** @type {?} */ refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return o.importExpr(Identifiers.nodeValue).callFn([currViewExpr, o.literal(refNodeIndex)]);\n            }\n            // check variables\n            const /** @type {?} */ varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n            if (varAst) {\n                const /** @type {?} */ varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    }\n    /**\n     * @param {?} sourceSpan\n     * @param {?} argCount\n     * @return {?}\n     */\n    _createLiteralArrayConverter(sourceSpan, argCount) {\n        if (argCount === 0) {\n            const /** @type {?} */ valueExpr = o.importExpr(Identifiers.EMPTY_ARRAY);\n            return () => valueExpr;\n        }\n        const /** @type {?} */ checkIndex = this.nodes.length;\n        this.nodes.push(() => ({\n            sourceSpan,\n            nodeFlags: 32 /* TypePureArray */,\n            nodeDef: o.importExpr(Identifiers.pureArrayDef).callFn([\n                o.literal(checkIndex),\n                o.literal(argCount),\n            ])\n        }));\n        return (args) => callCheckStmt(checkIndex, args);\n    }\n    /**\n     * @param {?} sourceSpan\n     * @param {?} keys\n     * @return {?}\n     */\n    _createLiteralMapConverter(sourceSpan, keys) {\n        if (keys.length === 0) {\n            const /** @type {?} */ valueExpr = o.importExpr(Identifiers.EMPTY_MAP);\n            return () => valueExpr;\n        }\n        const /** @type {?} */ map = o.literalMap(keys.map((e, i) => (Object.assign({}, e, { value: o.literal(i) }))));\n        const /** @type {?} */ checkIndex = this.nodes.length;\n        this.nodes.push(() => ({\n            sourceSpan,\n            nodeFlags: 64 /* TypePureObject */,\n            nodeDef: o.importExpr(Identifiers.pureObjectDef).callFn([\n                o.literal(checkIndex),\n                map,\n            ])\n        }));\n        return (args) => callCheckStmt(checkIndex, args);\n    }\n    /**\n     * @param {?} expression\n     * @param {?} name\n     * @param {?} argCount\n     * @return {?}\n     */\n    _createPipeConverter(expression, name, argCount) {\n        const /** @type {?} */ pipe = /** @type {?} */ ((this.usedPipes.find((pipeSummary) => pipeSummary.name === name)));\n        if (pipe.pure) {\n            const /** @type {?} */ checkIndex = this.nodes.length;\n            this.nodes.push(() => ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 128 /* TypePurePipe */,\n                nodeDef: o.importExpr(Identifiers.purePipeDef).callFn([\n                    o.literal(checkIndex),\n                    o.literal(argCount),\n                ])\n            }));\n            // find underlying pipe in the component view\n            let /** @type {?} */ compViewExpr = VIEW_VAR;\n            let /** @type {?} */ compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(o.DYNAMIC_TYPE);\n            }\n            const /** @type {?} */ pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            const /** @type {?} */ pipeValueExpr = o.importExpr(Identifiers.nodeValue).callFn([compViewExpr, o.literal(pipeNodeIndex)]);\n            return (args) => callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex, [pipeValueExpr].concat(args)));\n        }\n        else {\n            const /** @type {?} */ nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            const /** @type {?} */ nodeValueExpr = o.importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n            return (args) => callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr.callMethod('transform', args));\n        }\n    }\n    /**\n     * @param {?} sourceSpan\n     * @param {?} pipe\n     * @return {?}\n     */\n    _createPipe(sourceSpan, pipe) {\n        const /** @type {?} */ nodeIndex = this.nodes.length;\n        let /** @type {?} */ flags = 0 /* None */;\n        pipe.type.lifecycleHooks.forEach((lifecycleHook) => {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === LifecycleHooks.OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        const /** @type {?} */ depExprs = pipe.type.diDeps.map((diDep) => depDef(this.outputCtx, diDep));\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(() => ({\n            sourceSpan,\n            nodeFlags: 16 /* TypePipe */,\n            nodeDef: o.importExpr(Identifiers.pipeDef).callFn([\n                o.literal(flags), this.outputCtx.importExpr(pipe.type.reference), o.literalArr(depExprs)\n            ])\n        }));\n        return nodeIndex;\n    }\n    /**\n     * For the AST in `UpdateExpression.value`:\n     * - create nodes for pipes, literal arrays and, literal maps,\n     * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\n     *\n     * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\n     * @param {?} expression\n     * @return {?}\n     */\n    _preprocessUpdateExpression(expression) {\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: (argCount) => this._createLiteralArrayConverter(expression.sourceSpan, argCount),\n                createLiteralMapConverter: (keys) => this._createLiteralMapConverter(expression.sourceSpan, keys),\n                createPipeConverter: (name, argCount) => this._createPipeConverter(expression, name, argCount)\n            }, expression.value)\n        };\n    }\n    /**\n     * @return {?}\n     */\n    _createNodeExpressions() {\n        const /** @type {?} */ self = this;\n        let /** @type {?} */ updateBindingCount = 0;\n        const /** @type {?} */ updateRendererStmts = [];\n        const /** @type {?} */ updateDirectivesStmts = [];\n        const /** @type {?} */ nodeDefExprs = this.nodes.map((factory, nodeIndex) => {\n            const { nodeDef, nodeFlags, updateDirectives, updateRenderer, sourceSpan } = factory();\n            if (updateRenderer) {\n                updateRendererStmts.push(...createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push(...createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            const /** @type {?} */ logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new o.CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return o.applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts, updateDirectivesStmts, nodeDefExprs };\n        /**\n         * @param {?} nodeIndex\n         * @param {?} sourceSpan\n         * @param {?} expressions\n         * @param {?} allowEmptyExprs\n         * @return {?}\n         */\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            const /** @type {?} */ updateStmts = [];\n            const /** @type {?} */ exprs = expressions.map(({ sourceSpan, context, value }) => {\n                const /** @type {?} */ bindingId = `${updateBindingCount++}`;\n                const /** @type {?} */ nameResolver = context === COMP_VAR ? self : null;\n                const { stmts, currValExpr } = convertPropertyBinding(nameResolver, context, value, bindingId);\n                updateStmts.push(...stmts.map((stmt) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n                return o.applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(o.applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    }\n    /**\n     * @param {?} nodeIndex\n     * @param {?} handlers\n     * @return {?}\n     */\n    _createElementHandleEventFn(nodeIndex, handlers) {\n        const /** @type {?} */ handleEventStmts = [];\n        let /** @type {?} */ handleEventBindingCount = 0;\n        handlers.forEach(({ context, eventAst, dirAst }) => {\n            const /** @type {?} */ bindingId = `${handleEventBindingCount++}`;\n            const /** @type {?} */ nameResolver = context === COMP_VAR ? this : null;\n            const { stmts, allowDefault } = convertActionBinding(nameResolver, context, eventAst.handler, bindingId);\n            const /** @type {?} */ trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            const { target: eventTarget, name: eventName } = elementEventNameAndTarget(eventAst, dirAst);\n            const /** @type {?} */ fullEventName = elementEventFullName(eventTarget, eventName);\n            handleEventStmts.push(o.applySourceSpanToStatementIfNeeded(new o.IfStmt(o.literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        let /** @type {?} */ handleEventFn;\n        if (handleEventStmts.length > 0) {\n            const /** @type {?} */ preStmts = [ALLOW_DEFAULT_VAR.set(o.literal(true)).toDeclStmt(o.BOOL_TYPE)];\n            if (!this.component.isHost && o.findReadVarNames(handleEventStmts).has(/** @type {?} */ ((COMP_VAR.name)))) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = o.fn([\n                new o.FnParam(/** @type {?} */ ((VIEW_VAR.name)), o.INFERRED_TYPE),\n                new o.FnParam(/** @type {?} */ ((EVENT_NAME_VAR.name)), o.INFERRED_TYPE),\n                new o.FnParam(/** @type {?} */ ((EventHandlerVars.event.name)), o.INFERRED_TYPE)\n            ], [...preStmts, ...handleEventStmts, new o.ReturnStatement(ALLOW_DEFAULT_VAR)], o.INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = o.NULL_EXPR;\n        }\n        return handleEventFn;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitDirective(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitDirectiveProperty(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitReference(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitVariable(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitEvent(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitElementProperty(ast, context) { }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitAttr(ast, context) { }\n}\nfunction ViewBuilder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ViewBuilder.prototype.compType;\n    /** @type {?} */\n    ViewBuilder.prototype.nodes;\n    /** @type {?} */\n    ViewBuilder.prototype.purePipeNodeIndices;\n    /** @type {?} */\n    ViewBuilder.prototype.refNodeIndices;\n    /** @type {?} */\n    ViewBuilder.prototype.variables;\n    /** @type {?} */\n    ViewBuilder.prototype.children;\n    /** @type {?} */\n    ViewBuilder.prototype.viewName;\n    /** @type {?} */\n    ViewBuilder.prototype.reflector;\n    /** @type {?} */\n    ViewBuilder.prototype.outputCtx;\n    /** @type {?} */\n    ViewBuilder.prototype.parent;\n    /** @type {?} */\n    ViewBuilder.prototype.component;\n    /** @type {?} */\n    ViewBuilder.prototype.embeddedViewIndex;\n    /** @type {?} */\n    ViewBuilder.prototype.usedPipes;\n    /** @type {?} */\n    ViewBuilder.prototype.staticQueryIds;\n    /** @type {?} */\n    ViewBuilder.prototype.viewBuilderFactory;\n}\n/**\n * @param {?} astNodes\n * @return {?}\n */\nfunction needsAdditionalRootNode(astNodes) {\n    const /** @type {?} */ lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\n/**\n * @param {?} inputAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementBindingDef(inputAst, dirAst) {\n    switch (inputAst.type) {\n        case PropertyBindingType.Attribute:\n            return o.literalArr([\n                o.literal(1 /* TypeElementAttribute */), o.literal(inputAst.name),\n                o.literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Property:\n            return o.literalArr([\n                o.literal(8 /* TypeProperty */), o.literal(inputAst.name),\n                o.literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Animation:\n            const /** @type {?} */ bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return o.literalArr([\n                o.literal(bindingType), o.literal('@' + inputAst.name), o.literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Class:\n            return o.literalArr([o.literal(2 /* TypeElementClass */), o.literal(inputAst.name), o.NULL_EXPR]);\n        case PropertyBindingType.Style:\n            return o.literalArr([\n                o.literal(4 /* TypeElementStyle */), o.literal(inputAst.name), o.literal(inputAst.unit)\n            ]);\n    }\n}\n/**\n * @param {?} elementAst\n * @return {?}\n */\nfunction fixedAttrsDef(elementAst) {\n    const /** @type {?} */ mapResult = Object.create(null);\n    elementAst.attrs.forEach(attrAst => { mapResult[attrAst.name] = attrAst.value; });\n    elementAst.directives.forEach(dirAst => {\n        Object.keys(dirAst.directive.hostAttributes).forEach(name => {\n            const /** @type {?} */ value = dirAst.directive.hostAttributes[name];\n            const /** @type {?} */ prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return o.literalArr(Object.keys(mapResult).sort().map((attrName) => o.literalArr([o.literal(attrName), o.literal(mapResult[attrName])])));\n}\n/**\n * @param {?} attrName\n * @param {?} attrValue1\n * @param {?} attrValue2\n * @return {?}\n */\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {\n        return `${attrValue1} ${attrValue2}`;\n    }\n    else {\n        return attrValue2;\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} exprs\n * @return {?}\n */\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, o.literal(nodeIndex), o.literal(1 /* Dynamic */), o.literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn([VIEW_VAR, o.literal(nodeIndex), o.literal(0 /* Inline */), ...exprs]);\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} bindingIdx\n * @param {?} expr\n * @return {?}\n */\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return o.importExpr(Identifiers.unwrapValue).callFn([\n        VIEW_VAR, o.literal(nodeIndex), o.literal(bindingIdx), expr\n    ]);\n}\n/**\n * @record\n */\nfunction StaticAndDynamicQueryIds() { }\nfunction StaticAndDynamicQueryIds_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StaticAndDynamicQueryIds.prototype.staticQueryIds;\n    /** @type {?} */\n    StaticAndDynamicQueryIds.prototype.dynamicQueryIds;\n}\n/**\n * @param {?} nodes\n * @param {?=} result\n * @return {?}\n */\nfunction findStaticQueryIds(nodes, result = new Map()) {\n    nodes.forEach((node) => {\n        const /** @type {?} */ staticQueryIds = new Set();\n        const /** @type {?} */ dynamicQueryIds = new Set();\n        let /** @type {?} */ queryMatches = /** @type {?} */ ((undefined));\n        if (node instanceof ElementAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach((child) => {\n                const /** @type {?} */ childData = /** @type {?} */ ((result.get(child)));\n                childData.staticQueryIds.forEach(queryId => staticQueryIds.add(queryId));\n                childData.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n            });\n            queryMatches = node.queryMatches;\n        }\n        else if (node instanceof EmbeddedTemplateAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach((child) => {\n                const /** @type {?} */ childData = /** @type {?} */ ((result.get(child)));\n                childData.staticQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n                childData.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n            });\n            queryMatches = node.queryMatches;\n        }\n        if (queryMatches) {\n            queryMatches.forEach((match) => staticQueryIds.add(match.queryId));\n        }\n        dynamicQueryIds.forEach(queryId => staticQueryIds.delete(queryId));\n        result.set(node, { staticQueryIds, dynamicQueryIds });\n    });\n    return result;\n}\n/**\n * @param {?} nodeStaticQueryIds\n * @return {?}\n */\nfunction staticViewQueryIds(nodeStaticQueryIds) {\n    const /** @type {?} */ staticQueryIds = new Set();\n    const /** @type {?} */ dynamicQueryIds = new Set();\n    Array.from(nodeStaticQueryIds.values()).forEach((entry) => {\n        entry.staticQueryIds.forEach(queryId => staticQueryIds.add(queryId));\n        entry.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n    });\n    dynamicQueryIds.forEach(queryId => staticQueryIds.delete(queryId));\n    return { staticQueryIds, dynamicQueryIds };\n}\n/**\n * @param {?} eventAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: `@${eventAst.name}.${eventAst.phase}`,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\n/**\n * @param {?} queryIds\n * @param {?} queryId\n * @param {?} isFirst\n * @return {?}\n */\nfunction calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {\n    let /** @type {?} */ flags = 0 /* None */;\n    // Note: We only make queries static that query for a single item.\n    // This is because of backwards compatibility with the old view compiler...\n    if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {\n        flags |= 268435456 /* StaticQuery */;\n    }\n    else {\n        flags |= 536870912 /* DynamicQuery */;\n    }\n    return flags;\n}\n/**\n * @param {?} target\n * @param {?} name\n * @return {?}\n */\nexport function elementEventFullName(target, name) {\n    return target ? `${target}:${name}` : name;\n}\n//# sourceMappingURL=view_compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { extractMessages } from \"./extractor_merger\";\nimport * as i18n from \"./i18n_ast\";\n/**\n * A container for message extracted from the templates.\n */\nexport class MessageBundle {\n    /**\n     * @param {?} _htmlParser\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     * @param {?=} _locale\n     */\n    constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null) {\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    /**\n     * @param {?} html\n     * @param {?} url\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    updateFromTemplate(html, url, interpolationConfig) {\n        const /** @type {?} */ htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        const /** @type {?} */ i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        this._messages.push(...i18nParserResult.messages);\n        return [];\n    }\n    /**\n     * @return {?}\n     */\n    getMessages() { return this._messages; }\n    /**\n     * @param {?} serializer\n     * @param {?=} filterSources\n     * @return {?}\n     */\n    write(serializer, filterSources) {\n        const /** @type {?} */ messages = {};\n        const /** @type {?} */ mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(message => {\n            const /** @type {?} */ id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                messages[id].sources.push(...message.sources);\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        const /** @type {?} */ msgList = Object.keys(messages).map(id => {\n            const /** @type {?} */ mapper = serializer.createNameMapper(messages[id]);\n            const /** @type {?} */ src = messages[id];\n            const /** @type {?} */ nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            let /** @type {?} */ transformedMessage = new i18n.Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach((source) => source.filePath = filterSources(source.filePath));\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    }\n}\nfunction MessageBundle_tsickle_Closure_declarations() {\n    /** @type {?} */\n    MessageBundle.prototype._messages;\n    /** @type {?} */\n    MessageBundle.prototype._htmlParser;\n    /** @type {?} */\n    MessageBundle.prototype._implicitTags;\n    /** @type {?} */\n    MessageBundle.prototype._implicitAttrs;\n    /** @type {?} */\n    MessageBundle.prototype._locale;\n}\nclass MapPlaceholderNames extends i18n.CloneVisitor {\n    /**\n     * @param {?} nodes\n     * @param {?} mapper\n     * @return {?}\n     */\n    convert(nodes, mapper) {\n        return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n    }\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    visitTagPlaceholder(ph, mapper) {\n        const /** @type {?} */ startName = /** @type {?} */ ((mapper.toPublicName(ph.startName)));\n        const /** @type {?} */ closeName = ph.closeName ? /** @type {?} */ ((mapper.toPublicName(ph.closeName))) : ph.closeName;\n        const /** @type {?} */ children = ph.children.map(n => n.visit(this, mapper));\n        return new i18n.TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    }\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    visitPlaceholder(ph, mapper) {\n        return new i18n.Placeholder(ph.value, /** @type {?} */ ((mapper.toPublicName(ph.name))), ph.sourceSpan);\n    }\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    visitIcuPlaceholder(ph, mapper) {\n        return new i18n.IcuPlaceholder(ph.value, /** @type {?} */ ((mapper.toPublicName(ph.name))), ph.sourceSpan);\n    }\n}\n//# sourceMappingURL=message_bundle.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { areAllEquivalent } from \"../output/output_ast\";\nimport { TypeScriptEmitter } from \"../output/ts_emitter\";\nexport class GeneratedFile {\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} sourceOrStmts\n     */\n    constructor(srcFileUrl, genFileUrl, sourceOrStmts) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        if (typeof sourceOrStmts === 'string') {\n            this.source = sourceOrStmts;\n            this.stmts = null;\n        }\n        else {\n            this.source = null;\n            this.stmts = sourceOrStmts;\n        }\n    }\n    /**\n     * @param {?} other\n     * @return {?}\n     */\n    isEquivalent(other) {\n        if (this.genFileUrl !== other.genFileUrl) {\n            return false;\n        }\n        if (this.source) {\n            return this.source === other.source;\n        }\n        if (other.stmts == null) {\n            return false;\n        }\n        // Note: the constructor guarantees that if this.source is not filled,\n        // then this.stmts is.\n        return areAllEquivalent(/** @type {?} */ ((this.stmts)), /** @type {?} */ ((other.stmts)));\n    }\n}\nfunction GeneratedFile_tsickle_Closure_declarations() {\n    /** @type {?} */\n    GeneratedFile.prototype.source;\n    /** @type {?} */\n    GeneratedFile.prototype.stmts;\n    /** @type {?} */\n    GeneratedFile.prototype.srcFileUrl;\n    /** @type {?} */\n    GeneratedFile.prototype.genFileUrl;\n}\n/**\n * @param {?} file\n * @param {?=} preamble\n * @return {?}\n */\nexport function toTypeScript(file, preamble = '') {\n    if (!file.stmts) {\n        throw new Error(`Illegal state: No stmts present on GeneratedFile ${file.genFileUrl}`);\n    }\n    return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);\n}\n//# sourceMappingURL=generated_file.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { tokenReference } from \"../compile_metadata\";\n/**\n * @record\n */\nexport function LazyRoute() { }\nfunction LazyRoute_tsickle_Closure_declarations() {\n    /** @type {?} */\n    LazyRoute.prototype.module;\n    /** @type {?} */\n    LazyRoute.prototype.route;\n    /** @type {?} */\n    LazyRoute.prototype.referencedModule;\n}\n/**\n * @param {?} moduleMeta\n * @param {?} reflector\n * @return {?}\n */\nexport function listLazyRoutes(moduleMeta, reflector) {\n    const /** @type {?} */ allLazyRoutes = [];\n    for (const { provider, module } of moduleMeta.transitiveModule.providers) {\n        if (tokenReference(provider.token) === reflector.ROUTES) {\n            const /** @type {?} */ loadChildren = _collectLoadChildren(provider.useValue);\n            for (const /** @type {?} */ route of loadChildren) {\n                allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n            }\n        }\n    }\n    return allLazyRoutes;\n}\n/**\n * @param {?} routes\n * @param {?=} target\n * @return {?}\n */\nfunction _collectLoadChildren(routes, target = []) {\n    if (typeof routes === 'string') {\n        target.push(routes);\n    }\n    else if (Array.isArray(routes)) {\n        for (const /** @type {?} */ route of routes) {\n            _collectLoadChildren(route, target);\n        }\n    }\n    else if (routes.loadChildren) {\n        _collectLoadChildren(routes.loadChildren, target);\n    }\n    else if (routes.children) {\n        _collectLoadChildren(routes.children, target);\n    }\n    return target;\n}\n/**\n * @param {?} route\n * @param {?} reflector\n * @param {?=} module\n * @return {?}\n */\nexport function parseLazyRoute(route, reflector, module) {\n    const [routePath, routeName] = route.split('#');\n    const /** @type {?} */ referencedModule = reflector.resolveExternalReference({\n        moduleName: routePath,\n        name: routeName,\n    }, module ? module.filePath : undefined);\n    return { route: route, module: module || referencedModule, referencedModule };\n}\n//# sourceMappingURL=lazy_routes.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CompileNgModuleMetadata, CompileSummaryKind } from \"../compile_metadata\";\nimport * as o from \"../output/output_ast\";\nimport { ValueTransformer, visitValue } from \"../util\";\nimport { StaticSymbol } from \"./static_symbol\";\nimport { isLoweredSymbol, ngfactoryFilePath, summaryForJitFileName, summaryForJitName } from \"./util\";\n/**\n * @param {?} srcFileName\n * @param {?} forJitCtx\n * @param {?} summaryResolver\n * @param {?} symbolResolver\n * @param {?} symbols\n * @param {?} types\n * @return {?}\n */\nexport function serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types) {\n    const /** @type {?} */ toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach((resolvedSymbol) => toJsonSerializer.addSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }));\n    // Add type summaries.\n    types.forEach(({ summary, metadata }) => {\n        toJsonSerializer.addSummary({ symbol: summary.type.reference, metadata: undefined, type: summary });\n    });\n    const { json, exportAs } = toJsonSerializer.serialize();\n    if (forJitCtx) {\n        const /** @type {?} */ forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n        types.forEach(({ summary, metadata }) => { forJitSerializer.addSourceType(summary, metadata); });\n        toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach((summary) => {\n            if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n                forJitSerializer.addLibType(summary.type);\n            }\n        });\n        forJitSerializer.serialize(exportAs);\n    }\n    return { json, exportAs };\n}\n/**\n * @param {?} symbolCache\n * @param {?} summaryResolver\n * @param {?} libraryFileName\n * @param {?} json\n * @return {?}\n */\nexport function deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {\n    const /** @type {?} */ deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n    return deserializer.deserialize(libraryFileName, json);\n}\n/**\n * @param {?} outputCtx\n * @param {?} reference\n * @return {?}\n */\nexport function createForJitStub(outputCtx, reference) {\n    return createSummaryForJitFunction(outputCtx, reference, o.NULL_EXPR);\n}\n/**\n * @param {?} outputCtx\n * @param {?} reference\n * @param {?} value\n * @return {?}\n */\nfunction createSummaryForJitFunction(outputCtx, reference, value) {\n    const /** @type {?} */ fnName = summaryForJitName(reference.name);\n    outputCtx.statements.push(o.fn([], [new o.ReturnStatement(value)], new o.ArrayType(o.DYNAMIC_TYPE)).toDeclStmt(fnName, [\n        o.StmtModifier.Final, o.StmtModifier.Exported\n    ]));\n}\n/** @enum {number} */\nconst SerializationFlags = {\n    None: 0,\n    ResolveValue: 1,\n};\nclass ToJsonSerializer extends ValueTransformer {\n    /**\n     * @param {?} symbolResolver\n     * @param {?} summaryResolver\n     * @param {?} srcFileName\n     */\n    constructor(symbolResolver, summaryResolver, srcFileName) {\n        super();\n        this.symbolResolver = symbolResolver;\n        this.summaryResolver = summaryResolver;\n        this.srcFileName = srcFileName;\n        this.symbols = [];\n        this.indexBySymbol = new Map();\n        this.reexportedBy = new Map();\n        this.processedSummaryBySymbol = new Map();\n        this.processedSummaries = [];\n        this.unprocessedSymbolSummariesBySymbol = new Map();\n        this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    addSummary(summary) {\n        let /** @type {?} */ unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n        let /** @type {?} */ processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!unprocessedSummary) {\n            unprocessedSummary = { symbol: summary.symbol, metadata: undefined };\n            this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n            processedSummary = { symbol: this.processValue(summary.symbol, 0 /* None */) };\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        if (!unprocessedSummary.metadata && summary.metadata) {\n            let /** @type {?} */ metadata = summary.metadata || {};\n            if (metadata.__symbolic === 'class') {\n                // For classes, we keep everything except their class decorators.\n                // We need to keep e.g. the ctor args, method names, method decorators\n                // so that the class can be extended in another compilation unit.\n                // We don't keep the class decorators as\n                // 1) they refer to data\n                //   that should not cause a rebuild of downstream compilation units\n                //   (e.g. inline templates of @Component, or @NgModule.declarations)\n                // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n                const /** @type {?} */ clone = {};\n                Object.keys(metadata).forEach((propName) => {\n                    if (propName !== 'decorators') {\n                        clone[propName] = metadata[propName];\n                    }\n                });\n                metadata = clone;\n            }\n            else if (isCall(metadata)) {\n                if (!isFunctionCall(metadata) && !isMethodCallOnVariable(metadata)) {\n                    // Don't store complex calls as we won't be able to simplify them anyways later on.\n                    metadata = {\n                        __symbolic: 'error',\n                        message: 'Complex function calls are not supported.',\n                    };\n                }\n            }\n            // Note: We need to keep storing ctor calls for e.g.\n            // `export const x = new InjectionToken(...)`\n            unprocessedSummary.metadata = metadata;\n            processedSummary.metadata = this.processValue(metadata, 1 /* ResolveValue */);\n            if (metadata instanceof StaticSymbol &&\n                this.summaryResolver.isLibraryFile(metadata.filePath)) {\n                const /** @type {?} */ declarationSymbol = this.symbols[/** @type {?} */ ((this.indexBySymbol.get(metadata)))];\n                if (!isLoweredSymbol(declarationSymbol.name)) {\n                    // Note: symbols that were introduced during codegen in the user file can have a reexport\n                    // if a user used `export *`. However, we can't rely on this as tsickle will change\n                    // `export *` into named exports, using only the information from the typechecker.\n                    // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n                    // and omits them when expanding `export *`.\n                    // So we have to keep reexporting these symbols manually via .ngfactory files.\n                    this.reexportedBy.set(declarationSymbol, summary.symbol);\n                }\n            }\n        }\n        if (!unprocessedSummary.type && summary.type) {\n            unprocessedSummary.type = summary.type;\n            // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n            // as the type summaries already contain the transitive data that they require\n            // (in a minimal way).\n            processedSummary.type = this.processValue(summary.type, 0 /* None */);\n            // except for reexported directives / pipes, so we need to store\n            // their summaries explicitly.\n            if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\n                const /** @type {?} */ ngModuleSummary = /** @type {?} */ (summary.type);\n                ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach((id) => {\n                    const /** @type {?} */ symbol = id.reference;\n                    if (this.summaryResolver.isLibraryFile(symbol.filePath) &&\n                        !this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n                        const /** @type {?} */ summary = this.summaryResolver.resolveSummary(symbol);\n                        if (summary) {\n                            this.addSummary(summary);\n                        }\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    serialize() {\n        const /** @type {?} */ exportAs = [];\n        const /** @type {?} */ json = JSON.stringify({\n            moduleName: this.moduleName,\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map((symbol, index) => {\n                symbol.assertNoMembers();\n                let /** @type {?} */ importAs = /** @type {?} */ ((undefined));\n                if (this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    const /** @type {?} */ reexportSymbol = this.reexportedBy.get(symbol);\n                    if (reexportSymbol) {\n                        importAs = /** @type {?} */ ((this.indexBySymbol.get(reexportSymbol)));\n                    }\n                    else {\n                        const /** @type {?} */ summary = this.unprocessedSymbolSummariesBySymbol.get(symbol);\n                        if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n                            importAs = `${symbol.name}_${index}`;\n                            exportAs.push({ symbol, exportAs: importAs });\n                        }\n                    }\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    filePath: this.summaryResolver.toSummaryFileName(symbol.filePath, this.srcFileName),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json, exportAs };\n    }\n    /**\n     * @param {?} value\n     * @param {?} flags\n     * @return {?}\n     */\n    processValue(value, flags) {\n        return visitValue(value, this, flags);\n    }\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    visitOther(value, context) {\n        if (value instanceof StaticSymbol) {\n            let /** @type {?} */ baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            const /** @type {?} */ index = this.visitStaticSymbol(baseSymbol, context);\n            return { __symbol: index, members: value.members };\n        }\n    }\n    /**\n     * Returns null if the options.resolveValue is true, and the summary for the symbol\n     * resolved to a type or could not be resolved.\n     * @param {?} baseSymbol\n     * @param {?} flags\n     * @return {?}\n     */\n    visitStaticSymbol(baseSymbol, flags) {\n        let /** @type {?} */ index = this.indexBySymbol.get(baseSymbol);\n        let /** @type {?} */ summary = null;\n        if (flags & 1 /* ResolveValue */ &&\n            this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n            if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n                // the summary for this symbol was already added\n                // -> nothing to do.\n                return /** @type {?} */ ((index));\n            }\n            summary = this.loadSummary(baseSymbol);\n            if (summary && summary.metadata instanceof StaticSymbol) {\n                // The summary is a reexport\n                index = this.visitStaticSymbol(summary.metadata, flags);\n                // reset the summary as it is just a reexport, so we don't want to store it.\n                summary = null;\n            }\n        }\n        else if (index != null) {\n            // Note: == on purpose to compare with undefined!\n            // No summary and the symbol is already added -> nothing to do.\n            return index;\n        }\n        // Note: == on purpose to compare with undefined!\n        if (index == null) {\n            index = this.symbols.length;\n            this.symbols.push(baseSymbol);\n        }\n        this.indexBySymbol.set(baseSymbol, index);\n        if (summary) {\n            this.addSummary(summary);\n        }\n        return index;\n    }\n    /**\n     * @param {?} symbol\n     * @return {?}\n     */\n    loadSummary(symbol) {\n        let /** @type {?} */ summary = this.summaryResolver.resolveSummary(symbol);\n        if (!summary) {\n            // some symbols might originate from a plain typescript library\n            // that just exported .d.ts and .metadata.json files, i.e. where no summary\n            // files were created.\n            const /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n            if (resolvedSymbol) {\n                summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n            }\n        }\n        return summary;\n    }\n}\nfunction ToJsonSerializer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ToJsonSerializer.prototype.symbols;\n    /** @type {?} */\n    ToJsonSerializer.prototype.indexBySymbol;\n    /** @type {?} */\n    ToJsonSerializer.prototype.reexportedBy;\n    /** @type {?} */\n    ToJsonSerializer.prototype.processedSummaryBySymbol;\n    /** @type {?} */\n    ToJsonSerializer.prototype.processedSummaries;\n    /** @type {?} */\n    ToJsonSerializer.prototype.moduleName;\n    /** @type {?} */\n    ToJsonSerializer.prototype.unprocessedSymbolSummariesBySymbol;\n    /** @type {?} */\n    ToJsonSerializer.prototype.symbolResolver;\n    /** @type {?} */\n    ToJsonSerializer.prototype.summaryResolver;\n    /** @type {?} */\n    ToJsonSerializer.prototype.srcFileName;\n}\nclass ForJitSerializer {\n    /**\n     * @param {?} outputCtx\n     * @param {?} symbolResolver\n     * @param {?} summaryResolver\n     */\n    constructor(outputCtx, symbolResolver, summaryResolver) {\n        this.outputCtx = outputCtx;\n        this.symbolResolver = symbolResolver;\n        this.summaryResolver = summaryResolver;\n        this.data = [];\n    }\n    /**\n     * @param {?} summary\n     * @param {?} metadata\n     * @return {?}\n     */\n    addSourceType(summary, metadata) {\n        this.data.push({ summary, metadata, isLibrary: false });\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    addLibType(summary) {\n        this.data.push({ summary, metadata: null, isLibrary: true });\n    }\n    /**\n     * @param {?} exportAsArr\n     * @return {?}\n     */\n    serialize(exportAsArr) {\n        const /** @type {?} */ exportAsBySymbol = new Map();\n        for (const { symbol, exportAs } of exportAsArr) {\n            exportAsBySymbol.set(symbol, exportAs);\n        }\n        const /** @type {?} */ ngModuleSymbols = new Set();\n        for (const { summary, metadata, isLibrary } of this.data) {\n            if (summary.summaryKind === CompileSummaryKind.NgModule) {\n                // collect the symbols that refer to NgModule classes.\n                // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n                // we don't add the summaries of all referenced symbols when we serialize type summaries.\n                // See serializeSummaries for details.\n                ngModuleSymbols.add(summary.type.reference);\n                const /** @type {?} */ modSummary = /** @type {?} */ (summary);\n                for (const /** @type {?} */ mod of modSummary.modules) {\n                    ngModuleSymbols.add(mod.reference);\n                }\n            }\n            if (!isLibrary) {\n                const /** @type {?} */ fnName = summaryForJitName(summary.type.reference.name);\n                createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, /** @type {?} */ ((metadata))));\n            }\n        }\n        ngModuleSymbols.forEach((ngModuleSymbol) => {\n            if (this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n                let /** @type {?} */ exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n                const /** @type {?} */ jitExportAsName = summaryForJitName(exportAs);\n                this.outputCtx.statements.push(o.variable(jitExportAsName)\n                    .set(this.serializeSummaryRef(ngModuleSymbol))\n                    .toDeclStmt(null, [o.StmtModifier.Exported]));\n            }\n        });\n    }\n    /**\n     * @param {?} summary\n     * @param {?} metadata\n     * @return {?}\n     */\n    serializeSummaryWithDeps(summary, metadata) {\n        const /** @type {?} */ expressions = [this.serializeSummary(summary)];\n        let /** @type {?} */ providers = [];\n        if (metadata instanceof CompileNgModuleMetadata) {\n            expressions.push(...\n            // For directives / pipes, we only add the declared ones,\n            // and rely on transitively importing NgModules to get the transitive\n            // summaries.\n            metadata.declaredDirectives.concat(metadata.declaredPipes)\n                .map(type => type.reference)\n                .concat(metadata.transitiveModule.modules.map(type => type.reference)\n                .filter(ref => ref !== metadata.type.reference))\n                .map((ref) => this.serializeSummaryRef(ref)));\n            // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n            // and we already have transitive modules.\n            providers = metadata.providers;\n        }\n        else if (summary.summaryKind === CompileSummaryKind.Directive) {\n            const /** @type {?} */ dirSummary = /** @type {?} */ (summary);\n            providers = dirSummary.providers.concat(dirSummary.viewProviders);\n        }\n        // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n        // declaredDirectives / declaredPipes), as we allow\n        // providers without ctor arguments to skip the `@Injectable` decorator,\n        // i.e. we didn't generate .ngsummary.ts files for these.\n        expressions.push(...providers.filter(provider => !!provider.useClass).map(provider => this.serializeSummary(/** @type {?} */ ({\n            summaryKind: CompileSummaryKind.Injectable, type: provider.useClass\n        }))));\n        return o.literalArr(expressions);\n    }\n    /**\n     * @param {?} typeSymbol\n     * @return {?}\n     */\n    serializeSummaryRef(typeSymbol) {\n        const /** @type {?} */ jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n        return this.outputCtx.importExpr(jitImportedSymbol);\n    }\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    serializeSummary(data) {\n        const /** @type {?} */ outputCtx = this.outputCtx;\n        class Transformer {\n            /**\n             * @param {?} arr\n             * @param {?} context\n             * @return {?}\n             */\n            visitArray(arr, context) {\n                return o.literalArr(arr.map(entry => visitValue(entry, this, context)));\n            }\n            /**\n             * @param {?} map\n             * @param {?} context\n             * @return {?}\n             */\n            visitStringMap(map, context) {\n                return new o.LiteralMapExpr(Object.keys(map).map((key) => new o.LiteralMapEntry(key, visitValue(map[key], this, context), false)));\n            }\n            /**\n             * @param {?} value\n             * @param {?} context\n             * @return {?}\n             */\n            visitPrimitive(value, context) { return o.literal(value); }\n            /**\n             * @param {?} value\n             * @param {?} context\n             * @return {?}\n             */\n            visitOther(value, context) {\n                if (value instanceof StaticSymbol) {\n                    return outputCtx.importExpr(value);\n                }\n                else {\n                    throw new Error(`Illegal State: Encountered value ${value}`);\n                }\n            }\n        }\n        return visitValue(data, new Transformer(), null);\n    }\n}\nfunction ForJitSerializer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ForJitSerializer.prototype.data;\n    /** @type {?} */\n    ForJitSerializer.prototype.outputCtx;\n    /** @type {?} */\n    ForJitSerializer.prototype.symbolResolver;\n    /** @type {?} */\n    ForJitSerializer.prototype.summaryResolver;\n}\nclass FromJsonDeserializer extends ValueTransformer {\n    /**\n     * @param {?} symbolCache\n     * @param {?} summaryResolver\n     */\n    constructor(symbolCache, summaryResolver) {\n        super();\n        this.symbolCache = symbolCache;\n        this.summaryResolver = summaryResolver;\n    }\n    /**\n     * @param {?} libraryFileName\n     * @param {?} json\n     * @return {?}\n     */\n    deserialize(libraryFileName, json) {\n        const /** @type {?} */ data = JSON.parse(json);\n        const /** @type {?} */ allImportAs = [];\n        this.symbols = data.symbols.map((serializedSymbol) => this.symbolCache.get(this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name));\n        data.symbols.forEach((serializedSymbol, index) => {\n            const /** @type {?} */ symbol = this.symbols[index];\n            const /** @type {?} */ importAs = serializedSymbol.importAs;\n            if (typeof importAs === 'number') {\n                allImportAs.push({ symbol, importAs: this.symbols[importAs] });\n            }\n            else if (typeof importAs === 'string') {\n                allImportAs.push({ symbol, importAs: this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs) });\n            }\n        });\n        const /** @type {?} */ summaries = /** @type {?} */ (visitValue(data.summaries, this, null));\n        return { moduleName: data.moduleName, summaries, importAs: allImportAs };\n    }\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    visitStringMap(map, context) {\n        if ('__symbol' in map) {\n            const /** @type {?} */ baseSymbol = this.symbols[map['__symbol']];\n            const /** @type {?} */ members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return super.visitStringMap(map, context);\n        }\n    }\n}\nfunction FromJsonDeserializer_tsickle_Closure_declarations() {\n    /** @type {?} */\n    FromJsonDeserializer.prototype.symbols;\n    /** @type {?} */\n    FromJsonDeserializer.prototype.symbolCache;\n    /** @type {?} */\n    FromJsonDeserializer.prototype.summaryResolver;\n}\n/**\n * @param {?} metadata\n * @return {?}\n */\nfunction isCall(metadata) {\n    return metadata && metadata.__symbolic === 'call';\n}\n/**\n * @param {?} metadata\n * @return {?}\n */\nfunction isFunctionCall(metadata) {\n    return isCall(metadata) && metadata.expression instanceof StaticSymbol;\n}\n/**\n * @param {?} metadata\n * @return {?}\n */\nfunction isMethodCallOnVariable(metadata) {\n    return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' &&\n        metadata.expression.expression instanceof StaticSymbol;\n}\n//# sourceMappingURL=summary_serializer.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { componentFactoryName, flatten, identifierName, templateSourceUrl } from \"../compile_metadata\";\nimport { ViewEncapsulation } from \"../core\";\nimport { MessageBundle } from \"../i18n/message_bundle\";\nimport { Identifiers, createTokenForExternalReference } from \"../identifiers\";\nimport { HtmlParser } from \"../ml_parser/html_parser\";\nimport { InterpolationConfig } from \"../ml_parser/interpolation_config\";\nimport * as o from \"../output/output_ast\";\nimport { syntaxError, visitValue } from \"../util\";\nimport { GeneratedFile } from \"./generated_file\";\nimport { listLazyRoutes, parseLazyRoute } from \"./lazy_routes\";\nimport { StaticSymbol } from \"./static_symbol\";\nimport { createForJitStub, serializeSummaries } from \"./summary_serializer\";\nimport { ngfactoryFilePath, splitTypescriptSuffix, summaryFileName, summaryForJitFileName } from \"./util\";\n/** @enum {number} */\nconst StubEmitFlags = {\n    Basic: 1,\n    TypeCheck: 2,\n    All: 3,\n};\nStubEmitFlags[StubEmitFlags.Basic] = \"Basic\";\nStubEmitFlags[StubEmitFlags.TypeCheck] = \"TypeCheck\";\nStubEmitFlags[StubEmitFlags.All] = \"All\";\nexport class AotCompiler {\n    /**\n     * @param {?} _config\n     * @param {?} _options\n     * @param {?} _host\n     * @param {?} _reflector\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _typeCheckCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _outputEmitter\n     * @param {?} _summaryResolver\n     * @param {?} _symbolResolver\n     */\n    constructor(_config, _options, _host, _reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {\n        this._config = _config;\n        this._options = _options;\n        this._host = _host;\n        this._reflector = _reflector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._typeCheckCompiler = _typeCheckCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._symbolResolver = _symbolResolver;\n        this._templateAstCache = new Map();\n        this._analyzedFiles = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    clearCache() { this._metadataResolver.clearCache(); }\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    analyzeModulesSync(rootFiles) {\n        const /** @type {?} */ analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n        analyzeResult.ngModules.forEach(ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true));\n        return analyzeResult;\n    }\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    analyzeModulesAsync(rootFiles) {\n        const /** @type {?} */ analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n        return Promise\n            .all(analyzeResult.ngModules.map(ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false)))\n            .then(() => analyzeResult);\n    }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    _analyzeFile(fileName) {\n        let /** @type {?} */ analyzedFile = this._analyzedFiles.get(fileName);\n        if (!analyzedFile) {\n            analyzedFile =\n                analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n            this._analyzedFiles.set(fileName, analyzedFile);\n        }\n        return analyzedFile;\n    }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    findGeneratedFileNames(fileName) {\n        const /** @type {?} */ genFileNames = [];\n        const /** @type {?} */ file = this._analyzeFile(fileName);\n        // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n        // or a reference to a non source file.\n        // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n        // Only do this for StubEmitFlags.Basic, as adding a type check block\n        // does not change this file (as we generate type check blocks based on NgModules).\n        if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\n            file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n            genFileNames.push(ngfactoryFilePath(file.fileName, true));\n            if (this._options.enableSummariesForJit) {\n                genFileNames.push(summaryForJitFileName(file.fileName, true));\n            }\n        }\n        const /** @type {?} */ fileSuffix = splitTypescriptSuffix(file.fileName, true)[1];\n        file.directives.forEach((dirSymbol) => {\n            const /** @type {?} */ compMeta = /** @type {?} */ ((this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol))).metadata;\n            if (!compMeta.isComponent) {\n                return;\n            } /** @type {?} */\n            ((\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template)).styleUrls.forEach((styleUrl) => {\n                const /** @type {?} */ normalizedUrl = this._host.resourceNameToFileName(styleUrl, file.fileName);\n                if (!normalizedUrl) {\n                    throw syntaxError(`Couldn't resolve resource ${styleUrl} relative to ${file.fileName}`);\n                }\n                const /** @type {?} */ needsShim = (/** @type {?} */ ((compMeta.template)).encapsulation || this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n                genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n                if (this._options.allowEmptyCodegenFiles) {\n                    genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n                }\n            });\n        });\n        return genFileNames;\n    }\n    /**\n     * @param {?} genFileName\n     * @param {?=} originalFileName\n     * @return {?}\n     */\n    emitBasicStub(genFileName, originalFileName) {\n        const /** @type {?} */ outputCtx = this._createOutputContext(genFileName);\n        if (genFileName.endsWith('.ngfactory.ts')) {\n            if (!originalFileName) {\n                throw new Error(`Assertion error: require the original file for .ngfactory.ts stubs. File: ${genFileName}`);\n            }\n            const /** @type {?} */ originalFile = this._analyzeFile(originalFileName);\n            this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.Basic);\n        }\n        else if (genFileName.endsWith('.ngsummary.ts')) {\n            if (this._options.enableSummariesForJit) {\n                if (!originalFileName) {\n                    throw new Error(`Assertion error: require the original file for .ngsummary.ts stubs. File: ${genFileName}`);\n                }\n                const /** @type {?} */ originalFile = this._analyzeFile(originalFileName);\n                _createEmptyStub(outputCtx);\n                originalFile.ngModules.forEach(ngModule => {\n                    // create exports that user code can reference\n                    createForJitStub(outputCtx, ngModule.type.reference);\n                });\n            }\n        }\n        else if (genFileName.endsWith('.ngstyle.ts')) {\n            _createEmptyStub(outputCtx);\n        }\n        // Note: for the stubs, we don't need a property srcFileUrl,\n        // as lateron in emitAllImpls we will create the proper GeneratedFiles with the\n        // correct srcFileUrl.\n        // This is good as e.g. for .ngstyle.ts files we can't derive\n        // the url of components based on the genFileUrl.\n        return this._codegenSourceModule('unknown', outputCtx);\n    }\n    /**\n     * @param {?} genFileName\n     * @param {?} originalFileName\n     * @return {?}\n     */\n    emitTypeCheckStub(genFileName, originalFileName) {\n        const /** @type {?} */ originalFile = this._analyzeFile(originalFileName);\n        const /** @type {?} */ outputCtx = this._createOutputContext(genFileName);\n        if (genFileName.endsWith('.ngfactory.ts')) {\n            this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.TypeCheck);\n        }\n        return outputCtx.statements.length > 0 ?\n            this._codegenSourceModule(originalFile.fileName, outputCtx) :\n            null;\n    }\n    /**\n     * @param {?} fileNames\n     * @return {?}\n     */\n    loadFilesAsync(fileNames) {\n        const /** @type {?} */ files = fileNames.map(fileName => this._analyzeFile(fileName));\n        const /** @type {?} */ loadingPromises = [];\n        files.forEach(file => file.ngModules.forEach(ngModule => loadingPromises.push(this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false))));\n        return Promise.all(loadingPromises).then(_ => mergeAndValidateNgFiles(files));\n    }\n    /**\n     * @param {?} fileNames\n     * @return {?}\n     */\n    loadFilesSync(fileNames) {\n        const /** @type {?} */ files = fileNames.map(fileName => this._analyzeFile(fileName));\n        files.forEach(file => file.ngModules.forEach(ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true)));\n        return mergeAndValidateNgFiles(files);\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} file\n     * @param {?} emitFlags\n     * @return {?}\n     */\n    _createNgFactoryStub(outputCtx, file, emitFlags) {\n        let /** @type {?} */ componentId = 0;\n        file.ngModules.forEach((ngModuleMeta, ngModuleIndex) => {\n            // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n            // so we don't change the .ngfactory file too much when adding the typecheck block.\n            // create exports that user code can reference\n            this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\n            // add references to the symbols from the metadata.\n            // These can be used by the type check block for components,\n            // and they also cause TypeScript to include these files into the program too,\n            // which will make them part of the analyzedFiles.\n            const /** @type {?} */ externalReferences = [\n                // Add references that are available from all the modules and imports.\n                ...ngModuleMeta.transitiveModule.directives.map(d => d.reference),\n                ...ngModuleMeta.transitiveModule.pipes.map(d => d.reference),\n                ...ngModuleMeta.importedModules.map(m => m.type.reference),\n                ...ngModuleMeta.exportedModules.map(m => m.type.reference),\n                // Add references that might be inserted by the template compiler.\n                ...this._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef]),\n            ];\n            const /** @type {?} */ externalReferenceVars = new Map();\n            externalReferences.forEach((ref, typeIndex) => {\n                if (this._host.isSourceFile(ref.filePath)) {\n                    externalReferenceVars.set(ref, `_decl${ngModuleIndex}_${typeIndex}`);\n                }\n            });\n            externalReferenceVars.forEach((varName, reference) => {\n                outputCtx.statements.push(o.variable(varName)\n                    .set(o.NULL_EXPR.cast(o.DYNAMIC_TYPE))\n                    .toDeclStmt(o.expressionType(outputCtx.importExpr(reference))));\n            });\n            if (emitFlags & StubEmitFlags.TypeCheck) {\n                // add the typecheck block for all components of the NgModule\n                ngModuleMeta.declaredDirectives.forEach((dirId) => {\n                    const /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(dirId.reference);\n                    if (!compMeta.isComponent) {\n                        return;\n                    }\n                    componentId++;\n                    this._createTypeCheckBlock(outputCtx, `${compMeta.type.reference.name}_Host_${componentId}`, ngModuleMeta, this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);\n                    this._createTypeCheckBlock(outputCtx, `${compMeta.type.reference.name}_${componentId}`, ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n                });\n            }\n        });\n        if (outputCtx.statements.length === 0) {\n            _createEmptyStub(outputCtx);\n        }\n    }\n    /**\n     * @param {?} references\n     * @return {?}\n     */\n    _externalIdentifierReferences(references) {\n        const /** @type {?} */ result = [];\n        for (let /** @type {?} */ reference of references) {\n            const /** @type {?} */ token = createTokenForExternalReference(this._reflector, reference);\n            if (token.identifier) {\n                result.push(token.identifier.reference);\n            }\n        }\n        return result;\n    }\n    /**\n     * @param {?} ctx\n     * @param {?} componentId\n     * @param {?} moduleMeta\n     * @param {?} compMeta\n     * @param {?} directives\n     * @param {?} externalReferenceVars\n     * @return {?}\n     */\n    _createTypeCheckBlock(ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {\n        const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, moduleMeta, directives);\n        ctx.statements.push(...this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars));\n    }\n    /**\n     * @param {?} analyzeResult\n     * @param {?} locale\n     * @return {?}\n     */\n    emitMessageBundle(analyzeResult, locale) {\n        const /** @type {?} */ errors = [];\n        const /** @type {?} */ htmlParser = new HtmlParser();\n        // TODO(vicb): implicit tags & attributes\n        const /** @type {?} */ messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        analyzeResult.files.forEach(file => {\n            const /** @type {?} */ compMetas = [];\n            file.directives.forEach(directiveType => {\n                const /** @type {?} */ dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);\n                if (dirMeta && dirMeta.isComponent) {\n                    compMetas.push(dirMeta);\n                }\n            });\n            compMetas.forEach(compMeta => {\n                const /** @type {?} */ html = /** @type {?} */ ((/** @type {?} */ ((compMeta.template)).template));\n                const /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(/** @type {?} */ ((compMeta.template)).interpolation);\n                errors.push(.../** @type {?} */ ((messageBundle.updateFromTemplate(html, file.fileName, interpolationConfig))));\n            });\n        });\n        if (errors.length) {\n            throw new Error(errors.map(e => e.toString()).join('\\n'));\n        }\n        return messageBundle;\n    }\n    /**\n     * @param {?} analyzeResult\n     * @return {?}\n     */\n    emitAllImpls(analyzeResult) {\n        const { ngModuleByPipeOrDirective, files } = analyzeResult;\n        const /** @type {?} */ sourceModules = files.map(file => this._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables));\n        return flatten(sourceModules);\n    }\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ngModuleByPipeOrDirective\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @return {?}\n     */\n    _compileImplFile(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        const /** @type {?} */ fileSuffix = splitTypescriptSuffix(srcFileUrl, true)[1];\n        const /** @type {?} */ generatedFiles = [];\n        const /** @type {?} */ outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n        generatedFiles.push(...this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));\n        // compile all ng modules\n        ngModules.forEach((ngModuleMeta) => this._compileModule(outputCtx, ngModuleMeta));\n        // compile components\n        directives.forEach((dirType) => {\n            const /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));\n            if (!compMeta.isComponent) {\n                return;\n            }\n            const /** @type {?} */ ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(`Internal Error: cannot determine the module for component ${identifierName(compMeta.type)}!`);\n            }\n            // compile styles\n            const /** @type {?} */ componentStylesheet = this._styleCompiler.compileComponent(outputCtx, compMeta); /** @type {?} */\n            ((\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template)).externalStylesheets.forEach((stylesheetMeta) => {\n                // Note: fill non shim and shim style files as they might\n                // be shared by component with and without ViewEncapsulation.\n                const /** @type {?} */ shim = this._styleCompiler.needsStyleShim(compMeta);\n                generatedFiles.push(this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n                if (this._options.allowEmptyCodegenFiles) {\n                    generatedFiles.push(this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n                }\n            });\n            // compile components\n            const /** @type {?} */ compViewVars = this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\n            this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n        });\n        if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n            const /** @type {?} */ srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    }\n    /**\n     * @param {?} srcFileName\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @param {?} ngFactoryCtx\n     * @return {?}\n     */\n    _createSummary(srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {\n        const /** @type {?} */ symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\n            .map(symbol => this._symbolResolver.resolveSymbol(symbol));\n        const /** @type {?} */ typeData = [\n            ...ngModules.map(meta => ({\n                summary: /** @type {?} */ ((this._metadataResolver.getNgModuleSummary(meta.type.reference))),\n                metadata: /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(meta.type.reference)))\n            })),\n            ...directives.map(ref => ({\n                summary: /** @type {?} */ ((this._metadataResolver.getDirectiveSummary(ref))),\n                metadata: /** @type {?} */ ((this._metadataResolver.getDirectiveMetadata(ref)))\n            })),\n            ...pipes.map(ref => ({\n                summary: /** @type {?} */ ((this._metadataResolver.getPipeSummary(ref))),\n                metadata: /** @type {?} */ ((this._metadataResolver.getPipeMetadata(ref)))\n            })),\n            ...injectables.map(ref => ({\n                summary: /** @type {?} */ ((this._metadataResolver.getInjectableSummary(ref))),\n                metadata: /** @type {?} */ ((this._metadataResolver.getInjectableSummary(ref))).type\n            }))\n        ];\n        const /** @type {?} */ forJitOutputCtx = this._options.enableSummariesForJit ?\n            this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\n            null;\n        const { json, exportAs } = serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData);\n        exportAs.forEach((entry) => {\n            ngFactoryCtx.statements.push(o.variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n                o.StmtModifier.Exported\n            ]));\n        });\n        const /** @type {?} */ summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n        const /** @type {?} */ result = [summaryJson];\n        if (forJitOutputCtx) {\n            result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n        }\n        return result;\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} ngModule\n     * @return {?}\n     */\n    _compileModule(outputCtx, ngModule) {\n        const /** @type {?} */ providers = [];\n        if (this._options.locale) {\n            const /** @type {?} */ normalizedLocale = this._options.locale.replace(/_/g, '-');\n            providers.push({\n                token: createTokenForExternalReference(this._reflector, Identifiers.LOCALE_ID),\n                useValue: normalizedLocale,\n            });\n        }\n        if (this._options.i18nFormat) {\n            providers.push({\n                token: createTokenForExternalReference(this._reflector, Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._options.i18nFormat\n            });\n        }\n        this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    _compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix) {\n        const /** @type {?} */ hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n        const /** @type {?} */ hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n            .viewClassVar;\n        const /** @type {?} */ compFactoryVar = componentFactoryName(compMeta.type.reference);\n        const /** @type {?} */ inputsExprs = [];\n        for (let /** @type {?} */ propName in compMeta.inputs) {\n            const /** @type {?} */ templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n        }\n        const /** @type {?} */ outputsExprs = [];\n        for (let /** @type {?} */ propName in compMeta.outputs) {\n            const /** @type {?} */ templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n        }\n        outputCtx.statements.push(o.variable(compFactoryVar)\n            .set(o.importExpr(Identifiers.createComponentFactory).callFn([\n            o.literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n            o.variable(hostViewFactoryVar), new o.LiteralMapExpr(inputsExprs),\n            new o.LiteralMapExpr(outputsExprs),\n            o.literalArr(/** @type {?} */ ((compMeta.template)).ngContentSelectors.map(selector => o.literal(selector)))\n        ]))\n            .toDeclStmt(o.importType(Identifiers.ComponentFactory, [/** @type {?} */ ((o.expressionType(outputCtx.importExpr(compMeta.type.reference))))], [o.TypeModifier.Const]), [o.StmtModifier.Final, o.StmtModifier.Exported]));\n    }\n    /**\n     * @param {?} outputCtx\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @param {?} componentStyles\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    _compileComponent(outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\n        const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, ngModule, directiveIdentifiers);\n        const /** @type {?} */ stylesExpr = componentStyles ? o.variable(componentStyles.stylesVar) : o.literalArr([]);\n        const /** @type {?} */ viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n        }\n        return viewResult;\n    }\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @return {?}\n     */\n    _parseTemplate(compMeta, ngModule, directiveIdentifiers) {\n        if (this._templateAstCache.has(compMeta.type.reference)) {\n            return /** @type {?} */ ((this._templateAstCache.get(compMeta.type.reference)));\n        }\n        const /** @type {?} */ preserveWhitespaces = /** @type {?} */ ((/** @type {?} */ ((compMeta)).template)).preserveWhitespaces;\n        const /** @type {?} */ directives = directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n        const /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n        const /** @type {?} */ result = this._templateParser.parse(compMeta, /** @type {?} */ ((/** @type {?} */ ((compMeta.template)).htmlAst)), directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, /** @type {?} */ ((compMeta.template))), preserveWhitespaces);\n        this._templateAstCache.set(compMeta.type.reference, result);\n        return result;\n    }\n    /**\n     * @param {?} genFilePath\n     * @return {?}\n     */\n    _createOutputContext(genFilePath) {\n        const /** @type {?} */ importExpr = (symbol, typeParams = null) => {\n            if (!(symbol instanceof StaticSymbol)) {\n                throw new Error(`Internal error: unknown identifier ${JSON.stringify(symbol)}`);\n            }\n            const /** @type {?} */ arity = this._symbolResolver.getTypeArity(symbol) || 0;\n            const { filePath, name, members } = this._symbolResolver.getImportAs(symbol) || symbol;\n            const /** @type {?} */ importModule = this._fileNameToModuleName(filePath, genFilePath);\n            // It should be good enough to compare filePath to genFilePath and if they are equal\n            // there is a self reference. However, ngfactory files generate to .ts but their\n            // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n            // and is tracked by #17705.\n            const /** @type {?} */ selfReference = this._fileNameToModuleName(genFilePath, genFilePath);\n            const /** @type {?} */ moduleName = importModule === selfReference ? null : importModule;\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            const /** @type {?} */ suppliedTypeParams = typeParams || [];\n            const /** @type {?} */ missingTypeParamsCount = arity - suppliedTypeParams.length;\n            const /** @type {?} */ allTypeParams = suppliedTypeParams.concat(new Array(missingTypeParamsCount).fill(o.DYNAMIC_TYPE));\n            return members.reduce((expr, memberName) => expr.prop(memberName), /** @type {?} */ (o.importExpr(new o.ExternalReference(moduleName, name, null), allTypeParams)));\n        };\n        return { statements: [], genFilePath, importExpr };\n    }\n    /**\n     * @param {?} importedFilePath\n     * @param {?} containingFilePath\n     * @return {?}\n     */\n    _fileNameToModuleName(importedFilePath, containingFilePath) {\n        return this._summaryResolver.getKnownModuleName(importedFilePath) ||\n            this._symbolResolver.getKnownModuleName(importedFilePath) ||\n            this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n    }\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} compMeta\n     * @param {?} stylesheetMetadata\n     * @param {?} isShimmed\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    _codegenStyles(srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {\n        const /** @type {?} */ outputCtx = this._createOutputContext(_stylesModuleUrl(/** @type {?} */ ((stylesheetMetadata.moduleUrl)), isShimmed, fileSuffix));\n        const /** @type {?} */ compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n        _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n        return this._codegenSourceModule(srcFileUrl, outputCtx);\n    }\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ctx\n     * @return {?}\n     */\n    _codegenSourceModule(srcFileUrl, ctx) {\n        return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n    }\n    /**\n     * @param {?=} entryRoute\n     * @param {?=} analyzedModules\n     * @return {?}\n     */\n    listLazyRoutes(entryRoute, analyzedModules) {\n        const /** @type {?} */ self = this;\n        if (entryRoute) {\n            const /** @type {?} */ symbol = parseLazyRoute(entryRoute, this._reflector).referencedModule;\n            return visitLazyRoute(symbol);\n        }\n        else if (analyzedModules) {\n            const /** @type {?} */ allLazyRoutes = [];\n            for (const /** @type {?} */ ngModule of analyzedModules.ngModules) {\n                const /** @type {?} */ lazyRoutes = listLazyRoutes(ngModule, this._reflector);\n                for (const /** @type {?} */ lazyRoute of lazyRoutes) {\n                    allLazyRoutes.push(lazyRoute);\n                }\n            }\n            return allLazyRoutes;\n        }\n        else {\n            throw new Error(`Either route or analyzedModules has to be specified!`);\n        }\n        /**\n         * @param {?} symbol\n         * @param {?=} seenRoutes\n         * @param {?=} allLazyRoutes\n         * @return {?}\n         */\n        function visitLazyRoute(symbol, seenRoutes = new Set(), allLazyRoutes = []) {\n            // Support pointing to default exports, but stop recursing there,\n            // as the StaticReflector does not yet support default exports.\n            if (seenRoutes.has(symbol) || !symbol.name) {\n                return allLazyRoutes;\n            }\n            seenRoutes.add(symbol);\n            const /** @type {?} */ lazyRoutes = listLazyRoutes(/** @type {?} */ ((self._metadataResolver.getNgModuleMetadata(symbol, true))), self._reflector);\n            for (const /** @type {?} */ lazyRoute of lazyRoutes) {\n                allLazyRoutes.push(lazyRoute);\n                visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n            }\n            return allLazyRoutes;\n        }\n    }\n}\nfunction AotCompiler_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AotCompiler.prototype._templateAstCache;\n    /** @type {?} */\n    AotCompiler.prototype._analyzedFiles;\n    /** @type {?} */\n    AotCompiler.prototype._config;\n    /** @type {?} */\n    AotCompiler.prototype._options;\n    /** @type {?} */\n    AotCompiler.prototype._host;\n    /** @type {?} */\n    AotCompiler.prototype._reflector;\n    /** @type {?} */\n    AotCompiler.prototype._metadataResolver;\n    /** @type {?} */\n    AotCompiler.prototype._templateParser;\n    /** @type {?} */\n    AotCompiler.prototype._styleCompiler;\n    /** @type {?} */\n    AotCompiler.prototype._viewCompiler;\n    /** @type {?} */\n    AotCompiler.prototype._typeCheckCompiler;\n    /** @type {?} */\n    AotCompiler.prototype._ngModuleCompiler;\n    /** @type {?} */\n    AotCompiler.prototype._outputEmitter;\n    /** @type {?} */\n    AotCompiler.prototype._summaryResolver;\n    /** @type {?} */\n    AotCompiler.prototype._symbolResolver;\n}\n/**\n * @param {?} outputCtx\n * @return {?}\n */\nfunction _createEmptyStub(outputCtx) {\n    // Note: We need to produce at least one import statement so that\n    // TypeScript knows that the file is an es6 module. Otherwise our generated\n    // exports / imports won't be emitted properly by TypeScript.\n    outputCtx.statements.push(o.importExpr(Identifiers.ComponentFactory).toStmt());\n}\n/**\n * @param {?} symbolResolver\n * @param {?} compileResult\n * @param {?} needsShim\n * @param {?} fileSuffix\n * @return {?}\n */\nfunction _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\n    compileResult.dependencies.forEach((dep) => {\n        dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n    });\n}\n/**\n * @param {?} stylesheetUrl\n * @param {?} shim\n * @param {?} suffix\n * @return {?}\n */\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return `${stylesheetUrl}${shim ? '.shim' : ''}.ngstyle${suffix}`;\n}\n/**\n * @record\n */\nexport function NgAnalyzedModules() { }\nfunction NgAnalyzedModules_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgAnalyzedModules.prototype.ngModules;\n    /** @type {?} */\n    NgAnalyzedModules.prototype.ngModuleByPipeOrDirective;\n    /** @type {?} */\n    NgAnalyzedModules.prototype.files;\n    /** @type {?|undefined} */\n    NgAnalyzedModules.prototype.symbolsMissingModule;\n}\n/**\n * @record\n */\nexport function NgAnalyzedFile() { }\nfunction NgAnalyzedFile_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgAnalyzedFile.prototype.fileName;\n    /** @type {?} */\n    NgAnalyzedFile.prototype.directives;\n    /** @type {?} */\n    NgAnalyzedFile.prototype.pipes;\n    /** @type {?} */\n    NgAnalyzedFile.prototype.ngModules;\n    /** @type {?} */\n    NgAnalyzedFile.prototype.injectables;\n    /** @type {?} */\n    NgAnalyzedFile.prototype.exportsNonSourceFiles;\n}\n/**\n * @record\n */\nexport function NgAnalyzeModulesHost() { }\nfunction NgAnalyzeModulesHost_tsickle_Closure_declarations() {\n    /** @type {?} */\n    NgAnalyzeModulesHost.prototype.isSourceFile;\n}\n/**\n * @param {?} fileNames\n * @param {?} host\n * @param {?} staticSymbolResolver\n * @param {?} metadataResolver\n * @return {?}\n */\nexport function analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    const /** @type {?} */ files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);\n    return mergeAnalyzedFiles(files);\n}\n/**\n * @param {?} fileNames\n * @param {?} host\n * @param {?} staticSymbolResolver\n * @param {?} metadataResolver\n * @return {?}\n */\nexport function analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n}\n/**\n * @param {?} analyzedModules\n * @return {?}\n */\nfunction validateAnalyzedModules(analyzedModules) {\n    if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n        const /** @type {?} */ messages = analyzedModules.symbolsMissingModule.map(s => `Cannot determine the module for class ${s.name} in ${s.filePath}! Add ${s.name} to the NgModule to fix it.`);\n        throw syntaxError(messages.join('\\n'));\n    }\n    return analyzedModules;\n}\n/**\n * @param {?} fileNames\n * @param {?} host\n * @param {?} staticSymbolResolver\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {\n    const /** @type {?} */ seenFiles = new Set();\n    const /** @type {?} */ files = [];\n    const /** @type {?} */ visitFile = (fileName) => {\n        if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n            return false;\n        }\n        seenFiles.add(fileName);\n        const /** @type {?} */ analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n        files.push(analyzedFile);\n        analyzedFile.ngModules.forEach(ngModule => {\n            ngModule.transitiveModule.modules.forEach(modMeta => visitFile(modMeta.reference.filePath));\n        });\n    };\n    fileNames.forEach((fileName) => visitFile(fileName));\n    return files;\n}\n/**\n * @param {?} host\n * @param {?} staticSymbolResolver\n * @param {?} metadataResolver\n * @param {?} fileName\n * @return {?}\n */\nexport function analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {\n    const /** @type {?} */ directives = [];\n    const /** @type {?} */ pipes = [];\n    const /** @type {?} */ injectables = [];\n    const /** @type {?} */ ngModules = [];\n    const /** @type {?} */ hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n    let /** @type {?} */ exportsNonSourceFiles = false;\n    // Don't analyze .d.ts files that have no decorators as a shortcut\n    // to speed up the analysis. This prevents us from\n    // resolving the references in these files.\n    // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n    // which is not the case when .d.ts files are treated as input files.\n    if (!fileName.endsWith('.d.ts') || hasDecorators) {\n        staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n            const /** @type {?} */ resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            const /** @type {?} */ symbolMeta = resolvedSymbol.metadata;\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n                return;\n            }\n            let /** @type {?} */ isNgSymbol = false;\n            if (symbolMeta.__symbolic === 'class') {\n                if (metadataResolver.isDirective(symbol)) {\n                    isNgSymbol = true;\n                    directives.push(symbol);\n                }\n                else if (metadataResolver.isPipe(symbol)) {\n                    isNgSymbol = true;\n                    pipes.push(symbol);\n                }\n                else if (metadataResolver.isNgModule(symbol)) {\n                    const /** @type {?} */ ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n                    if (ngModule) {\n                        isNgSymbol = true;\n                        ngModules.push(ngModule);\n                    }\n                }\n                else if (metadataResolver.isInjectable(symbol)) {\n                    isNgSymbol = true;\n                    injectables.push(symbol);\n                }\n            }\n            if (!isNgSymbol) {\n                exportsNonSourceFiles =\n                    exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n            }\n        });\n    }\n    return {\n        fileName, directives, pipes, ngModules, injectables, exportsNonSourceFiles,\n    };\n}\n/**\n * @param {?} host\n * @param {?} metadata\n * @return {?}\n */\nfunction isValueExportingNonSourceFile(host, metadata) {\n    let /** @type {?} */ exportsNonSourceFiles = false;\n    class Visitor {\n        /**\n         * @param {?} arr\n         * @param {?} context\n         * @return {?}\n         */\n        visitArray(arr, context) { arr.forEach(v => visitValue(v, this, context)); }\n        /**\n         * @param {?} map\n         * @param {?} context\n         * @return {?}\n         */\n        visitStringMap(map, context) {\n            Object.keys(map).forEach((key) => visitValue(map[key], this, context));\n        }\n        /**\n         * @param {?} value\n         * @param {?} context\n         * @return {?}\n         */\n        visitPrimitive(value, context) { }\n        /**\n         * @param {?} value\n         * @param {?} context\n         * @return {?}\n         */\n        visitOther(value, context) {\n            if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n                exportsNonSourceFiles = true;\n            }\n        }\n    }\n    visitValue(metadata, new Visitor(), null);\n    return exportsNonSourceFiles;\n}\n/**\n * @param {?} analyzedFiles\n * @return {?}\n */\nexport function mergeAnalyzedFiles(analyzedFiles) {\n    const /** @type {?} */ allNgModules = [];\n    const /** @type {?} */ ngModuleByPipeOrDirective = new Map();\n    const /** @type {?} */ allPipesAndDirectives = new Set();\n    analyzedFiles.forEach(af => {\n        af.ngModules.forEach(ngModule => {\n            allNgModules.push(ngModule);\n            ngModule.declaredDirectives.forEach(d => ngModuleByPipeOrDirective.set(d.reference, ngModule));\n            ngModule.declaredPipes.forEach(p => ngModuleByPipeOrDirective.set(p.reference, ngModule));\n        });\n        af.directives.forEach(d => allPipesAndDirectives.add(d));\n        af.pipes.forEach(p => allPipesAndDirectives.add(p));\n    });\n    const /** @type {?} */ symbolsMissingModule = [];\n    allPipesAndDirectives.forEach(ref => {\n        if (!ngModuleByPipeOrDirective.has(ref)) {\n            symbolsMissingModule.push(ref);\n        }\n    });\n    return {\n        ngModules: allNgModules,\n        ngModuleByPipeOrDirective,\n        symbolsMissingModule,\n        files: analyzedFiles\n    };\n}\n/**\n * @param {?} files\n * @return {?}\n */\nfunction mergeAndValidateNgFiles(files) {\n    return validateAnalyzedModules(mergeAnalyzedFiles(files));\n}\n//# sourceMappingURL=compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CompileSummaryKind } from \"../compile_metadata\";\nimport { createAttribute, createComponent, createContentChild, createContentChildren, createDirective, createHost, createHostBinding, createHostListener, createInject, createInjectable, createInput, createNgModule, createOptional, createOutput, createPipe, createSelf, createSkipSelf, createViewChild, createViewChildren } from \"../core\";\nimport { syntaxError } from \"../util\";\nimport { StaticSymbol } from \"./static_symbol\";\nconst /** @type {?} */ ANGULAR_CORE = '@angular/core';\nconst /** @type {?} */ ANGULAR_ROUTER = '@angular/router';\nconst /** @type {?} */ HIDDEN_KEY = /^\\$.*\\$$/;\nconst /** @type {?} */ IGNORE = {\n    __symbolic: 'ignore'\n};\nconst /** @type {?} */ USE_VALUE = 'useValue';\nconst /** @type {?} */ PROVIDE = 'provide';\nconst /** @type {?} */ REFERENCE_SET = new Set([USE_VALUE, 'useFactory', 'data']);\n/**\n * @param {?} value\n * @return {?}\n */\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nexport class StaticReflector {\n    /**\n     * @param {?} summaryResolver\n     * @param {?} symbolResolver\n     * @param {?=} knownMetadataClasses\n     * @param {?=} knownMetadataFunctions\n     * @param {?=} errorRecorder\n     */\n    constructor(summaryResolver, symbolResolver, knownMetadataClasses = [], knownMetadataFunctions = [], errorRecorder) {\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.conversionMap = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach((kc) => this._registerDecoratorOrConstructor(this.getStaticSymbol(kc.filePath, kc.name), kc.ctor));\n        knownMetadataFunctions.forEach((kf) => this._registerFunction(this.getStaticSymbol(kf.filePath, kf.name), kf.fn));\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\n    }\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    componentModuleUrl(typeOrFunc) {\n        const /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    }\n    /**\n     * @param {?} ref\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    resolveExternalReference(ref, containingFile) {\n        const /** @type {?} */ refSymbol = this.symbolResolver.getSymbolByModule(/** @type {?} */ ((ref.moduleName)), /** @type {?} */ ((ref.name)), containingFile);\n        const /** @type {?} */ declarationSymbol = this.findSymbolDeclaration(refSymbol);\n        if (!containingFile) {\n            this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, /** @type {?} */ ((ref.moduleName)));\n            this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n        }\n        return declarationSymbol;\n    }\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    findDeclaration(moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    }\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @return {?}\n     */\n    tryFindDeclaration(moduleUrl, name) {\n        return this.symbolResolver.ignoreErrorsFor(() => this.findDeclaration(moduleUrl, name));\n    }\n    /**\n     * @param {?} symbol\n     * @return {?}\n     */\n    findSymbolDeclaration(symbol) {\n        const /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n        else {\n            return symbol;\n        }\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    annotations(type) {\n        let /** @type {?} */ annotations = this.annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            const /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            const /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                const /** @type {?} */ parentAnnotations = this.annotations(parentType);\n                annotations.push(...parentAnnotations);\n            }\n            let /** @type {?} */ ownAnnotations = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations = this.simplify(type, classMetadata['decorators']);\n                annotations.push(...ownAnnotations);\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                const /** @type {?} */ summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    const /** @type {?} */ requiredAnnotationTypes = /** @type {?} */ ((this.annotationForParentClassWithSummaryKind.get(/** @type {?} */ ((summary.type.summaryKind)))));\n                    const /** @type {?} */ typeHasRequiredAnnotation = requiredAnnotationTypes.some((requiredType) => ownAnnotations.some(ann => requiredType.isTypeOf(ann)));\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(syntaxError(`Class ${type.name} in ${type.filePath} extends from a ${CompileSummaryKind[(/** @type {?} */ ((summary.type.summaryKind)))]} in another compilation unit without duplicating the decorator. ` +\n                            `Please add a ${requiredAnnotationTypes.map((type) => type.ngMetadataName).join(' or ')} decorator to the class.`), type);\n                    }\n                }\n            }\n            this.annotationCache.set(type, annotations.filter(ann => !!ann));\n        }\n        return annotations;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    propMetadata(type) {\n        let /** @type {?} */ propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            const /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            const /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                const /** @type {?} */ parentPropMetadata = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata).forEach((parentProp) => {\n                    /** @type {?} */ ((propMetadata))[parentProp] = parentPropMetadata[parentProp];\n                });\n            }\n            const /** @type {?} */ members = classMetadata['members'] || {};\n            Object.keys(members).forEach((propName) => {\n                const /** @type {?} */ propData = members[propName];\n                const /** @type {?} */ prop = (/** @type {?} */ (propData))\n                    .find(a => a['__symbolic'] == 'property' || a['__symbolic'] == 'method');\n                const /** @type {?} */ decorators = [];\n                if (/** @type {?} */ ((propMetadata))[propName]) {\n                    decorators.push(.../** @type {?} */ ((propMetadata))[propName]);\n                } /** @type {?} */\n                ((propMetadata))[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push(...this.simplify(type, prop['decorators']));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    parameters(type) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(`parameters received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\n            return [];\n        }\n        try {\n            let /** @type {?} */ parameters = this.parameterCache.get(type);\n            if (!parameters) {\n                const /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n                const /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n                const /** @type {?} */ members = classMetadata ? classMetadata['members'] : null;\n                const /** @type {?} */ ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    const /** @type {?} */ ctor = (/** @type {?} */ (ctorData)).find(a => a['__symbolic'] == 'constructor');\n                    const /** @type {?} */ rawParameterTypes = /** @type {?} */ (ctor['parameters']) || [];\n                    const /** @type {?} */ parameterDecorators = /** @type {?} */ (this.simplify(type, ctor['parameterDecorators'] || []));\n                    parameters = [];\n                    rawParameterTypes.forEach((rawParamType, index) => {\n                        const /** @type {?} */ nestedResult = [];\n                        const /** @type {?} */ paramType = this.trySimplify(type, rawParamType);\n                        if (paramType)\n                            nestedResult.push(paramType);\n                        const /** @type {?} */ decorators = parameterDecorators ? parameterDecorators[index] : null;\n                        if (decorators) {\n                            nestedResult.push(...decorators);\n                        } /** @type {?} */\n                        ((parameters)).push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters = this.parameters(parentType);\n                }\n                if (!parameters) {\n                    parameters = [];\n                }\n                this.parameterCache.set(type, parameters);\n            }\n            return parameters;\n        }\n        catch (/** @type {?} */ e) {\n            console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\n            throw e;\n        }\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _methodNames(type) {\n        let /** @type {?} */ methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            const /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            const /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                const /** @type {?} */ parentMethodNames = this._methodNames(parentType);\n                Object.keys(parentMethodNames).forEach((parentProp) => {\n                    /** @type {?} */ ((methodNames))[parentProp] = parentMethodNames[parentProp];\n                });\n            }\n            const /** @type {?} */ members = classMetadata['members'] || {};\n            Object.keys(members).forEach((propName) => {\n                const /** @type {?} */ propData = members[propName];\n                const /** @type {?} */ isMethod = (/** @type {?} */ (propData)).some(a => a['__symbolic'] == 'method'); /** @type {?} */\n                ((methodNames))[propName] = /** @type {?} */ ((methodNames))[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    }\n    /**\n     * @param {?} type\n     * @param {?} classMetadata\n     * @return {?}\n     */\n    findParentType(type, classMetadata) {\n        const /** @type {?} */ parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    }\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    hasLifecycleHook(type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(`hasLifecycleHook received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (/** @type {?} */ e) {\n            console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\n            throw e;\n        }\n    }\n    /**\n     * @param {?} type\n     * @param {?} ctor\n     * @return {?}\n     */\n    _registerDecoratorOrConstructor(type, ctor) {\n        this.conversionMap.set(type, (context, args) => new ctor(...args));\n    }\n    /**\n     * @param {?} type\n     * @param {?} fn\n     * @return {?}\n     */\n    _registerFunction(type, fn) {\n        this.conversionMap.set(type, (context, args) => fn.apply(undefined, args));\n    }\n    /**\n     * @return {?}\n     */\n    initializeConversionMap() {\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n        this.ANALYZE_FOR_ENTRY_COMPONENTS =\n            this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n    }\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members\n     * @return {?}\n     */\n    getStaticSymbol(declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    }\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    reportError(error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    }\n    /**\n     * Simplify but discard any errors\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    trySimplify(context, value) {\n        const /** @type {?} */ originalRecorder = this.errorRecorder;\n        this.errorRecorder = (error, fileName) => { };\n        const /** @type {?} */ result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    }\n    /**\n     * \\@internal\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    simplify(context, value) {\n        const /** @type {?} */ self = this;\n        let /** @type {?} */ scope = BindingScope.empty;\n        const /** @type {?} */ calling = new Map();\n        /**\n         * @param {?} context\n         * @param {?} value\n         * @param {?} depth\n         * @param {?} references\n         * @return {?}\n         */\n        function simplifyInContext(context, value, depth, references) {\n            /**\n             * @param {?} staticSymbol\n             * @return {?}\n             */\n            function resolveReferenceValue(staticSymbol) {\n                const /** @type {?} */ resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            /**\n             * @param {?} functionSymbol\n             * @param {?} targetFunction\n             * @param {?} args\n             * @return {?}\n             */\n            function simplifyCall(functionSymbol, targetFunction, args) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        throw new Error('Recursion not supported');\n                    }\n                    try {\n                        const /** @type {?} */ value = targetFunction['value'];\n                        if (value && (depth != 0 || value.__symbolic != 'error')) {\n                            const /** @type {?} */ parameters = targetFunction['parameters'];\n                            const /** @type {?} */ defaults = targetFunction.defaults;\n                            args = args.map(arg => simplifyInContext(context, arg, depth + 1, references))\n                                .map(arg => shouldIgnore(arg) ? undefined : arg);\n                            if (defaults && defaults.length > args.length) {\n                                args.push(...defaults.slice(args.length).map((value) => simplify(value)));\n                            }\n                            calling.set(functionSymbol, true);\n                            const /** @type {?} */ functionScope = BindingScope.build();\n                            for (let /** @type {?} */ i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            const /** @type {?} */ oldScope = scope;\n                            let /** @type {?} */ result;\n                            try {\n                                scope = functionScope.done();\n                                result = simplifyInContext(functionSymbol, value, depth + 1, references);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                return simplify({ __symbolic: 'error', message: 'Function call not supported', context: functionSymbol });\n            }\n            /**\n             * @param {?} expression\n             * @return {?}\n             */\n            function simplify(expression) {\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (expression instanceof Array) {\n                    const /** @type {?} */ result = [];\n                    for (const /** @type {?} */ item of (/** @type {?} */ (expression))) {\n                        // Check for a spread expression\n                        if (item && item.__symbolic === 'spread') {\n                            // We call with references as 0 because we require the actual value and cannot\n                            // tolerate a reference here.\n                            const /** @type {?} */ spreadArray = simplifyInContext(context, item.expression, depth, 0);\n                            if (Array.isArray(spreadArray)) {\n                                for (const /** @type {?} */ spreadItem of spreadArray) {\n                                    result.push(spreadItem);\n                                }\n                                continue;\n                            }\n                        }\n                        const /** @type {?} */ value = simplify(item);\n                        if (shouldIgnore(value)) {\n                            continue;\n                        }\n                        result.push(value);\n                    }\n                    return result;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols or if we are in a reference context and\n                    // the symbol doesn't have members.\n                    if (expression === self.injectionToken || self.conversionMap.has(expression) ||\n                        (references > 0 && !expression.members.length)) {\n                        return expression;\n                    }\n                    else {\n                        const /** @type {?} */ staticSymbol = expression;\n                        const /** @type {?} */ declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue != null) {\n                            return simplifyInContext(staticSymbol, declarationValue, depth + 1, references);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        let /** @type {?} */ staticSymbol;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                let /** @type {?} */ left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                let /** @type {?} */ right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                let /** @type {?} */ condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                let /** @type {?} */ operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                let /** @type {?} */ indexTarget = simplifyInContext(context, expression['expression'], depth, 0);\n                                let /** @type {?} */ index = simplifyInContext(context, expression['index'], depth, 0);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                const /** @type {?} */ member = expression['member'];\n                                let /** @type {?} */ selectContext = context;\n                                let /** @type {?} */ selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    const /** @type {?} */ members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    const /** @type {?} */ declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue != null) {\n                                        return simplifyInContext(selectContext, declarationValue, depth + 1, references);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyInContext(selectContext, selectTarget[member], depth + 1, references);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references,\n                                // as symbol references have been converted into StaticSymbols already\n                                // in the StaticSymbolResolver!\n                                const /** @type {?} */ name = expression['name'];\n                                const /** @type {?} */ localValue = scope.resolve(name);\n                                if (localValue != BindingScope.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, /* references */ 0);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        // OpaqueToken is supported too as it is required by the language service to\n                                        // support v4 and prior versions of Angular.\n                                        return context;\n                                    }\n                                    const /** @type {?} */ argExpressions = expression['arguments'] || [];\n                                    let /** @type {?} */ converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        const /** @type {?} */ args = argExpressions\n                                            .map(arg => simplifyInContext(context, arg, depth + 1, references))\n                                            .map(arg => shouldIgnore(arg) ? undefined : arg);\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        const /** @type {?} */ targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions);\n                                    }\n                                }\n                                return IGNORE;\n                            case 'error':\n                                let /** @type {?} */ message = produceErrorMessage(expression);\n                                if (expression['line']) {\n                                    message =\n                                        `${message} (position ${expression['line'] + 1}:${expression['character'] + 1} in the original .ts file)`;\n                                    self.reportError(positionalError(message, context.filePath, expression['line'], expression['character']), context);\n                                }\n                                else {\n                                    self.reportError(new Error(message), context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, (value, name) => {\n                        if (REFERENCE_SET.has(name)) {\n                            if (name === USE_VALUE && PROVIDE in expression) {\n                                // If this is a provider expression, check for special tokens that need the value\n                                // during analysis.\n                                const /** @type {?} */ provide = simplify(expression.provide);\n                                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                                    return simplify(value);\n                                }\n                            }\n                            return simplifyInContext(context, value, depth, references + 1);\n                        }\n                        return simplify(value);\n                    });\n                }\n                return IGNORE;\n            }\n            try {\n                return simplify(value);\n            }\n            catch (/** @type {?} */ e) {\n                const /** @type {?} */ members = context.members.length ? `.${context.members.join('.')}` : '';\n                const /** @type {?} */ message = `${e.message}, resolving symbol ${context.name}${members} in ${context.filePath}`;\n                if (e.fileName) {\n                    throw positionalError(message, e.fileName, e.line, e.column);\n                }\n                throw syntaxError(message);\n            }\n        }\n        const /** @type {?} */ recordedSimplifyInContext = (context, value) => {\n            try {\n                return simplifyInContext(context, value, 0, 0);\n            }\n            catch (/** @type {?} */ e) {\n                this.reportError(e, context);\n            }\n        };\n        const /** @type {?} */ result = this.errorRecorder ? recordedSimplifyInContext(context, value) :\n            simplifyInContext(context, value, 0, 0);\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    getTypeMetadata(type) {\n        const /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    }\n}\nfunction StaticReflector_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StaticReflector.prototype.annotationCache;\n    /** @type {?} */\n    StaticReflector.prototype.propertyCache;\n    /** @type {?} */\n    StaticReflector.prototype.parameterCache;\n    /** @type {?} */\n    StaticReflector.prototype.methodCache;\n    /** @type {?} */\n    StaticReflector.prototype.conversionMap;\n    /** @type {?} */\n    StaticReflector.prototype.injectionToken;\n    /** @type {?} */\n    StaticReflector.prototype.opaqueToken;\n    /** @type {?} */\n    StaticReflector.prototype.ROUTES;\n    /** @type {?} */\n    StaticReflector.prototype.ANALYZE_FOR_ENTRY_COMPONENTS;\n    /** @type {?} */\n    StaticReflector.prototype.annotationForParentClassWithSummaryKind;\n    /** @type {?} */\n    StaticReflector.prototype.summaryResolver;\n    /** @type {?} */\n    StaticReflector.prototype.symbolResolver;\n    /** @type {?} */\n    StaticReflector.prototype.errorRecorder;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction expandedMessage(error) {\n    switch (error.message) {\n        case 'Reference to non-exported class':\n            if (error.context && error.context.className) {\n                return `Reference to a non-exported class ${error.context.className}. Consider exporting the class`;\n            }\n            break;\n        case 'Variable not initialized':\n            return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n        case 'Destructuring not supported':\n            return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n        case 'Could not resolve type':\n            if (error.context && error.context.typeName) {\n                return `Could not resolve type ${error.context.typeName}`;\n            }\n            break;\n        case 'Function call not supported':\n            let /** @type {?} */ prefix = error.context && error.context.name ? `Calling function '${error.context.name}', f` : 'F';\n            return prefix +\n                'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n        case 'Reference to a local symbol':\n            if (error.context && error.context.name) {\n                return `Reference to a local (non-exported) symbol '${error.context.name}'. Consider exporting the symbol`;\n            }\n            break;\n    }\n    return error.message;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction produceErrorMessage(error) {\n    return `Error encountered resolving symbol values statically. ${expandedMessage(error)}`;\n}\n/**\n * @param {?} input\n * @param {?} transform\n * @return {?}\n */\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    const /** @type {?} */ result = {};\n    Object.keys(input).forEach((key) => {\n        const /** @type {?} */ value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\n/**\n * @param {?} o\n * @return {?}\n */\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n/**\n * @record\n */\nfunction BindingScopeBuilder() { }\nfunction BindingScopeBuilder_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BindingScopeBuilder.prototype.define;\n    /** @type {?} */\n    BindingScopeBuilder.prototype.done;\n}\n/**\n * @abstract\n */\nclass BindingScope {\n    /**\n     * @return {?}\n     */\n    static build() {\n        const /** @type {?} */ current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    }\n}\nBindingScope.missing = {};\nBindingScope.empty = { resolve: name => BindingScope.missing };\nfunction BindingScope_tsickle_Closure_declarations() {\n    /** @type {?} */\n    BindingScope.missing;\n    /** @type {?} */\n    BindingScope.empty;\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    BindingScope.prototype.resolve = function (name) { };\n}\nclass PopulatedScope extends BindingScope {\n    /**\n     * @param {?} bindings\n     */\n    constructor(bindings) {\n        super();\n        this.bindings = bindings;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    resolve(name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n    }\n}\nfunction PopulatedScope_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PopulatedScope.prototype.bindings;\n}\n/**\n * @param {?} message\n * @param {?} fileName\n * @param {?} line\n * @param {?} column\n * @return {?}\n */\nfunction positionalError(message, fileName, line, column) {\n    const /** @type {?} */ result = syntaxError(message);\n    (/** @type {?} */ (result)).fileName = fileName;\n    (/** @type {?} */ (result)).line = line;\n    (/** @type {?} */ (result)).column = column;\n    return result;\n}\n//# sourceMappingURL=static_reflector.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { ValueTransformer, visitValue } from \"../util\";\nimport { StaticSymbol } from \"./static_symbol\";\nimport { isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName } from \"./util\";\nexport class ResolvedStaticSymbol {\n    /**\n     * @param {?} symbol\n     * @param {?} metadata\n     */\n    constructor(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n}\nfunction ResolvedStaticSymbol_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ResolvedStaticSymbol.prototype.symbol;\n    /** @type {?} */\n    ResolvedStaticSymbol.prototype.metadata;\n}\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n * @record\n */\nexport function StaticSymbolResolverHost() { }\nfunction StaticSymbolResolverHost_tsickle_Closure_declarations() {\n    /**\n     * Return a ModuleMetadata for the given module.\n     * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n     * produced and the module has exported variables or classes with decorators. Module metadata can\n     * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n     *\n     * \\@param modulePath is a string identifier for a module as an absolute path.\n     * \\@return the metadata for the given module.\n     * @type {?}\n     */\n    StaticSymbolResolverHost.prototype.getMetadataFor;\n    /**\n     * Converts a module name that is used in an `import` to a file path.\n     * I.e.\n     * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n     * @type {?}\n     */\n    StaticSymbolResolverHost.prototype.moduleNameToFileName;\n}\nconst /** @type {?} */ SUPPORTED_SCHEMA_VERSION = 4;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     * @param {?} summaryResolver\n     * @param {?=} errorRecorder\n     */\n    constructor(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        this.resolvedSymbols = new Map();\n        this.resolvedFilePaths = new Set();\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    resolveSymbol(staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return /** @type {?} */ ((this._resolveSymbolMembers(staticSymbol)));\n        }\n        // Note: always ask for a summary first,\n        // as we might have read shallow metadata via a .d.ts file\n        // for the symbol.\n        const /** @type {?} */ resultFromSummary = /** @type {?} */ ((this._resolveSymbolFromSummary(staticSymbol)));\n        if (resultFromSummary) {\n            return resultFromSummary;\n        }\n        const /** @type {?} */ resultFromCache = this.resolvedSymbols.get(staticSymbol);\n        if (resultFromCache) {\n            return resultFromCache;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        return /** @type {?} */ ((this.resolvedSymbols.get(staticSymbol)));\n    }\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param {?} staticSymbol the symbol for which to generate a import symbol\n     * @return {?}\n     */\n    getImportAs(staticSymbol) {\n        if (staticSymbol.members.length) {\n            const /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            const /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        const /** @type {?} */ summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n        if (summarizedFileName !== staticSymbol.filePath) {\n            const /** @type {?} */ summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n            const /** @type {?} */ baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n            const /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) :\n                null;\n        }\n        let /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n        if (!result) {\n            result = /** @type {?} */ ((this.importAs.get(staticSymbol)));\n        }\n        return result;\n    }\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    getResourcePath(staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    }\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    getTypeArity(staticSymbol) {\n        // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isGeneratedFile(staticSymbol.filePath)) {\n            return null;\n        }\n        let /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    getKnownModuleName(filePath) {\n        return this.knownFileNameToModuleNames.get(filePath) || null;\n    }\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    recordImportAs(sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    }\n    /**\n     * @param {?} fileName\n     * @param {?} moduleName\n     * @return {?}\n     */\n    recordModuleNameForFileName(fileName, moduleName) {\n        this.knownFileNameToModuleNames.set(fileName, moduleName);\n    }\n    /**\n     * Invalidate all information derived from the given file.\n     *\n     * @param {?} fileName the file to invalidate\n     * @return {?}\n     */\n    invalidateFile(fileName) {\n        this.metadataCache.delete(fileName);\n        this.resolvedFilePaths.delete(fileName);\n        const /** @type {?} */ symbols = this.symbolFromFile.get(fileName);\n        if (symbols) {\n            this.symbolFromFile.delete(fileName);\n            for (const /** @type {?} */ symbol of symbols) {\n                this.resolvedSymbols.delete(symbol);\n                this.importAs.delete(symbol);\n                this.symbolResourcePaths.delete(symbol);\n            }\n        }\n    }\n    /**\n     * @template T\n     * @param {?} cb\n     * @return {?}\n     */\n    ignoreErrorsFor(cb) {\n        const /** @type {?} */ recorder = this.errorRecorder;\n        this.errorRecorder = () => { };\n        try {\n            return cb();\n        }\n        finally {\n            this.errorRecorder = recorder;\n        }\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    _resolveSymbolMembers(staticSymbol) {\n        const /** @type {?} */ members = staticSymbol.members;\n        const /** @type {?} */ baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        const /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            let /** @type {?} */ value = baseMetadata;\n            for (let /** @type {?} */ i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    _resolveSymbolFromSummary(staticSymbol) {\n        const /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    }\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members a symbol for a static member of the named type\n     * @return {?}\n     */\n    getStaticSymbol(declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    }\n    /**\n     * hasDecorators checks a file's metadata for the presense of decorators without evalutating the\n     * metadata.\n     *\n     * @param {?} filePath the absolute path to examine for decorators.\n     * @return {?} true if any class in the file has a decorator.\n     */\n    hasDecorators(filePath) {\n        const /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n        if (metadata['metadata']) {\n            return Object.keys(metadata['metadata']).some((metadataKey) => {\n                const /** @type {?} */ entry = metadata['metadata'][metadataKey];\n                return entry && entry.__symbolic === 'class' && entry.decorators;\n            });\n        }\n        return false;\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    getSymbolsOf(filePath) {\n        const /** @type {?} */ summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n        if (summarySymbols) {\n            return summarySymbols;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n        this._createSymbolsOf(filePath);\n        const /** @type {?} */ metadataSymbols = [];\n        this.resolvedSymbols.forEach((resolvedSymbol) => {\n            if (resolvedSymbol.symbol.filePath === filePath) {\n                metadataSymbols.push(resolvedSymbol.symbol);\n            }\n        });\n        return metadataSymbols;\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    _createSymbolsOf(filePath) {\n        if (this.resolvedFilePaths.has(filePath)) {\n            return;\n        }\n        this.resolvedFilePaths.add(filePath);\n        const /** @type {?} */ resolvedSymbols = [];\n        const /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n        if (metadata['importAs']) {\n            // Index bundle indices should use the importAs module name defined\n            // in the bundle.\n            this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            for (const /** @type {?} */ moduleExport of metadata['exports']) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach((exportSymbol) => {\n                        let /** @type {?} */ symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        let /** @type {?} */ symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            const /** @type {?} */ targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n                            const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // handle the symbols via export * directives.\n                    const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule) {\n                        const /** @type {?} */ nestedExports = this.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach((targetSymbol) => {\n                            const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            }\n        }\n        // handle the actual metadata. Has to be after the exports\n        // as there migth be collisions in the names, and we want the symbols\n        // of the current module to win ofter reexports.\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            const /** @type {?} */ topLevelSymbolNames = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            const /** @type {?} */ origins = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach((metadataKey) => {\n                const /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n                const /** @type {?} */ name = unescapeIdentifier(metadataKey);\n                const /** @type {?} */ symbol = this.getStaticSymbol(filePath, name);\n                const /** @type {?} */ origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    const /** @type {?} */ originFilePath = this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        this.reportError(new Error(`Couldn't resolve original symbol for ${origin} from ${filePath}`));\n                    }\n                    else {\n                        this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n            });\n        }\n        resolvedSymbols.forEach((resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n        this.symbolFromFile.set(filePath, resolvedSymbols.map(resolvedSymbol => resolvedSymbol.symbol));\n    }\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} topLevelPath\n     * @param {?} topLevelSymbolNames\n     * @param {?} metadata\n     * @return {?}\n     */\n    createResolvedSymbol(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata &&\n            metadata['__symbolic'] === 'class') {\n            const /** @type {?} */ transformedMeta = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n        }\n        const /** @type {?} */ self = this;\n        class ReferenceTransformer extends ValueTransformer {\n            /**\n             * @param {?} map\n             * @param {?} functionParams\n             * @return {?}\n             */\n            visitStringMap(map, functionParams) {\n                const /** @type {?} */ symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    const /** @type {?} */ oldLen = functionParams.length;\n                    functionParams.push(...(map['parameters'] || []));\n                    const /** @type {?} */ result = super.visitStringMap(map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    const /** @type {?} */ module = map['module'];\n                    const /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name) {\n                        return null;\n                    }\n                    let /** @type {?} */ filePath;\n                    if (module) {\n                        filePath = /** @type {?} */ ((self.resolveModule(module, sourceSymbol.filePath)));\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`\n                            };\n                        }\n                        return self.getStaticSymbol(filePath, name);\n                    }\n                    else if (functionParams.indexOf(name) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name)) {\n                            return self.getStaticSymbol(topLevelPath, name);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else {\n                    return super.visitStringMap(map, functionParams);\n                }\n            }\n        }\n        const /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        if (transformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, transformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    createExport(sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n            this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    }\n    /**\n     * @param {?} error\n     * @param {?=} context\n     * @param {?=} path\n     * @return {?}\n     */\n    reportError(error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    }\n    /**\n     * @param {?} module an absolute path to a module file.\n     * @return {?}\n     */\n    getModuleMetadata(module) {\n        let /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            const /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                let /** @type {?} */ maxVersion = -1;\n                moduleMetadatas.forEach((md) => {\n                    if (md['version'] > maxVersion) {\n                        maxVersion = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                const /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n                    `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n                    `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n                this.reportError(new Error(errorMessage));\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    }\n    /**\n     * @param {?} module\n     * @param {?} symbolName\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    getSymbolByModule(module, symbolName, containingFile) {\n        const /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(`Could not resolve module ${module}${containingFile ? ' relative to ' +\n                containingFile : ''}`));\n            return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    }\n    /**\n     * @param {?} module\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    resolveModule(module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (/** @type {?} */ e) {\n            console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n            this.reportError(e, undefined, containingFile);\n        }\n        return null;\n    }\n}\nfunction StaticSymbolResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StaticSymbolResolver.prototype.metadataCache;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.resolvedSymbols;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.resolvedFilePaths;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.importAs;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.symbolResourcePaths;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.symbolFromFile;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.knownFileNameToModuleNames;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.host;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.staticSymbolCache;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.summaryResolver;\n    /** @type {?} */\n    StaticSymbolResolver.prototype.errorRecorder;\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nexport function unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n//# sourceMappingURL=static_symbol_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { deserializeSummaries } from \"./summary_serializer\";\nimport { stripGeneratedFileSuffix, summaryFileName } from \"./util\";\n/**\n * @record\n */\nexport function AotSummaryResolverHost() { }\nfunction AotSummaryResolverHost_tsickle_Closure_declarations() {\n    /**\n     * Loads an NgModule/Directive/Pipe summary file\n     * @type {?}\n     */\n    AotSummaryResolverHost.prototype.loadSummary;\n    /**\n     * Returns whether a file is a source file or not.\n     * @type {?}\n     */\n    AotSummaryResolverHost.prototype.isSourceFile;\n    /**\n     * Converts a file name into a representation that should be stored in a summary file.\n     * This has to include changing the suffix as well.\n     * E.g.\n     * `some_file.ts` -> `some_file.d.ts`\n     *\n     * \\@param referringSrcFileName the soure file that refers to fileName\n     * @type {?}\n     */\n    AotSummaryResolverHost.prototype.toSummaryFileName;\n    /**\n     * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\n     * given the fileName of the library that is referrig to it.\n     * @type {?}\n     */\n    AotSummaryResolverHost.prototype.fromSummaryFileName;\n}\nexport class AotSummaryResolver {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     */\n    constructor(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Map();\n        this.importAs = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    isLibraryFile(filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n    }\n    /**\n     * @param {?} filePath\n     * @param {?} referringSrcFileName\n     * @return {?}\n     */\n    toSummaryFileName(filePath, referringSrcFileName) {\n        return this.host.toSummaryFileName(filePath, referringSrcFileName);\n    }\n    /**\n     * @param {?} fileName\n     * @param {?} referringLibFileName\n     * @return {?}\n     */\n    fromSummaryFileName(fileName, referringLibFileName) {\n        return this.host.fromSummaryFileName(fileName, referringLibFileName);\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    resolveSummary(staticSymbol) {\n        staticSymbol.assertNoMembers();\n        let /** @type {?} */ summary = this.summaryCache.get(staticSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = /** @type {?} */ ((this.summaryCache.get(staticSymbol)));\n        }\n        return summary || null;\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    getSymbolsOf(filePath) {\n        if (this._loadSummaryFile(filePath)) {\n            return Array.from(this.summaryCache.keys()).filter((symbol) => symbol.filePath === filePath);\n        }\n        return null;\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    getImportAs(staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return /** @type {?} */ ((this.importAs.get(staticSymbol)));\n    }\n    /**\n     * Converts a file path to a module name that can be used as an `import`.\n     * @param {?} importedFilePath\n     * @return {?}\n     */\n    getKnownModuleName(importedFilePath) {\n        return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    addSummary(summary) { this.summaryCache.set(summary.symbol, summary); }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    _loadSummaryFile(filePath) {\n        let /** @type {?} */ hasSummary = this.loadedFilePaths.get(filePath);\n        if (hasSummary != null) {\n            return hasSummary;\n        }\n        let /** @type {?} */ json = null;\n        if (this.isLibraryFile(filePath)) {\n            const /** @type {?} */ summaryFilePath = summaryFileName(filePath);\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (/** @type {?} */ e) {\n                console.error(`Error loading summary file ${summaryFilePath}`);\n                throw e;\n            }\n        }\n        hasSummary = json != null;\n        this.loadedFilePaths.set(filePath, hasSummary);\n        if (json) {\n            const { moduleName, summaries, importAs } = deserializeSummaries(this.staticSymbolCache, this, filePath, json);\n            summaries.forEach((summary) => this.summaryCache.set(summary.symbol, summary));\n            if (moduleName) {\n                this.knownFileNameToModuleNames.set(filePath, moduleName);\n            }\n            importAs.forEach((importAs) => { this.importAs.set(importAs.symbol, importAs.importAs); });\n        }\n        return hasSummary;\n    }\n}\nfunction AotSummaryResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    AotSummaryResolver.prototype.summaryCache;\n    /** @type {?} */\n    AotSummaryResolver.prototype.loadedFilePaths;\n    /** @type {?} */\n    AotSummaryResolver.prototype.importAs;\n    /** @type {?} */\n    AotSummaryResolver.prototype.knownFileNameToModuleNames;\n    /** @type {?} */\n    AotSummaryResolver.prototype.host;\n    /** @type {?} */\n    AotSummaryResolver.prototype.staticSymbolCache;\n}\n//# sourceMappingURL=summary_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CompilerConfig } from \"../config\";\nimport { ViewEncapsulation } from \"../core\";\nimport { DirectiveNormalizer } from \"../directive_normalizer\";\nimport { DirectiveResolver } from \"../directive_resolver\";\nimport { Lexer } from \"../expression_parser/lexer\";\nimport { Parser } from \"../expression_parser/parser\";\nimport { I18NHtmlParser } from \"../i18n/i18n_html_parser\";\nimport { CompileMetadataResolver } from \"../metadata_resolver\";\nimport { HtmlParser } from \"../ml_parser/html_parser\";\nimport { NgModuleCompiler } from \"../ng_module_compiler\";\nimport { NgModuleResolver } from \"../ng_module_resolver\";\nimport { TypeScriptEmitter } from \"../output/ts_emitter\";\nimport { PipeResolver } from \"../pipe_resolver\";\nimport { DomElementSchemaRegistry } from \"../schema/dom_element_schema_registry\";\nimport { StyleCompiler } from \"../style_compiler\";\nimport { TemplateParser } from \"../template_parser/template_parser\";\nimport { syntaxError } from \"../util\";\nimport { TypeCheckCompiler } from \"../view_compiler/type_check_compiler\";\nimport { ViewCompiler } from \"../view_compiler/view_compiler\";\nimport { AotCompiler } from \"./compiler\";\nimport { StaticReflector } from \"./static_reflector\";\nimport { StaticSymbolCache } from \"./static_symbol\";\nimport { StaticSymbolResolver } from \"./static_symbol_resolver\";\nimport { AotSummaryResolver } from \"./summary_resolver\";\n/**\n * @param {?} host\n * @return {?}\n */\nexport function createAotUrlResolver(host) {\n    return {\n        resolve: (basePath, url) => {\n            const /** @type {?} */ filePath = host.resourceNameToFileName(url, basePath);\n            if (!filePath) {\n                throw syntaxError(`Couldn't resolve resource ${url} from ${basePath}`);\n            }\n            return filePath;\n        }\n    };\n}\n/**\n * Creates a new AotCompiler based on options and a host.\n * @param {?} compilerHost\n * @param {?} options\n * @param {?=} errorCollector\n * @return {?}\n */\nexport function createAotCompiler(compilerHost, options, errorCollector) {\n    let /** @type {?} */ translations = options.translations || '';\n    const /** @type {?} */ urlResolver = createAotUrlResolver(compilerHost);\n    const /** @type {?} */ symbolCache = new StaticSymbolCache();\n    const /** @type {?} */ summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    const /** @type {?} */ symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    const /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);\n    const /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\n    const /** @type {?} */ config = new CompilerConfig({\n        defaultEncapsulation: ViewEncapsulation.Emulated,\n        useJit: false,\n        enableLegacyTemplate: options.enableLegacyTemplate === true,\n        missingTranslation: options.missingTranslation,\n        preserveWhitespaces: options.preserveWhitespaces,\n        strictInjectionParameters: options.strictInjectionParameters,\n    });\n    const /** @type {?} */ normalizer = new DirectiveNormalizer({ get: (url) => compilerHost.loadResource(url) }, urlResolver, htmlParser, config);\n    const /** @type {?} */ expressionParser = new Parser(new Lexer());\n    const /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n    const /** @type {?} */ tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    const /** @type {?} */ resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    const /** @type {?} */ viewCompiler = new ViewCompiler(staticReflector);\n    const /** @type {?} */ typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);\n    const /** @type {?} */ compiler = new AotCompiler(config, options, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler, new NgModuleCompiler(staticReflector), new TypeScriptEmitter(), summaryResolver, symbolResolver);\n    return { compiler, reflector: staticReflector };\n}\n//# sourceMappingURL=compiler_factory.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\nexport function Summary() { }\nfunction Summary_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Summary.prototype.symbol;\n    /** @type {?} */\n    Summary.prototype.metadata;\n    /** @type {?|undefined} */\n    Summary.prototype.type;\n}\n/**\n * @abstract\n */\nexport class SummaryResolver {\n}\nfunction SummaryResolver_tsickle_Closure_declarations() {\n    /**\n     * @abstract\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.isLibraryFile = function (fileName) { };\n    /**\n     * @abstract\n     * @param {?} fileName\n     * @param {?} referringSrcFileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.toSummaryFileName = function (fileName, referringSrcFileName) { };\n    /**\n     * @abstract\n     * @param {?} fileName\n     * @param {?} referringLibFileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.fromSummaryFileName = function (fileName, referringLibFileName) { };\n    /**\n     * @abstract\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.resolveSummary = function (reference) { };\n    /**\n     * @abstract\n     * @param {?} filePath\n     * @return {?}\n     */\n    SummaryResolver.prototype.getSymbolsOf = function (filePath) { };\n    /**\n     * @abstract\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.getImportAs = function (reference) { };\n    /**\n     * @abstract\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.getKnownModuleName = function (fileName) { };\n    /**\n     * @abstract\n     * @param {?} summary\n     * @return {?}\n     */\n    SummaryResolver.prototype.addSummary = function (summary) { };\n}\nexport class JitSummaryResolver {\n    constructor() {\n        this._summaries = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    isLibraryFile() { return false; }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    toSummaryFileName(fileName) { return fileName; }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    fromSummaryFileName(fileName) { return fileName; }\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    resolveSummary(reference) {\n        return this._summaries.get(reference) || null;\n    }\n    /**\n     * @return {?}\n     */\n    getSymbolsOf() { return []; }\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    getImportAs(reference) { return reference; }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    getKnownModuleName(fileName) { return null; }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    addSummary(summary) { this._summaries.set(summary.symbol, summary); }\n}\nfunction JitSummaryResolver_tsickle_Closure_declarations() {\n    /** @type {?} */\n    JitSummaryResolver.prototype._summaries;\n}\n//# sourceMappingURL=summary_resolver.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport * as o from \"./output_ast\";\nimport { debugOutputAstAsTypeScript } from \"./ts_emitter\";\n/**\n * @param {?} statements\n * @param {?} reflector\n * @return {?}\n */\nexport function interpretStatements(statements, reflector) {\n    const /** @type {?} */ ctx = new _ExecutionContext(null, null, null, new Map());\n    const /** @type {?} */ visitor = new StatementInterpreter(reflector);\n    visitor.visitAllStatements(statements, ctx);\n    const /** @type {?} */ result = {};\n    ctx.exports.forEach((exportName) => { result[exportName] = ctx.vars.get(exportName); });\n    return result;\n}\n/**\n * @param {?} varNames\n * @param {?} varValues\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    const /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n    for (let /** @type {?} */ i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    const /** @type {?} */ result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nclass _ExecutionContext {\n    /**\n     * @param {?} parent\n     * @param {?} instance\n     * @param {?} className\n     * @param {?} vars\n     */\n    constructor(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n        this.exports = [];\n    }\n    /**\n     * @return {?}\n     */\n    createChildWihtLocalVars() {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    }\n}\nfunction _ExecutionContext_tsickle_Closure_declarations() {\n    /** @type {?} */\n    _ExecutionContext.prototype.exports;\n    /** @type {?} */\n    _ExecutionContext.prototype.parent;\n    /** @type {?} */\n    _ExecutionContext.prototype.instance;\n    /** @type {?} */\n    _ExecutionContext.prototype.className;\n    /** @type {?} */\n    _ExecutionContext.prototype.vars;\n}\nclass ReturnValue {\n    /**\n     * @param {?} value\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\nfunction ReturnValue_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ReturnValue.prototype.value;\n}\n/**\n * @param {?} _classStmt\n * @param {?} _ctx\n * @param {?} _visitor\n * @return {?}\n */\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    const /** @type {?} */ propertyDescriptors = {};\n    _classStmt.getters.forEach((getter) => {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                const /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        const /** @type {?} */ paramNames = method.params.map(param => param.name);\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[/** @type {?} */ ((method.name))] = {\n            writable: false,\n            configurable: false,\n            value: function (...args) {\n                const /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    const /** @type {?} */ ctorParamNames = _classStmt.constructorMethod.params.map(param => param.name);\n    // Note: use `function` instead of arrow function to capture `this`\n    const /** @type {?} */ ctor = function (...args) {\n        const /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach((field) => { this[field.name] = undefined; });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    const /** @type {?} */ superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nclass StatementInterpreter {\n    /**\n     * @param {?} reflector\n     */\n    constructor(reflector) {\n        this.reflector = reflector;\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    debugAst(ast) { return debugOutputAstAsTypeScript(ast); }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareVarStmt(stmt, ctx) {\n        ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitWriteVarExpr(expr, ctx) {\n        const /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        let /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = /** @type {?} */ ((currCtx.parent));\n        }\n        throw new Error(`Not declared variable ${expr.name}`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadVarExpr(ast, ctx) {\n        let /** @type {?} */ varName = /** @type {?} */ ((ast.name));\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case o.BuiltinVar.Super:\n                    return ctx.instance.__proto__;\n                case o.BuiltinVar.This:\n                    return ctx.instance;\n                case o.BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR;\n                    break;\n                case o.BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR;\n                    break;\n                default:\n                    throw new Error(`Unknown builtin variable ${ast.builtin}`);\n            }\n        }\n        let /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = /** @type {?} */ ((currCtx.parent));\n        }\n        throw new Error(`Not declared variable ${varName}`);\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitWriteKeyExpr(expr, ctx) {\n        const /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        const /** @type {?} */ index = expr.index.visitExpression(this, ctx);\n        const /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitWritePropExpr(expr, ctx) {\n        const /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        const /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInvokeMethodExpr(expr, ctx) {\n        const /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        const /** @type {?} */ args = this.visitAllExpressions(expr.args, ctx);\n        let /** @type {?} */ result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case o.BuiltinMethod.ConcatArray:\n                    result = receiver.concat(...args);\n                    break;\n                case o.BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case o.BuiltinMethod.Bind:\n                    result = receiver.bind(...args);\n                    break;\n                default:\n                    throw new Error(`Unknown builtin method ${expr.builtin}`);\n            }\n        }\n        else {\n            result = receiver[/** @type {?} */ ((expr.name))].apply(receiver, args);\n        }\n        return result;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInvokeFunctionExpr(stmt, ctx) {\n        const /** @type {?} */ args = this.visitAllExpressions(stmt.args, ctx);\n        const /** @type {?} */ fnExpr = stmt.fn;\n        if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            const /** @type {?} */ fn = stmt.fn.visitExpression(this, ctx);\n            return fn.apply(null, args);\n        }\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReturnStmt(stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, ctx) {\n        const /** @type {?} */ clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitExpressionStmt(stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitIfStmt(stmt, ctx) {\n        const /** @type {?} */ condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitTryCatchStmt(stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (/** @type {?} */ e) {\n            const /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR, e);\n            childCtx.vars.set(CATCH_STACK_VAR, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitThrowStmt(stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?=} context\n     * @return {?}\n     */\n    visitCommentStmt(stmt, context) { return null; }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInstantiateExpr(ast, ctx) {\n        const /** @type {?} */ args = this.visitAllExpressions(ast.args, ctx);\n        const /** @type {?} */ clazz = ast.classExpr.visitExpression(this, ctx);\n        return new clazz(...args);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralExpr(ast, ctx) { return ast.value; }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitExternalExpr(ast, ctx) {\n        return this.reflector.resolveExternalReference(ast.value);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitConditionalExpr(ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitNotExpr(ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitAssertNotNullExpr(ast, ctx) {\n        return ast.condition.visitExpression(this, ctx);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitCastExpr(ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitFunctionExpr(ast, ctx) {\n        const /** @type {?} */ paramNames = ast.params.map((param) => param.name);\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, ctx) {\n        const /** @type {?} */ paramNames = stmt.params.map((param) => param.name);\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitBinaryOperatorExpr(ast, ctx) {\n        const /** @type {?} */ lhs = () => ast.lhs.visitExpression(this, ctx);\n        const /** @type {?} */ rhs = () => ast.rhs.visitExpression(this, ctx);\n        switch (ast.operator) {\n            case o.BinaryOperator.Equals:\n                return lhs() == rhs();\n            case o.BinaryOperator.Identical:\n                return lhs() === rhs();\n            case o.BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case o.BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case o.BinaryOperator.And:\n                return lhs() && rhs();\n            case o.BinaryOperator.Or:\n                return lhs() || rhs();\n            case o.BinaryOperator.Plus:\n                return lhs() + rhs();\n            case o.BinaryOperator.Minus:\n                return lhs() - rhs();\n            case o.BinaryOperator.Divide:\n                return lhs() / rhs();\n            case o.BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case o.BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case o.BinaryOperator.Lower:\n                return lhs() < rhs();\n            case o.BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case o.BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case o.BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadPropExpr(ast, ctx) {\n        let /** @type {?} */ result;\n        const /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadKeyExpr(ast, ctx) {\n        const /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        const /** @type {?} */ prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralArrayExpr(ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitLiteralMapExpr(ast, ctx) {\n        const /** @type {?} */ result = {};\n        ast.entries.forEach(entry => result[entry.key] = entry.value.visitExpression(this, ctx));\n        return result;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    visitCommaExpr(ast, context) {\n        const /** @type {?} */ values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    }\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitAllExpressions(expressions, ctx) {\n        return expressions.map((expr) => expr.visitExpression(this, ctx));\n    }\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitAllStatements(statements, ctx) {\n        for (let /** @type {?} */ i = 0; i < statements.length; i++) {\n            const /** @type {?} */ stmt = statements[i];\n            const /** @type {?} */ val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    }\n}\nfunction StatementInterpreter_tsickle_Closure_declarations() {\n    /** @type {?} */\n    StatementInterpreter.prototype.reflector;\n}\n/**\n * @param {?} varNames\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return (...args) => _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n}\nconst /** @type {?} */ CATCH_ERROR_VAR = 'error';\nconst /** @type {?} */ CATCH_STACK_VAR = 'stack';\n//# sourceMappingURL=output_interpreter.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { AbstractEmitterVisitor, CATCH_ERROR_VAR, CATCH_STACK_VAR } from \"./abstract_emitter\";\nimport * as o from \"./output_ast\";\n/**\n * @abstract\n */\nexport class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n    constructor() { super(false); }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, ctx) {\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, `.prototype);`);\n        }\n        stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));\n        stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));\n        ctx.popClass();\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassConstructor(stmt, ctx) {\n        ctx.print(stmt, `function ${stmt.name}(`);\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, `var self = this;`);\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassGetter(stmt, getter, ctx) {\n        ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, `var self = this;`);\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, `}});`);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitClassMethod(stmt, method, ctx) {\n        ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, `var self = this;`);\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, `};`);\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitReadVarExpr(ast, ctx) {\n        if (ast.builtin === o.BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === o.BuiltinVar.Super) {\n            throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);\n        }\n        else {\n            super.visitReadVarExpr(ast, ctx);\n        }\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareVarStmt(stmt, ctx) {\n        ctx.print(stmt, `var ${stmt.name} = `);\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, `;`);\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitCastExpr(ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    }\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitInvokeFunctionExpr(expr, ctx) {\n        const /** @type {?} */ fnExpr = expr.fn;\n        if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n            /** @type {?} */ ((/** @type {?} */ ((ctx.currentClass)).parent)).visitExpression(this, ctx);\n            ctx.print(expr, `.call(this`);\n            if (expr.args.length > 0) {\n                ctx.print(expr, `, `);\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, `)`);\n        }\n        else {\n            super.visitInvokeFunctionExpr(expr, ctx);\n        }\n        return null;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitFunctionExpr(ast, ctx) {\n        ctx.print(ast, `function(`);\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, `}`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, ctx) {\n        ctx.print(stmt, `function ${stmt.name}(`);\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitTryCatchStmt(stmt, ctx) {\n        ctx.println(stmt, `try {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `} catch (${CATCH_ERROR_VAR.name}) {`);\n        ctx.incIndent();\n        const /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR.set(CATCH_ERROR_VAR.prop('stack')).toDeclStmt(null, [\n                o.StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    _visitParams(params, ctx) {\n        this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n    }\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    getBuiltinMethodName(method) {\n        let /** @type {?} */ name;\n        switch (method) {\n            case o.BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case o.BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case o.BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(`Unknown builtin method: ${method}`);\n        }\n        return name;\n    }\n}\n//# sourceMappingURL=abstract_js_emitter.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { identifierName } from \"../compile_metadata\";\nimport { EmitterVisitorContext } from \"./abstract_emitter\";\nimport { AbstractJsEmitterVisitor } from \"./abstract_js_emitter\";\nimport * as o from \"./output_ast\";\n/**\n * @param {?} sourceUrl\n * @param {?} ctx\n * @param {?} vars\n * @param {?} createSourceMap\n * @return {?}\n */\nfunction evalExpression(sourceUrl, ctx, vars, createSourceMap) {\n    let /** @type {?} */ fnBody = `${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const /** @type {?} */ fnArgNames = [];\n    const /** @type {?} */ fnArgValues = [];\n    for (const /** @type {?} */ argName in vars) {\n        fnArgNames.push(argName);\n        fnArgValues.push(vars[argName]);\n    }\n    if (createSourceMap) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        const /** @type {?} */ emptyFn = new Function(...fnArgNames.concat('return null;')).toString();\n        const /** @type {?} */ headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    return new Function(...fnArgNames.concat(fnBody))(...fnArgValues);\n}\n/**\n * @param {?} sourceUrl\n * @param {?} statements\n * @param {?} reflector\n * @param {?} createSourceMaps\n * @return {?}\n */\nexport function jitStatements(sourceUrl, statements, reflector, createSourceMaps) {\n    const /** @type {?} */ converter = new JitEmitterVisitor(reflector);\n    const /** @type {?} */ ctx = EmitterVisitorContext.createRoot();\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return evalExpression(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n}\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n    /**\n     * @param {?} reflector\n     */\n    constructor(reflector) {\n        super();\n        this.reflector = reflector;\n        this._evalArgNames = [];\n        this._evalArgValues = [];\n        this._evalExportedVars = [];\n    }\n    /**\n     * @param {?} ctx\n     * @return {?}\n     */\n    createReturnStmt(ctx) {\n        const /** @type {?} */ stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n        stmt.visitStatement(this, ctx);\n    }\n    /**\n     * @return {?}\n     */\n    getArgs() {\n        const /** @type {?} */ result = {};\n        for (let /** @type {?} */ i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitExternalExpr(ast, ctx) {\n        const /** @type {?} */ value = this.reflector.resolveExternalReference(ast.value);\n        let /** @type {?} */ id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            const /** @type {?} */ name = identifierName({ reference: value }) || 'val';\n            this._evalArgNames.push(`jit_${name}_${id}`);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n        return null;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareVarStmt(stmt, ctx) {\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareVarStmt(stmt, ctx);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareFunctionStmt(stmt, ctx) {\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareFunctionStmt(stmt, ctx);\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    visitDeclareClassStmt(stmt, ctx) {\n        if (stmt.hasModifier(o.StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareClassStmt(stmt, ctx);\n    }\n}\nfunction JitEmitterVisitor_tsickle_Closure_declarations() {\n    /** @type {?} */\n    JitEmitterVisitor.prototype._evalArgNames;\n    /** @type {?} */\n    JitEmitterVisitor.prototype._evalArgValues;\n    /** @type {?} */\n    JitEmitterVisitor.prototype._evalExportedVars;\n    /** @type {?} */\n    JitEmitterVisitor.prototype.reflector;\n}\n//# sourceMappingURL=output_jit.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { identifierName, ngModuleJitUrl, sharedStylesheetJitUrl, templateJitUrl, templateSourceUrl } from \"../compile_metadata\";\nimport * as ir from \"../output/output_ast\";\nimport { interpretStatements } from \"../output/output_interpreter\";\nimport { jitStatements } from \"../output/output_jit\";\nimport { SyncAsync, stringify } from \"../util\";\n/**\n * @record\n */\nexport function ModuleWithComponentFactories() { }\nfunction ModuleWithComponentFactories_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ModuleWithComponentFactories.prototype.ngModuleFactory;\n    /** @type {?} */\n    ModuleWithComponentFactories.prototype.componentFactories;\n}\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * \\@security When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nexport class JitCompiler {\n    /**\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _summaryResolver\n     * @param {?} _reflector\n     * @param {?} _compilerConfig\n     * @param {?} _console\n     * @param {?} getExtraNgModuleProviders\n     */\n    constructor(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _compilerConfig, _console, getExtraNgModuleProviders) {\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._summaryResolver = _summaryResolver;\n        this._reflector = _reflector;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this.getExtraNgModuleProviders = getExtraNgModuleProviders;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n    }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleSync(moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n    }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleAsync(moduleType) {\n        return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n    }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleAndAllComponentsSync(moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n    }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    compileModuleAndAllComponentsAsync(moduleType) {\n        return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n    }\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    getComponentFactory(component) {\n        const /** @type {?} */ summary = this._metadataResolver.getDirectiveSummary(component);\n        return /** @type {?} */ (summary.componentFactory);\n    }\n    /**\n     * @param {?} summaries\n     * @return {?}\n     */\n    loadAotSummaries(summaries) {\n        this.clearCache();\n        flattenSummaries(summaries).forEach((summary) => {\n            this._summaryResolver.addSummary({ symbol: summary.type.reference, metadata: null, type: summary });\n        });\n    }\n    /**\n     * @param {?} ref\n     * @return {?}\n     */\n    hasAotSummary(ref) { return !!this._summaryResolver.resolveSummary(ref); }\n    /**\n     * @param {?} ids\n     * @return {?}\n     */\n    _filterJitIdentifiers(ids) {\n        return ids.map(mod => mod.reference).filter((ref) => !this.hasAotSummary(ref));\n    }\n    /**\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    _compileModuleAndComponents(moduleType, isSync) {\n        return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\n            this._compileComponents(moduleType, null);\n            return this._compileModule(moduleType);\n        });\n    }\n    /**\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    _compileModuleAndAllComponents(moduleType, isSync) {\n        return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\n            const /** @type {?} */ componentFactories = [];\n            this._compileComponents(moduleType, componentFactories);\n            return {\n                ngModuleFactory: this._compileModule(moduleType),\n                componentFactories: componentFactories\n            };\n        });\n    }\n    /**\n     * @param {?} mainModule\n     * @param {?} isSync\n     * @return {?}\n     */\n    _loadModules(mainModule, isSync) {\n        const /** @type {?} */ loading = [];\n        const /** @type {?} */ mainNgModule = /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(mainModule)));\n        // Note: for runtime compilation, we want to transitively compile all modules,\n        // so we also need to load the declared directives / pipes for all nested modules.\n        this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach((nestedNgModule) => {\n            // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n            const /** @type {?} */ moduleMeta = /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(nestedNgModule)));\n            this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach((ref) => {\n                const /** @type {?} */ promise = this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            this._filterJitIdentifiers(moduleMeta.declaredPipes)\n                .forEach((ref) => this._metadataResolver.getOrLoadPipeMetadata(ref));\n        });\n        return SyncAsync.all(loading);\n    }\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    _compileModule(moduleType) {\n        let /** @type {?} */ ngModuleFactory = /** @type {?} */ ((this._compiledNgModuleCache.get(moduleType)));\n        if (!ngModuleFactory) {\n            const /** @type {?} */ moduleMeta = /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(moduleType)));\n            // Always provide a bound Compiler\n            const /** @type {?} */ extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n            const /** @type {?} */ outputCtx = createOutputContext();\n            const /** @type {?} */ compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n            ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n            this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    }\n    /**\n     * \\@internal\n     * @param {?} mainModule\n     * @param {?} allComponentFactories\n     * @return {?}\n     */\n    _compileComponents(mainModule, allComponentFactories) {\n        const /** @type {?} */ ngModule = /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(mainModule)));\n        const /** @type {?} */ moduleByJitDirective = new Map();\n        const /** @type {?} */ templates = new Set();\n        const /** @type {?} */ transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n        transJitModules.forEach((localMod) => {\n            const /** @type {?} */ localModuleMeta = /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(localMod)));\n            this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\n                moduleByJitDirective.set(dirRef, localModuleMeta);\n                const /** @type {?} */ dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    templates.add(this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        const /** @type {?} */ template = this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(/** @type {?} */ (dirMeta.componentFactory));\n                    }\n                }\n            });\n        });\n        transJitModules.forEach((localMod) => {\n            const /** @type {?} */ localModuleMeta = /** @type {?} */ ((this._metadataResolver.getNgModuleMetadata(localMod)));\n            this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\n                const /** @type {?} */ dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach((entryComponentType) => {\n                        const /** @type {?} */ moduleMeta = /** @type {?} */ ((moduleByJitDirective.get(entryComponentType.componentType)));\n                        templates.add(this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach((entryComponentType) => {\n                if (!this.hasAotSummary(entryComponentType.componentType.reference)) {\n                    const /** @type {?} */ moduleMeta = /** @type {?} */ ((moduleByJitDirective.get(entryComponentType.componentType)));\n                    templates.add(this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                }\n            });\n        });\n        templates.forEach((template) => this._compileTemplate(template));\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    clearCacheFor(type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        const /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    clearCache() {\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    }\n    /**\n     * @param {?} compType\n     * @param {?} ngModule\n     * @return {?}\n     */\n    _createCompiledHostTemplate(compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(`Component ${stringify(compType)} is not part of any NgModule or the module has not been imported into your module.`);\n        }\n        let /** @type {?} */ compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            const /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            const /** @type {?} */ hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, (/** @type {?} */ (compMeta.componentFactory)).viewDefFactory);\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    }\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @return {?}\n     */\n    _createCompiledTemplate(compMeta, ngModule) {\n        let /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    }\n    /**\n     * @param {?} template\n     * @return {?}\n     */\n    _compileTemplate(template) {\n        if (template.isCompiled) {\n            return;\n        }\n        const /** @type {?} */ compMeta = template.compMeta;\n        const /** @type {?} */ externalStylesheetsByModuleUrl = new Map();\n        const /** @type {?} */ outputContext = createOutputContext();\n        const /** @type {?} */ componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta); /** @type {?} */\n        ((compMeta.template)).externalStylesheets.forEach((stylesheetMeta) => {\n            const /** @type {?} */ compiledStylesheet = this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n            externalStylesheetsByModuleUrl.set(/** @type {?} */ ((stylesheetMeta.moduleUrl)), compiledStylesheet);\n        });\n        this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n        const /** @type {?} */ pipes = template.ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n        const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, template.ngModule, template.directives);\n        const /** @type {?} */ compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, ir.variable(componentStylesheet.stylesVar), usedPipes);\n        const /** @type {?} */ evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n        const /** @type {?} */ viewClass = evalResult[compileResult.viewClassVar];\n        const /** @type {?} */ rendererType = evalResult[compileResult.rendererTypeVar];\n        template.compiled(viewClass, rendererType);\n    }\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @return {?}\n     */\n    _parseTemplate(compMeta, ngModule, directiveIdentifiers) {\n        // Note: ! is ok here as components always have a template.\n        const /** @type {?} */ preserveWhitespaces = /** @type {?} */ ((compMeta.template)).preserveWhitespaces;\n        const /** @type {?} */ directives = directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n        const /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n        return this._templateParser.parse(compMeta, /** @type {?} */ ((/** @type {?} */ ((compMeta.template)).htmlAst)), directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, /** @type {?} */ ((compMeta.template))), preserveWhitespaces);\n    }\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl) {\n        result.dependencies.forEach((dep, i) => {\n            const /** @type {?} */ nestedCompileResult = /** @type {?} */ ((externalStylesheetsByModuleUrl.get(dep.moduleUrl)));\n            const /** @type {?} */ nestedStylesArr = this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.setValue(nestedStylesArr);\n        });\n    }\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\n    }\n    /**\n     * @param {?} sourceUrl\n     * @param {?} statements\n     * @return {?}\n     */\n    _interpretOrJit(sourceUrl, statements) {\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(statements, this._reflector);\n        }\n        else {\n            return jitStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n        }\n    }\n}\nfunction JitCompiler_tsickle_Closure_declarations() {\n    /** @type {?} */\n    JitCompiler.prototype._compiledTemplateCache;\n    /** @type {?} */\n    JitCompiler.prototype._compiledHostTemplateCache;\n    /** @type {?} */\n    JitCompiler.prototype._compiledDirectiveWrapperCache;\n    /** @type {?} */\n    JitCompiler.prototype._compiledNgModuleCache;\n    /** @type {?} */\n    JitCompiler.prototype._sharedStylesheetCount;\n    /** @type {?} */\n    JitCompiler.prototype._metadataResolver;\n    /** @type {?} */\n    JitCompiler.prototype._templateParser;\n    /** @type {?} */\n    JitCompiler.prototype._styleCompiler;\n    /** @type {?} */\n    JitCompiler.prototype._viewCompiler;\n    /** @type {?} */\n    JitCompiler.prototype._ngModuleCompiler;\n    /** @type {?} */\n    JitCompiler.prototype._summaryResolver;\n    /** @type {?} */\n    JitCompiler.prototype._reflector;\n    /** @type {?} */\n    JitCompiler.prototype._compilerConfig;\n    /** @type {?} */\n    JitCompiler.prototype._console;\n    /** @type {?} */\n    JitCompiler.prototype.getExtraNgModuleProviders;\n}\nclass CompiledTemplate {\n    /**\n     * @param {?} isHost\n     * @param {?} compType\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directives\n     */\n    constructor(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = /** @type {?} */ ((null));\n        this.isCompiled = false;\n    }\n    /**\n     * @param {?} viewClass\n     * @param {?} rendererType\n     * @return {?}\n     */\n    compiled(viewClass, rendererType) {\n        this._viewClass = viewClass;\n        (/** @type {?} */ (this.compMeta.componentViewType)).setDelegate(viewClass);\n        for (let /** @type {?} */ prop in rendererType) {\n            (/** @type {?} */ (this.compMeta.rendererType))[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    }\n}\nfunction CompiledTemplate_tsickle_Closure_declarations() {\n    /** @type {?} */\n    CompiledTemplate.prototype._viewClass;\n    /** @type {?} */\n    CompiledTemplate.prototype.isCompiled;\n    /** @type {?} */\n    CompiledTemplate.prototype.isHost;\n    /** @type {?} */\n    CompiledTemplate.prototype.compType;\n    /** @type {?} */\n    CompiledTemplate.prototype.compMeta;\n    /** @type {?} */\n    CompiledTemplate.prototype.ngModule;\n    /** @type {?} */\n    CompiledTemplate.prototype.directives;\n}\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(`Could not compile '${identifierName(meta.type)}' because it is not a component.`);\n    }\n}\n/**\n * @param {?} fn\n * @param {?=} out\n * @param {?=} seen\n * @return {?}\n */\nfunction flattenSummaries(fn, out = [], seen = new Set()) {\n    if (seen.has(fn)) {\n        return out;\n    }\n    seen.add(fn);\n    const /** @type {?} */ summaries = fn();\n    for (let /** @type {?} */ i = 0; i < summaries.length; i++) {\n        const /** @type {?} */ entry = summaries[i];\n        if (typeof entry === 'function') {\n            flattenSummaries(entry, out, seen);\n        }\n        else {\n            out.push(entry);\n        }\n    }\n    return out;\n}\n/**\n * @return {?}\n */\nfunction createOutputContext() {\n    const /** @type {?} */ importExpr = (symbol) => ir.importExpr({ name: identifierName(symbol), moduleName: null, runtime: symbol });\n    return { statements: [], genFilePath: '', importExpr };\n}\n//# sourceMappingURL=compiler.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Provides access to reflection data about symbols that the compiler needs.\n * @abstract\n */\nexport class CompileReflector {\n}\nfunction CompileReflector_tsickle_Closure_declarations() {\n    /**\n     * @abstract\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileReflector.prototype.parameters = function (typeOrFunc) { };\n    /**\n     * @abstract\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileReflector.prototype.annotations = function (typeOrFunc) { };\n    /**\n     * @abstract\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileReflector.prototype.propMetadata = function (typeOrFunc) { };\n    /**\n     * @abstract\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    CompileReflector.prototype.hasLifecycleHook = function (type, lcProperty) { };\n    /**\n     * @abstract\n     * @param {?} type\n     * @param {?} cmpMetadata\n     * @return {?}\n     */\n    CompileReflector.prototype.componentModuleUrl = function (type, cmpMetadata) { };\n    /**\n     * @abstract\n     * @param {?} ref\n     * @return {?}\n     */\n    CompileReflector.prototype.resolveExternalReference = function (ref) { };\n}\n//# sourceMappingURL=compile_reflector.js.map","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Create a {\\@link UrlResolver} with no package prefix.\n * @return {?}\n */\nexport function createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\n/**\n * @return {?}\n */\nexport function createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\n/**\n * @record\n */\nexport function UrlResolverCtor() { }\nfunction UrlResolverCtor_tsickle_Closure_declarations() {\n    /* TODO: handle strange member:\n    new (packagePrefix?: string|null): UrlResolver;\n    */\n}\nexport const /** @type {?} */ UrlResolver = class UrlResolverImpl {\n    /**\n     * @param {?=} _packagePrefix\n     */\n    constructor(_packagePrefix = null) {\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     * @param {?} baseUrl\n     * @param {?} url\n     * @return {?}\n     */\n    resolve(baseUrl, url) {\n        let /** @type {?} */ resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        const /** @type {?} */ resolvedParts = _split(resolvedUrl);\n        let /** @type {?} */ prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            let /** @type {?} */ path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return `${prefix}/${path}`;\n        }\n        return resolvedUrl;\n    }\n};\n/**\n * Extract the scheme of a URL.\n * @param {?} url\n * @return {?}\n */\nexport function getUrlScheme(url) {\n    const /** @type {?} */ match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?=} opt_scheme The scheme such as 'http'.\n * @param {?=} opt_userInfo The user name before the '\\@'.\n * @param {?=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {?=} opt_port The port number.\n * @param {?=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?=} opt_queryData The URI-encoded query data.\n * @param {?=} opt_fragment The URI-encoded fragment identifier.\n * @return {?} The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    const /** @type {?} */ out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {\\@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * \\@internal\n */\nconst /** @type {?} */ _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' +\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\n    '(?::([0-9]+))?' +\n    ')?' +\n    '([^?#]+)?' +\n    '(?:\\\\?([^#]*))?' +\n    '(?:#(.*))?' +\n    '$');\n/** @enum {number} */\nconst _ComponentIndex = {\n    Scheme: 1,\n    UserInfo: 2,\n    Domain: 3,\n    Port: 4,\n    Path: 5,\n    QueryData: 6,\n    Fragment: 7,\n};\n_ComponentIndex[_ComponentIndex.Scheme] = \"Scheme\";\n_ComponentIndex[_ComponentIndex.UserInfo] = \"UserInfo\";\n_ComponentIndex[_ComponentIndex.Domain] = \"Domain\";\n_ComponentIndex[_ComponentIndex.Port] = \"Port\";\n_ComponentIndex[_ComponentIndex.Path] = \"Path\";\n_ComponentIndex[_ComponentIndex.QueryData] = \"QueryData\";\n_ComponentIndex[_ComponentIndex.Fragment] = \"Fragment\";\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {?} uri The URI string to examine.\n * @return {?} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return /** @type {?} */ ((uri.match(_splitRe)));\n}\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {?} path A non-empty path component.\n * @return {?} Path component with removed dot segments.\n */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    const /** @type {?} */ leadingSlash = path[0] == '/' ? '/' : '';\n    const /** @type {?} */ trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    const /** @type {?} */ segments = path.split('/');\n    const /** @type {?} */ out = [];\n    let /** @type {?} */ up = 0;\n    for (let /** @type {?} */ pos = 0; pos < segments.length; pos++) {\n        const /** @type {?} */ segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n * @param {?} parts\n * @return {?}\n */\nfunction _joinAndCanonicalizePath(parts) {\n    let /** @type {?} */ path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, 